* Ascii/Iambic morse keyer (and more) using Jack audio connection kit.
  This is a morse code keyer consisting of jack audio connection kit
  plugins, a hardware interface, and a variety of additional Tcl
  hosted SDR tools for testing and playing with them.

  The keyer-control application launches iambic and ascii keyers with
  independent tone generators, wires them up, and allows their
  parameters to be fiddled with.

  The essential prerequisites for using this are a computer running
  Linux to build and to host the applications. With that you can run
  the ascii keyer, listen to the output, examine the waveforms, and
  see how the system works.  You can also launch the mouse key
  application and hook it up to the iambic keyer, though mouse buttons
  or key board keys do not make for a great telegraphy experience.

  Adding a MidiKeyer USB dongle will allow you to translate your
  paddle or straight key switch closures into MIDI events and transmit
  them to the computer over USB.  With that you can fully exercise the
  iambic keyer and play with some of the games which require you to
  key in the answers.
* Prerequisites
  I've written these instructions as I use them on a laptop running
  Ubuntu 11.10, the Oneiric Ocelot release.  Most of it is generic
  enough to work on other current Linux systems with minor
  translations of package management tools and package names. It's
  also generic enough to port to MacOS or Windows.  But I don't run
  other Linux systems, MacOS, or Windows so asking me to help you make
  it work is a lost cause, unless you want moral support.

  I will be assuming that you have installed the keyer sources in your
  home directory, which I abbreviate as "~".  So I will refer to the
  keyer source directory as "~/keyer" in all that follows.   It
  doesn't depend on being there, you can install it anywhere, and that
  isn't where I install it.  But these instructions will depend on you
  making the necessary translation if you install the sources
  someplace else.
** Required packages
   Using your preferred Ubuntu package manager, you want to install
   the following packages:
   | build-essentials   |
   | git-core           |
   | jackd2             |
   | libfftw3-dev       |
   | libjack-jackd2-dev |
   | qjackctl           |
   | tk-dev             |
   These are not all the required packages.  Several other packages
   will be dragged in because they're required by the packages
   listed.

   The "apt-get" command to install these packages is
   #+BEGIN_EXAMPLE
   sudo apt-get install build-essentials git-core jackd2 libfftw3-dev libjack-jackd2-dev qjackctl tk-dev
   #+END_EXAMPLE

   Note that Ubuntu 11.10 has some confusion in the packaging of jackd.
   Some audio packages were built against jackd1 and some against the
   jackd agnostic package, so some audio libraries will force
   installation  of the old jackd version 1 package.  I force jackd2
   because it's what I use.  I don't know if jackd1 will work.
** Getting the source
   The sources are archived at https://github.com/recri/keyer.
   Assuming that you want the sources to be in ~/keyer,
   #+BEGIN_EXAMPLE
   cd ~ && git clone https://github.com/recri/keyer
   #+END_EXAMPLE
   will create a new directory named "keyer" in your home directory.
   The sources will be up to date as of the time that you clone the 
   repository.

   Running:
   #+BEGIN_EXAMPLE
   cd ~/keyer && git pull origin master
   #+END_EXAMPLE
   will refresh your sources to the most recent at any time.  It's
   prudent to run: 
   #+BEGIN_EXAMPLE
   cd ~/keyer && make all-clean
   #+END_EXAMPLE
   before refreshing the sources because the list of things to be built
   and cleaned up is changing all the time.

   If things get messed up (and you have no local changes to preserve)
   you can always:
   #+BEGIN_EXAMPLE
   cd ~ && rm -fr keyer && git clone https://github.com/recri/keyer
   #+END_EXAMPLE
   to start over again from a clean copy.
** Building
   #+BEGIN_EXAMPLE
   cd ~/keyer && make
   #+END_EXAMPLE
   will compile everything needed to run.  If you have problems,
   please go back to the list of required packages and make sure you
   didn't miss one.
   #+BEGIN_EXAMPLE
   cd ~/keyer && make clean
   #+END_EXAMPLE
   will remove intermediate files not required to run.
   #+BEGIN_EXAMPLE
   cd ~/keyer && make all-clean
   #+END_EXAMPLE
   should remove all built files.
** Installing
   I don't do any install. I usually run the scripts from ~/keyer
   manually prefixing bin/ to get the commands I want to run.
** MidiKey
  The whole point is to get CW keying information into the computer
  with the lowest latency possible.  To do that you'll need a
  MIDI-USB-Keyer dongle to hookup your straight key or paddle.

  I started with a paddle interface built on a breadboard from a
  Teensy 2.0 (from http://www.pjrc.com/teensy/), a stereo audio jack,
  and three jumper wires.
| Teensy B0     | -> | stereo jack dit    |
| Teensy B1     | -> | stereo jack dah    |
| Teensy GND    | -> | stereo jack common |
| Iambic paddle | -> | stereo jack        |
| Teensy USB    | -> | computer           |

  [[https://github.com/recri/keyer/blob/master/images/keyer-1.jpg][Blurry image1]], [[https://github.com/recri/keyer/blob/master/images/keyer-2.jpg][Blurry image2]], [[https://github.com/recri/keyer/blob/master/images/keyer-3.jpg][Blurry image3]].

  The Teensyduino application to translate paddle transitions into
  MIDI events is in MidiKey/MidiKey.ino.  The instructions for building
  it are in the source code.

  I've packaged the keyer dongle into an Altoids Smalls tin, shown
  [[https://github.com/recri/keyer/blob/master/images/keyer-8.jpg][in the tin]], and [[https://github.com/recri/keyer/blob/master/images/keyer-7.jpg][exposed]]. The perf board is supported on 5/8"
  standoffs   of the bottom of the tin.  The Teensy is mounted on
  upside down header pins, short end through the perf board long end
  through the Teensy mounting holes. The Teensy and stereo jack are
  super glued onto the perf board.  The stereo jack lugs are soldered
  to a set of five header pins.  The rest of the connections are
  wire-wrapped between long legs of header pins.

  The set of 11 pins at the left edge of the [[https://github.com/recri/keyer/blob/master/images/keyer-7.jpg][exposed]] image is a
  Sparkfun Blackberry trackball breakout which is unsupported in the
  software at the moment.  You can see the trackball erupting through
  [[https://github.com/recri/keyer/blob/master/images/keyer-8.jpg][the tin]].
  
  In retrospect, I'd switch to using input pins closer to the stereo
  jack end of the Teensy.

  Glen Overby provoked this project on the dttsp list at yahoo back in
  November 2011.  He has built another MIDI key interface which is
  described [[http://reality.sgiweb.org/overby/ham/Equipment/Key-Adapter/index.html][here]]. It should work with this software if the MIDI note
  is set properly.
* Usage
  My basic usage pattern is to use qjackctl to configure my jack
  server, start the server, control the server, and manually make
  connections between modules.

  Some of the commands will automatically make connections to a
  default set of ports, if the port names match with their
  expectations.  You can view what happens with qjackctl.
  
  You can configure your jack server to "autolaunch" whenever an
  application tries to open it, but the result will be that you get a 
  bunch of messages from jackd which appear to come from your
  application, the messages look pretty much the same whether jackd
  succeeds or fails to start, and the autolaunched jackd may or may
  not be visible and controllable from qjackctl.  So turn off the
  autolaunch feature and use qjackctl so you can see what's
  happening.

  All of the commands in ~/keyer/bin are now Tcl/Tk scripts. I may or
  may not describe what they do.  Some of them may go away or change
  drastically as I figure out what I'm doing.  So for the fullest
  documentation of the options each script implements, you should open
  the script file in a text editor and scroll to the end of the file.
  Each application should define a "main" procedure which parses
  command line options, and you should be able to figure out what the
  options do.
** Abstraction
   The code is evolving toward a really nice set of abstractions and
   implementations, but it's a bit of a mess at the moment and will
   continue to be a mess until I get it right.

   My basic gripe with existing SDR code is that it's hard to see what
   it does because it's usually buried inside some baroque mechanism
   for putting it together into the radio.  I can't see the parts
   because they've been potted in hot glue to stick them together.

   I've extracted the bits that do the work into one library, and
   settled on using Tcl/Tk and Jack as the glue to put the parts
   together.  So you can see the computations without the glue, and
   then glue them together in a script to see how they work.
*** sdrkit - just the bits
    Sdrkit is plain SDR implementations in c and c++ without
    any distracting details.  Oscillators, filters, mixers,
    demodulation, modulation, keyers, debouncers, and so on.
    I'll include as many alternate implementations as I find the time
    to excavate for comparison. This is where you go to figure out how
    a particular computation is performed or to steal code for your
    own use.

    I'm doing sdrkit entirely as header files.  This is a bit
    different from the usual hide the implementation one place and
    expose an interface someplace else, but I've got nothing to hide
    and I get tired of groveling all over the place trying to figure
    out how things work.  It may not work out in the end, but it's
    worked so far for me.  You include the header which defines an
    interface and an implementation, define an instance, initialize,
    and use it. The code is all static to the file that includes it,
    so the unused parts can be optimized to nothing and the used parts
    can be inlined.
*** jack-tcl-wrap - the bits wrapped for use
    This code is my own baroque implementation of software hot glue.
    It wraps sdrkit components into Tcl so they can be loaded and
    executed within a Tcl/Tk application. This covers mostly boring
    stuff like command creation and deletion, options handling,
    subcommand processing, and the gory details of being a Jack
    component.  And it's all done through an evolving framework that
    abstracts out the common code, making it very terse and cryptic.

*** lib/* - tcl code and compiled loadable modules
    The lib directory is structured as a collection of sub-directories
    which could be safely installed into a system lib directory.
*** lib/sdrkit - where sdrkit installs loadable modules
    The lib/sdrkit directory contains, after you make them, a
    collection of shared object files.  The lib/sdrkit/pkgIndex.tcl
    file contains a catalog of the packages.
*** lib/wrap - Tcl code for wrapping up loadable modules
    The commands implemented by sdrkit are barebones computational
    modules.  The code in lib/wrap makes larger functional units.
*** bin/* - tcl scripts implementing full applications.
    These are a mixed bag of Tcl/Tk applications which work pretty
    well in some cases and not at all in others.  The collection will
    evolve, I'll describe the ones I'm happiest with.
** A brief introduction to Tcl
    All of the library Tcl scripts and Tcl application scripts build
    on these basics.

    The end result of jack-tcl-wrap is a collection of Tcl packages,
    which are located in "~/keyer/lib/sdrkit" and indexed in
    "~/keyer/lib/sdrkit/pkgIndex.tcl".  You use them by running Tcl,
    and you run Tcl by executing the Tcl shell command, tclsh:
   #+BEGIN_EXAMPLE
     $ tclsh
     % 
   #+END_EXAMPLE
    You load packages by telling Tcl where to look:
   #+BEGIN_EXAMPLE
     % lappend auto_path ~/keyer/lib
     /usr/share/tcltk/tcl8.5 /usr/lib /usr/local/lib/tcltk /usr/local/share/tcltk /usr/lib/tcltk /usr/share/tcltk ~/keyer/lib
     %
   #+END_EXAMPLE
     and then telling Tcl what you need, say an oscillator:
   #+BEGIN_EXAMPLE
     % package require sdrkit::oscillator
     1.0.0
     %
   #+END_EXAMPLE
     Loading an sdrkit package usually creates a Tcl command factory
     with the same name as the package.  You use the factory command
     to create SDR modules.  So: 
   #+BEGIN_EXAMPLE
    % sdrkit::oscillator lo -freq 10000 -gain 0
    lo
    %
   #+END_EXAMPLE
    creates an oscillator named "lo" which oscillates at 10000 Hertz
    and has 0 decibels gain relative to full scale.  (Well, it ought
    to, but the options at create aren't working this afternoon.)
    "lo" is now a Tcl command which can be run from the Tcl command
    line to query and alter its configuration.  If you say:
   #+BEGIN_EXAMPLE
    % lo help
    unrecognized subcommand "help", should one of configure, cget, or cdoc
    %
   #+END_EXAMPLE
    then you get the list of recognized subcommands as an error.  If you say:
   #+BEGIN_EXAMPLE
    % join [lo configure] \n
    -server server Server default default
    -client client Client {} lo
    -gain gain Gain -30.0 -30.0
    -freq frequency Hertz 700.0 440.0
    %
   #+END_EXAMPLE
    then you get the list of (potentially) configurable options for
    the command.  (Which shows that the -freq and -gain options to the
    command creation weren't effective.)  The -server and -client
    options tell us the Jack server and client name the module
    registered as, so we can use:
   #+BEGIN_EXAMPLE
    % package require sdrkit::jack
    1.0.0
    % sdrkit::jack connect lo:out_i system:playback_1
    %
   #+END_EXAMPLE
    to connect one channel of our complex local oscillator to the
    system audio out. Note that the sdrkit::jack package is an
    exception to the rule given above, it creates a simple command
    rather than a command factory.
** Options
   Most of the lib/sdrkit packages install a command factory which
   allows you to create as many instances of a module as an
   application requires.  Each module usually implements a series of
   sub-commands, including sub-commands for configuring, querying, and
   documenting the options implemented.

   Most of the lib/wrap packages inherit the options of the components
   they wrap, inherit the options of the Tk widgets which they use for
   the wrapping, and implement further options for convenience.

   And the applications in bin/* expose some or all of the options
   that their lib/sdrkit, lib/wrap, or Tk components implement.

*** common options for all apps
**** verbose - generates output to standard error.
     Will slow down the jack process callback if set high enough.
**** server - specifies the jack server name to connect to.
**** client - specifies the jack client name to connect as.
*** common options for MIDI keyer apps
**** chan - specifies which midi channel the communication runs on.
     Note that midi channel 1 is encoded as 0 in midi events.
**** note - specifies which midi note is used for communication. In the
     case of keyer_iambic, "note" specifies the dit and the dah is found
     one higher.  Note that midi note 0 is encoded as 0 in midi events.
*** common options for morse code timing
**** word - specifies the number of dit clocks in a word.
     Use 50 for PARIS and 60 for CODEX.
**** wpm - specifies the words per minute.
     Used with "word" to compute the dit clocks per minute.
**** dah - specifies the number of dit clocks in a dah.
     Default value is 3.0.
**** ies - specifies the number of dit clocks in an inter-element space.
     Defaults value is 1.0.
**** ils - specifies the number of dit clocks in an inter-letter space.
     Defaults value is 3.0.
**** iws - specifies the number of dit clocks in an inter-word space.
     Defaults value is 7.0. You can jack this up get Farnsworth word 
     spacing where strings of letters are sent fast with large gaps
     between the words.
** keyer-control - launch and control ascii and iambic midi keyers
*** --iambic 0 - turns off the iambic keyer controls
*** --ascii 0 - turns off the ascii keyer controls
*** --ascii-* - applies option * to ascii keyer
*** --iambic-* - applies option * to iambic keyer
*** --ascii_tone-* - applies option * to ascii tone generator    
*** --iambic_tone-* - applies option * to iambic tone generator    
** keyer-ascii - ascii to midi morse keyer
   keyer_ascii implements the common options and the common timing
   options.

   You type to the program's standard input to supply the characters
   to be sent.  Anything it knows will be encoded, that which it
   doesn't know gets silently ignored.

   You can send prosigns by using the backslash.  The input sequence
   \sk will send ...-.-, and \\sos will send ...---...

   And you can insert option queries and settings inline with the <>
   syntax, so <wpm?> to query words per minute and <wpm22.5> to set
   "wpm" to 22.5.
** keyer-detime - midi to dit-dah-space decoder
   keyer-detime implements the common options and the timing options.
   It infers the dit clock rate from midi note on and off events and
   writes a stream of decoded '.',  '-', and ' ' to its standard
   output.  
** keyer-iambic - iambic paddle midi to midi morse keyer
   The iambic keyer implements the common options and the common
   timing options.  In addition it implements.

   "swap" reverses the sense of dit and dah.  Normally dit comes in on
   the "chan" channel at "note" and dah one note higher.  Default 0.

   "alsp" specifies if the keyer does automatic letter spacing or
   simply turns off.  Default 0.

   "awsp" specifies if the keyer does automatic word spacing or simply
   turns off.  Default 0.

   "mode" should specify if the keyer implements iambic mode A or mode
   B, but the keyer only does what it does at the moment.
*** Bugs and Issues
   Mode A only, or something like that.

   Stuck keys sometimes, probably MidiKey problem
** keyer-straight - using a straight key
   There isn't any app for this, you wire the MIDI system device
   directly to keyer_tone input, and make sure that your MidiKey
   is sending note 0 for the key, or reconfigure keyer_tone to listen
   to the channel and note your key is sending.
** keyer-tone - midi to i/q tone generator
   It uses a filter based I/Q oscillator which requires a couple of
   multiplies and adds for each step, and the steps are configured to
   be exactly the desired phase difference for each sample.

   It uses the same oscillator to generate a sine ramp for key on and
   key off.  The "rise" and "fall" times can be independently set to the
   desired number of milliseconds.

   The "ramp" option sets "rise" and "fall" to the same number of
   milliseconds.

   The other parameters to keyer_tone are "gain" in decibels and
   "freq" in hertz.
** keyer-scope - watch the keyer mess up
   This is a work in progress designed to debug keyer timing and tone
   generation.  It starts losing sync with the sample source after a
   while but it works, after a fashion.  It connects to the system
   midi capture device to get paddle input events, to the iambic keyer
   output to get the key logic output, and to the iambic keyer tone
   generator to get wave forms.  It expects the keyer-control app to
   be already running.
** MidiKey - Teesyduino application
   There's very little to this, you compile in the Teensyduino
   augmented Arduino environment.

   Be sure to specify your board on the Tools > Board menu, and be
   sure to specify MIDI on the Tools > USB Type menu.
   
   Once you've downloaded the compiled sketch, you should see "ID
   16c0:0485 VOTI" listed by lsusb, "USB-Audio - Teensy MIDI" listed
   in /proc/asound/cards, and the same should show up in Qjackctl on
   the ALSA panel.

   Don't forget to install the /etc/udev/rules.d rules file for the
   Teensy.
* Things to Do
** TODO - keyer_tone.c: protect against 0 rise or fall
** TODO - keyer timing: protect against 0 clocks in all possibilities
** TODO - keyer_ascii.c: to fix the timing glitches visible in scope
** TODO - keyer_iambic.c: to fix the timing glitces visible in scope
** TODO - keyer_iambic.c: mode B
   Should only require a short memory of key states, make the next
   element decision at end of inter-element space based on key state
   at 1.5 dit clocks in the past.
** TODO - MidiKey: to support the AdaFruit atmega32u4breakout.
** TODO - abstract dttsp oscillator and cwtone class in a header.
** TODO - convert all jack SDR modules to take parameters via MIDI sysex
** TODO - build a character trie to decode sysex parameter settings.
** TODO - keyer_ascii.c: to throttle input down to the output rate.
** TODO - keyer_ascii: install more code points
   There's more to Morse code than the basic US Ham usage, but I'm not
   sure how to best internationalize the table.
** TODO - keyer_detone.c: to convert keyed cw into midi note on/off events.
** TODO - keyer-control: build, save, and restore custom configurations.
** TODO - keyer-control: ascii input/output window
** TODO - keyer-control: jack launching panel.
** TODO - keyer-control: jack connection panel.
** TODO - keyer-control: offer to launch mouse-key
** TODO - sdrkit_jack.c: provide missing jack status information.
** TODO - bin/invaders: callsign-invaders ear/key training game.
** TODO - bin/pileup: echo back callsigns in a pileup situation
** TODO - keyer_binaural.c: to spread a monoaural audio spectrum out spatially
   using DJ5IL's CodePhaser circuit.
** TODO - sdrkit_binaural.c: to spread i/q binaurally according to dttsp
   The binaural option in dttsp simply leaves the I/Q as it is, the
   monoaural option discards the Q and pans the result to a specified
   azimuth.
** TODO - keyer_skimmer.c: to identify active frequencies in passband and start keyer_detone -> keyer_decode -> ascii.
** DONE - general abstraction - sdrkit: c and c++ modules in headers for pure computation.
   oscillators, mixers, filters, modulators, demodulators.
** TODO - general abstraction - jack-tcl-wrap: sdrkit wrapped as Tcl extensions with consistent options handling
   the command framework lives here
** TODO - general abstraction - jackit: sdrkit variation wrapped to jack process loop    
** TODO - sdrkit/framework.h - readonly options
** TODO - sdrkit/framework.h - command documentation strings
** TODO - sdrkit/framework.h - subcommand documentation strings
* Things already done
** DONE - MidiKey: to debounce with a period in microseconds.
   Mangled the existing Bounce class, still not quite right.
** DONE - MidiKey: to use a less ad hoc debouncer.
   Gave up on debouncing altogether, works fine with my key.
** DONE - MidiKey: to use the LUFA library for USB.
   Glen Overby's sources use LUFA, the LufaMidiKey here needs revision.
** DONE - keyer_midi.c:  to use a queuing api that looks like jack's event_in queuing. 
   Won't fit in an Altoids Smalls box.
   and doesn't scare me as bad as the current interface.
** DONE - abstract Oscillator class in a header.
** DONE - users of keyer_midi.c: to use the new queuing api.
** DONE - keyer-control: to use a dedicated keyer_tone for each keyer.
** DONE - keyer-control: to use expect to manage plugins.
   Didn't work out as I hoped.
** DONE - keyer_iambic - Rewrite the process loop -> iambic_transition
    Make it call iambic_transition at a specified granularity
    irrespective of the jack buffer size, like twice per dit clock.
** DONE - keyer-control: don't die when midi_capture device is missing
** DONE - insert license information.
** DONE - keyer_*.c: distinguish stdout and stderr better.
** DONE - keyer_framework.c: implement a tcl command framework.
** DONE - sdrkit_mtap.c: Should add MIDI input to receive the iambic shaped keying.
   That could be used to key a transmitter, play a sidetone, wiggle a
   PTT line, or flash some LED's. 
** DONE - bin/*: follow symlinked scripts back to the source directory
** DONE - bin/midiscope: display logic transitions of midi events.
** DONE - bin/scope: display audio baseband waveforms
** DONE - bin/spectrum: spectrogram display
** DONE - keyer_decode.c: rename to keyer_detime.c
** DONE - keyer-control: examine output of lsp to determine connection possibilities.
** DONE - keyer_framework.c: allow jack thread to buffer output to memory for the main thread to print. Hence input cannot block.
** DONE - bin/waterfall: persistent spectrogram display
** DONE - keyer_mix.c: to mix multiple keyer_tone channels down to a single channel.
   Does a gain block do that all by itself when jack routes multiple
   inputs?  Yes.  The problem would be in mixing multiple I/Q channels
   together. 
** DONE - sdrkit_mono_to_iq.c: convert an monoaural signal to i/q by up-sampling and shifting.
   I've thought this out.  It appears that simply taking the mono
   channel as I and the mono channel delayed by one sample as Q is
   equivalent to doing quadrature detection at samplerate/4.
** DONE - keyer_tone.c: to fix the ramping glitches visible in scope
** DONE - midiscope: reorganize into three digital panes and an audio
   pane so all aspects of keying can be compared.
** DONE - major renaming 
   Rename 'sdrkit' to 'tjwrap' because it's a Tcl/Jack wrapper around the around the real 'sdrkit'.
   Rename 'dspkit' to 'sdrkit' because it's the real kit for SDR.
   Retain the 'sdrkit::foo' name space because they're wrapped sdrkit modules.
   Opens the possibility of wrappers using alternate script and audio glue.
* Credits
  This code is derived from many sources.

  The largest debt is to the dttsp sources, Copyright (C) 2004, 2005,
  2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY.
  Many of the modules here are directly or indirectly derived from
  their code.

  I've learned a lot from reading documentation, example applications,
  header files, and library code for [[http://www.alsa-project.org/][ALSA]] and [[http://jackaudio.org/][Jack]].

  Perry Cook's [[https://ccrma.stanford.edu/software/stk/][Synthesis Toolkit]] provided one worked example of how to
  make adjustments to DSP components on the fly.

  Faust, http://faust.grame.fr/, is a really neat idea, dsp computations
  described as an algebra on infinite streams of samples.  It also
  provided an example of how not to make adjustments to DSP components
  on the fly.
* Licensing
  Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
   
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
