* Ascii/Iambic morse keyer (and more) using Jack audio connection kit.
  This is a morse code keyer consisting of Jack Audio Connection Kit
  plugins, a hardware interface, and a variety of additional Tcl
  hosted SDR tools for testing and playing with them.
* Prerequisites
  I've written these instructions as I use them on a laptop running
  Ubuntu 11.10, the Oneiric Ocelot release.  Most of it is generic
  enough to work on other current Linux systems with minor
  translations of package management tools and package names. It's
  also generic enough to port to MacOS or Windows.  But I don't run
  other Linux systems, MacOS, or Windows so asking me to help you make
  it work is a lost cause, unless you want moral support.

  I will be assuming that you have installed the keyer sources in your
  home directory, which I abbreviate as "~".  So I will refer to the
  keyer source directory as "~/keyer" in all that follows.   It
  doesn't depend on being there.  You can install it anywhere, and that
  isn't where I install it.  But these instructions will depend on you
  making the necessary translation if you install the sources
  someplace else.
** Required packages
   Using your preferred Ubuntu package manager, you want to install
   the following packages:
   | build-essentials   |
   | git-core           |
   | jackd2             |
   | libfftw3-dev       |
   | libjack-jackd2-dev |
   | qjackctl           |
   | tk-dev             |
   These are not all the required packages.  Several other packages
   will be dragged in because they're required by the packages
   listed.

   The "apt-get" command to install these packages is
   #+BEGIN_EXAMPLE
   sudo apt-get install build-essentials git-core jackd2 libfftw3-dev libjack-jackd2-dev qjackctl tk-dev
   #+END_EXAMPLE

   Note that Ubuntu 11.10 has some confusion in the packaging of jackd.
   Some audio packages were built against jackd1 and some against the
   jackd agnostic package, so some audio libraries will force
   installation  of the old jackd version 1 package.  I force jackd2
   because it's what I use.  I don't know if jackd1 will work.

   Also, there is a bug in qjackctl that unnecessarily disables PulseAudio.
   Edit /usr/bin/qjackctl and make the non-comment part look like this:
   #+BEGIN_EXAMPLE
#!/bin/sh
PROGRAM="/usr/lib/qjackctl/qjackctl.real"
#PASUSPENDER="`whereis -b pasuspender | cut -d ':' -f 2 | tr -d ' '`"
#( [ -x "${PASUSPENDER}" ] && ${PASUSPENDER} -- ${PROGRAM} ${@} ) || ${PROGRAM} ${@}
${PROGRAM} ${@}
exit 0
   #+END_EXAMPLE
   to avoid the problem.
** Getting the source
   The sources are archived at https://github.com/recri/keyer.
   Assuming that you installed the git packages and want the
   sources to be in ~/keyer,
   #+BEGIN_EXAMPLE
   cd ~ && git clone https://github.com/recri/keyer
   #+END_EXAMPLE
   will create a new directory named "keyer" in your home directory.
   The sources will be up to date as of the time that you clone the 
   repository.

   Running:
   #+BEGIN_EXAMPLE
   cd ~/keyer && git pull origin master
   #+END_EXAMPLE
   will refresh your sources to the most recent at any time.  It's
   prudent to run: 
   #+BEGIN_EXAMPLE
   cd ~/keyer && make all-clean
   #+END_EXAMPLE
   before refreshing the sources because the list of things to be built
   and cleaned up is changing all the time.

   If things get messed up (and you have no local changes to preserve)
   you can always:
   #+BEGIN_EXAMPLE
   cd ~ && rm -fr keyer && git clone https://github.com/recri/keyer
   #+END_EXAMPLE
   to start over again from a clean copy.
** Building
   #+BEGIN_EXAMPLE
   cd ~/keyer && make
   #+END_EXAMPLE
   will compile everything needed to run.  If you have problems,
   please go back to the list of required packages and make sure you
   didn't miss one.
   #+BEGIN_EXAMPLE
   cd ~/keyer && make clean
   #+END_EXAMPLE
   will remove intermediate files not required to run.
   #+BEGIN_EXAMPLE
   cd ~/keyer && make all-clean
   #+END_EXAMPLE
   should remove all built files.
** Installing
   I don't do any install. I usually run the scripts from ~/keyer
   manually prefixing bin/ to get the commands I want to run.
** MidiKey
  The whole point is to get CW keying information into the computer
  with the lowest latency possible.  To do that you'll need a
  MIDI-USB-Keyer dongle to hookup your straight key or paddle.

  I started with a paddle interface built on a breadboard from a
  Teensy 2.0 (from http://www.pjrc.com/teensy/), a stereo audio jack,
  and three jumper wires.
| Teensy B0     | -> | stereo jack dit    |
| Teensy B1     | -> | stereo jack dah    |
| Teensy GND    | -> | stereo jack common |
| Iambic paddle | -> | stereo jack        |
| Teensy USB    | -> | computer           |

  [[https://github.com/recri/keyer/blob/master/images/keyer-1.jpg][Blurry image1]], [[https://github.com/recri/keyer/blob/master/images/keyer-2.jpg][Blurry image2]], [[https://github.com/recri/keyer/blob/master/images/keyer-3.jpg][Blurry image3]].

  The Teensyduino application to translate paddle transitions into
  MIDI events is in MidiKey/MidiKey.ino.  The instructions for building
  it are in the source code.

  I've packaged the keyer dongle into an Altoids Smalls tin, shown
  [[https://github.com/recri/keyer/blob/master/images/keyer-8.jpg][in the tin]], and [[https://github.com/recri/keyer/blob/master/images/keyer-7.jpg][exposed]]. The perf board is supported on 5/8"
  standoffs   of the bottom of the tin.  The Teensy is mounted on
  upside down header pins, short end through the perf board long end
  through the Teensy mounting holes. The Teensy and stereo jack are
  super glued onto the perf board.  The stereo jack lugs are soldered
  to a set of five header pins.  The rest of the connections are
  wire-wrapped between long legs of header pins.

  The set of 11 pins at the left edge of the [[https://github.com/recri/keyer/blob/master/images/keyer-7.jpg][exposed]] image is a
  Sparkfun Blackberry trackball breakout which is unsupported in the
  software at the moment.  You can see the trackball erupting through
  [[https://github.com/recri/keyer/blob/master/images/keyer-8.jpg][the tin]].
  
  In retrospect, I'd switch to using input pins closer to the stereo
  jack end of the Teensy.

  Glen Overby provoked this project on the dttsp list at yahoo back in
  November 2011.  He has built another MIDI key interface which is
  described [[http://reality.sgiweb.org/overby/ham/Equipment/Key-Adapter/index.html][here]]. It should work with this software if the MIDI note
  is set properly.
* Usage
  My basic usage pattern is to use qjackctl to configure my jack
  server, start the server, control the server, and manually make
  connections between modules.

  Some of the commands will automatically make connections to a
  default set of ports, if the port names match with their
  expectations.  You can view what happens and what fails to happen
  with qjackctl.  The most usual problem is that the MidiKey hiccupped
  and moved from system:capture_1 to system:capture_2.
  
  bin/keyer-control, bin/keyer-scope, and bin/pileup are written to
  automatically hook themselves up in a useful way, and they are
  the applications which I try to test to make sure they work before
  each push back to github.

  You can configure your jack server to "autolaunch" whenever an
  application tries to open it, but the result will be that you get a 
  bunch of messages from jackd which appear to come from your
  application, the messages look pretty much the same whether jackd
  succeeds or fails to start, and the autolaunched jackd may or may
  not be visible and controllable from qjackctl.  So turn off the
  autolaunch feature and use qjackctl so you can see what's
  happening.

  All of the commands in ~/keyer/bin are Tcl/Tk scripts. I'm only
  going to talk about the ones that make the keyer work.  The rest
  of it is other parts of a software defined radio software kit that
  gets soldered together with Jack and Tcl. Some of it may work, some
  of it used to work, some of it never worked, some of it has been
  abandoned, some of it is experimental code that may yet be abandoned
  or changed beyond recognition.  So, if you're curious, try it.  If
  you're still curious, open it in a text editor.  All the code is
  either in the script file, or part of standard Tcl/Tk, or it's in
  ~/keyer/lib.
** keyer-control - launch and control ascii and iambic midi keyers
*** --ascii 0 - turns off the ascii keyer and controls
    which default on.
*** --debounce 0 - turns off the switch debouncing    
*** --dttsp_iambic 1 - turns on the dttsp derived iambic keyer
    and controls, which default off.
*** --iambic 0 - turns off the iambic keyer and controls
    which default on.
*** --ptt 0 - turns off the ptt switch and controls
*** --ascii-* - applies option * to ascii keyer
*** --ascii_tone-* - applies option * to ascii tone generator    
*** --dttsp_iambic-* - applies option * to dttsp iambic keyer
*** --iambic-* - applies option * to iambic keyer
*** --iambic_tone-* - applies option * to iambic tone generator    
** keyer-scope - watch the keyer mess up
   This is a work in progress designed to debug keyer timing and tone
   generation. It connects to the system midi capture device to get
   paddle input events, to the debouncer to get deglitched input
   events, to the iambic keyer output to get the key logic output,
   to the PTT outputs to get the final ptt and key outputs, and to the
   iambic keyer tone generator to get wave forms.  The vertical scale
   control for the wave form display is the output gain on iambic tone
   control.  It's rough.
** pileup - morse code training
   Pileup sends morse code for you to echo back with your keyer.

   The words sent are either chosen from a set of callsigns from the
   original pileup program or they are random words with up to N dit
   clocks from the start of the first element to the end of the last
   element.

   There is a limit on how many simultaneous voices can run, but I'm
   not sure what it is.

   There is a simulated sideways waterfall display, but you shouldn't
   look at it, you should work to hear the code and echo it back.
** MidiKey - Teesyduino application
   There's very little to this, the steps should be listed in the
   comment at the head of MidiKey/MidiKey.ino.

   Don't forget to install the /etc/udev/rules.d rules file for the
   Teensy.
* Credits
  This code is derived from many sources.

  The largest debt is to the dttsp sources, Copyright (C) 2004, 2005,
  2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY.
  Many of the modules here are directly or indirectly derived from
  their code.

  I've learned a lot from reading documentation, example applications,
  header files, and library code for [[http://www.alsa-project.org/][ALSA]] and [[http://jackaudio.org/][Jack]].

  Perry Cook's [[https://ccrma.stanford.edu/software/stk/][Synthesis Toolkit]] provided one worked example of how to
  make adjustments to DSP components on the fly.

  Faust, http://faust.grame.fr/, is a really neat idea, dsp computations
  described as an algebra on infinite streams of samples.  It also
  provided an example of how not to make adjustments to DSP components
  on the fly.
* Licensing
  Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
   
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
