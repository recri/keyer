* Ascii/Iambic morse keyer (and more) using Jack audio connection kit.
  This is a morse code keyer consisting of jack audio connection kit
  plugins, a hardware interface, and a variety of additional Tcl
  hosted SDR tools for testing and playing with them.

  The keyer-control application launches iambic and ascii keyers with
  independent tone generators, wires them up, and allows their
  parameters to be fiddled with.

  The essential prerequisites for using this are a computer running
  Linux build and host the applications. With that you can run the
  ascii keyer, listen to the output, examine the waveforms, and see
  how the system works.

  Adding a MidiKeyer USB dongle will allow you to translate your
  paddle or straight key switch closures into MIDI events and transmit
  them to the computer over USB.  With that you can fully exercise the
  iambic keyer and play with some of the games which require you to
  key in the answers.
* Prerequisites
  I've written these instructions as I use them on a laptop running
  Ubuntu 11.10, the Oneiric Ocelot release.  Most of it is generic
  enough to work on other current Linux systems with minor
  translations of package management tools and package names. It's
  also generic enough to port to MacOS or Windows.  But I don't run
  other Linux systems, MacOS, or Windows so asking me to help you make
  it work is a lost cause.

  I will be assuming that you have installed the keyer sources in your
  home directory, which I abbreviate as "~".  So I will refer to the
  keyer source directory as "~/keyer" in all that follows.   It
  doesn't depend on being there, you can install it anywhere, but
  these instructions will depend on you making the necessary
  translation if you install the sources someplace else.
** Required packages
   Using your preferred Ubuntu package manager, you want to install:
   | build-essentials   |
   | git-core           |
   | jackd2             |
   | libfftw3-dev       |
   | libjack-jackd2-dev |
   | qjackctl           |
   | tk-dev             |
   These are not all the required packages.  Several other packages
   will be dragged in because they're required by the packages
   listed. 

   Note that Ubuntu 11.10 has some confusion in the jackd packaging.
   Some audio packages were built against jackd1 and some against the
   jackd agnostic package, so some audio libraries will force
   installation  of the old jackd version 1 package.  I force jackd2
   because it's better.  I don't know if jackd1 will work.
** Getting the source
   The sources are archived at https://github.com/recri/keyer.
   Assuming that you want the sources to be in ~/keyer,
   #+BEGIN_EXAMPLE
   cd ~ && git clone https://github.com/recri/keyer
   #+END_EXAMPLE
   will create a new directory named "keyer" in your home directory.
   The sources will be up to date as of the time that you clone the 
   repository.

   Running:
   #+BEGIN_EXAMPLE
   cd ~/keyer && git pull origin master
   #+END_EXAMPLE
   will refresh your sources to the most recent at any time.  It's
   prudent to run: 
   #+BEGIN_EXAMPLE
   cd ~/keyer && make all-clean
   #+END_EXAMPLE
   before refreshing the sources because the list of things to be built
   and cleaned up is changing all the time.

   If things get messed up (and you have no local changes to preserve)
   you can always:
   #+BEGIN_EXAMPLE
   cd ~ && rm -fr keyer && git clone https://github.com/recri/keyer
   #+END_EXAMPLE
   to start over again.
** Building
   #+BEGIN_EXAMPLE
   cd ~/keyer && make
   #+END_EXAMPLE
   will compile everything needed to run.

   #+BEGIN_EXAMPLE
   cd ~/keyer && make clean
   #+END_EXAMPLE
   will remove intermediate files not required to run.

   #+BEGIN_EXAMPLE
   cd ~/keyer && make all-clean
   #+END_EXAMPLE
   should remove all built files.
** Installing
   I don't do any install. I usually run the scripts from ~/keyer
   manually prefixing bin/ to get the commands I want to run.
** MidiKey
  Originally, the whole point is to get CW keying information into the
  computer with the lowest latency possible.  To do that you'll need a
  MIDI-USB-Keyer dongle to hookup your keys.

  I started with a paddle interface built on a breadboard from a
  Teensy 2.0 (from http://www.pjrc.com/teensy/), a stereo audio jack,
  and three jumper wires.
| Teensy B0     | -> | stereo jack dit    |
| Teensy B1     | -> | stereo jack dah    |
| Teensy GND    | -> | stereo jack common |
| Iambic paddle | -> | stereo jack        |
| Teensy USB    | -> | computer           |

  [[https://github.com/recri/keyer/blob/master/images/keyer-1.jpg][Blurry image1]], [[https://github.com/recri/keyer/blob/master/images/keyer-2.jpg][Blurry image2]], [[https://github.com/recri/keyer/blob/master/images/keyer-3.jpg][Blurry image3]].

  The Teensyduino application to translate paddle transitions into
  MIDI events is in MidiKey/MidiKey.ino.  The instructions for building
  it are in the source code.

  I've packaged the keyer dongle into an Altoids Smalls tin, shown
  [[https://github.com/recri/keyer/blob/master/images/keyer-8.jpg][in the tin]], and [[https://github.com/recri/keyer/blob/master/images/keyer-7.jpg][exposed]]. The perf board is supported on 5/8"
  standoffs   of the bottom of the tin.  The Teensy is mounted on
  upside down header pins, short end through the perf board long end
  through the Teensy mounting holes. The Teensy and stereo jack are
  super glued onto the perf board.  The stereo jack lugs are soldered
  to a set of five header pins.  The rest of the connections are
  wire-wrapped between long legs of header pins.

  The set of 11 pins at the left edge of the [[https://github.com/recri/keyer/blob/master/images/keyer-7.jpg][exposed]] image is a
  Sparkfun Blackberry trackball breakout which is unsupported in the
  software at the moment.  You can see the trackball erupting through
  [[https://github.com/recri/keyer/blob/master/images/keyer-8.jpg][the tin]].
  
  In retrospect, I'd switch to using input pins closer to the stereo
  jack end of the Teensy.

  Glen Overby built another MIDI key interface which is described here
  http://reality.sgiweb.org/overby/ham/Equipment/Key-Adapter/index.html. 
  It should work with this software if the MIDI note is set properly.
  It was Glen's work which got me restarted on this project.
* Usage
  My basic usage pattern is to use qjackctl to configure my jack
  server, start the server, control the server, and manually make
  connections between modules.
  
  You can configure your jack server to "autolaunch" whenever an
  application tries to open it, but the result will be that you get a 
  bunch of messages from jackd which appear to come from your
  application, the messages look the same whether jackd succeeds or
  fails to start, and the autolaunched jackd may or may not be visible 
  and controllable from qjackctl.  So turn off the autolaunch feature
  and use qjackctl so you can see what's happening.

  All of the scripts in ~/keyer/bin are now Tcl/Tk scripts. I'm going
  to describe what they do, but for the fullest documentation of the
  options each script implements, you should open the script file in a
  text editor and scroll to the end of the file.  Each application
  should define a "main" procedure which parses command line options,
  and you should be able to figure out what the options do.

  The problem is that I change things that I don't like, so a
  canonical description of how things work is hard to pin down.
** Abstraction
   The code is evolving toward a really nice set of abstractions, but
   it's a bit of a mess at the moment.
*** dspkit - digital signal processing
    This contains plain dsp implementations in c and c++ without
    any distracting details.  Oscillators, filters, mixers,
    demodulation, modulation, keyers, debouncers, and so on.  Best of
    breed and less optimal implementations for comparison.  This is
    where you go to figure out how a particular computation is
    performed or to steal code for your own use.

    Note that dspkit is entirely header files.
*** sdrkit - software defined radio
    This will define the framework for wrapping dspkit as Tcl commands
    so they can be loaded and executed within a Tcl/Tk application.
    This covers command creation and deletion, options handling, and
    subcommand processing.

    This is also where the plain Tcl commands get defined.
*** jackit - Jack enabled modules
    Jack modules are Tcl commands that link themselves into the Jack
    computation graph.  This involves defining a Jack process
    callback, opening Jack ports, and subsequent clean up.

    This is also where the Jack enabled modules get defined.
*** vizkit - visualization modules
    Software defined radio requires fast display for meters, scopes,
    spectrum, and waterfall displays.
*** lib/* - tcl code and compiled loadable modules
    The lib directory is structured as a collection of sub-directories
    which could be safely installed into a system lib directory.
*** lib/sdrkit - where sdrkit installs loadable modules
*** lib/jackit - where jackit installs loadable modules
*** lib/vizkit - where vizkit installs loadable modules
*** lib/wrapit - Tcl code for wrapping up loadable modules
    The commands implemented by sdrkit, jackit, and vizkit are
    barebones computational modules.  The code in wrapit wraps the
    barebones computations into a ui widget with controls for managing
    the wrapped computation or display.
    
    So a wrapped vizkit::scope will provide scrollbars for shifting
    the display, buttons for adjusting the horizontal and vertical
    scales, and dropdowns for selecting the input channels.
*** bin/* - tcl scripts implementing full applications.    
** Options
   Almost all commands will accept some set of options that allow you
   to alter the default behavior of the command, but almost all
   commands have a user interface, too.

   Generally options are implemented as command line options using a
   "--name value" syntax, that's two minus signs in front of the
   option name as one argument followed by the value as a second
   argument.
   
   The command line option parsers are getting more forgiving, some of
   them will accept a single minus sign or even a one character
   abbreviations.

   Tcl configuration options use a "-name value" syntax, that's one
   minus sign in front of the option name as one argument followed by
   the value as a second argument.  Generally, the command that
   creates a Tcl command will accept a certain set of configuration
   options, and the command's "config" and "cget" subcommands will
   allow the same options to be queried or modified after creation.

   Most options can be changed after a command is started. The notable
   exceptions are the jack "server" and jack "client" names.  These
   cannot be changed once the plugin starts. They determine which
   server the plugin connects to and what name it uses in the
   connection.  Changing the MIDI "chan" and "note" on the fly is
   tricky because the change won't work until both ends of the
   connection are using the same 

   All of the options which are numbers, eg "wpm", "dah", "freq", and
   "gain", are floating point values.
*** common options for all apps
**** verbose - generates output to standard error.
     Will slow down the jack process callback if set high enough.
**** server - specifies the jack server name to connect to.
**** client - specifies the jack client name to connect as.
*** common options for MIDI keyer apps
**** chan - specifies which midi channel the communication runs on.
     Note that midi channel 1 is encoded as 0 in midi events.
**** note - specifies which midi note is used for communication. In the
     case of keyer_iambic, "note" specifies the dit and the dah is found
     one higher.  Note that midi note 0 is encoded as 0 in midi events.
*** common options for morse code timing
**** word - specifies the number of dit clocks in a word.
     Use 50 for PARIS and 60 for CODEX.
**** wpm - specifies the words per minute.
     Used with "word" to compute the dit clocks per minute.
**** dah - specifies the number of dit clocks in a dah.
     Default value is 3.0.
**** ies - specifies the number of dit clocks in an inter-element space.
     Defaults value is 1.0.
**** ils - specifies the number of dit clocks in an inter-letter space.
     Defaults value is 3.0.
**** iws - specifies the number of dit clocks in an inter-word space.
     Defaults value is 7.0. You can jack this up get Farnsworth word 
     spacing where strings of letters are sent fast with large gaps
     between the words.
** keyer-control - launch and control ascii and iambic midi keyers
*** --iambic 0 - turns off the iambic keyer controls
*** --ascii 0 - turns off the ascii keyer controls
*** --ascii-* - applies option * to ascii keyer
*** --iambic-* - applies option * to iambic keyer
*** --ascii_tone-* - applies option * to ascii tone generator    
*** --iambic_tone-* - applies option * to iambic tone generator    
** keyer-ascii - ascii to midi morse keyer
   keyer_ascii implements the common options and the common timing
   options.

   You type to the program's standard input to supply the characters
   to be sent.  Anything it knows will be encoded, that which it
   doesn't know gets silently ignored.

   You can send prosigns by using the backslash.  The input sequence
   \sk will send ...-.-, and \\sos will send ...---...

   And you can insert option queries and settings inline with the <>
   syntax, so <wpm?> to query words per minute and <wpm22.5> to set
   "wpm" to 22.5.
** keyer-detime - midi to dit-dah-space decoder
   keyer-detime implements the common options and the timing options.
   It infers the dit clock rate from midi note on and off events and
   writes a stream of decoded '.',  '-', and ' ' to its standard
   output.  
** keyer-iambic - iambic paddle midi to midi morse keyer
   The iambic keyer implements the common options and the common
   timing options.  In addition it implements.

   "swap" reverses the sense of dit and dah.  Normally dit comes in on
  the "chan" channel at "note" and dah one note higher.  Default 0.

  "alsp" specifies if the keyer does automatic letter spacing or
  simply turns off.  Default 0.

  "awsp" specifies if the keyer does automatic word spacing or simply
  turns off.  Default 0.

  "mode" should specify if the keyer implements iambic mode A or mode
  B, but the keyer only does what it does at the moment.
*** Bugs and Issues
   Mode A only, or something like that.

   Stuck keys sometimes, probably MidiKey problem
** keyer-straight - using a straight key
   There isn't any app for this, you wire the MIDI system device
   directly to keyer_tone input, and make sure that your MidiKey
   is sending note 0 for the key, or reconfigure keyer_tone to listen
   to the channel and note your key is sending.
** keyer-tone - midi to i/q tone generator
   It uses a filter based I/Q oscillator which requires a couple of
   multiplies and adds for each step, and the steps are configured to
   be exactly the desired phase difference for each sample.

   It uses the same oscillator to generate a sine ramp for key on and
   key off.  The "rise" and "fall" times can be independently set to the
   desired number of milliseconds.

   The "ramp" option sets "rise" and "fall" to the same number of
   milliseconds.

   The other parameters to keyer_tone are "gain" in decibels and
   "freq" in hertz.
** MidiKey - Teesyduino application
   There's very little to this, you compile in the Teensyduino
   augmented Arduino environment.

   Be sure to specify your board on the Tools > Board menu, and be
   sure to specify MIDI on the Tools > USB Type menu.
   
   Once you've downloaded the compiled sketch, you should see "ID
   16c0:0485 VOTI" listed by lsusb, "USB-Audio - Teensy MIDI" listed
   in /proc/asound/cards, and the same should show up in Qjackctl on
   the ALSA panel.

   Don't forget to install the /etc/udev/rules.d rules file for the
   Teensy.
*** Bugs and Issues
    I think the key debouncing is just slowing things down and missing
    some of the key transitions as a consequence.  Iambic paddles are
    not consumer grade push buttons.  No, it was my bug in the
    jack_process callback that was causing the dropped event problems.
** gain - gain module
** midiscope - midi event capture and display
** oscillator - oscillator module
** pileup - cw pileup simulator
** scope - audio signal capture and display
** spectrum - audio spectrogram capture and display
** waterfall - audio waterfall capture and display
** panorama - combined spectrogram and waterfall display
* Things to Do
** TODO - MidiKey: to support the AdaFruit atmega32u4breakout.
** TODO - keyer_ascii.c: to fix the timing glitches visible in scope
** TODO - keyer_iambic.c: to fix the timing glitces visible in scope
** TODO - keyer_tone.c: to fix the ramping glitches visible in scope
** TODO - abstract DttspOscillator class in a header.
** TODO - keyer_ascii.c: to throttle input down to the output rate.
** TODO - keyer_ascii: install more code points
   There's more to Morse code than the basic US Ham usage, but I'm not
   sure how to best internationalize the table.
** TODO - keyer_iambic.c: mode B
    Should only require a short memory of key states, make the next
    element decision at end of inter-element space based on key state
    at 1.5 dit clocks in the past.
** TODO - keyer_detone.c: to convert keyed tones into midi.
** TODO - keyer-control: build, save, and restore custom configurations.
** TODO - keyer-control: ascii input/output window
** TODO - keyer-control: jack launching panel.
** TODO - keyer-control: jack connection panel.
** TODO - sdrkit_jack.c: provide missing jack status information.
** TODO - keyer_tone.c: protect against 0 rise or fall
** TODO - keyer timing: protect against 0 clocks in all possibilities
** TODO - bin/invaders: callsign-invaders ear/key training game.
** TODO - bin/pileup: echo back callsigns in a pileup situation
** TODO - keyer_binaural.c: to spread a monoaural audio spectrum out spatially
   using DJ5IL's CodePhaser circuit.
** TODO - sdrkit_binaural.c: to spread i/q binaurally according to dttsp
   The binaural option in dttsp simply leaves the I/Q as it is, the
   monoaural option discards the Q and pans the result to a specified
   azimuth.
** TODO - sdrkit_monoiq.c: convert an monoaural signal to i/q by up-sampling and shifting.
   I've thought this out.  It appears that simply taking the mono
   channel as I and the mono channel delayed by one sample as Q is
   equivalent to doing quadrature detection at samplerate/4.
** TODO - keyer_skimmer.c: to identify active frequencies in passband and start keyer_detone -> keyer_decode -> ascii.
** TODO - general abstraction - dspkit: c and c++ modules in headers for pure computation.
   oscillators, mixers, filters, modulators, demodulators.
** TODO - general abstraction - sdrkit: dspkit wrapped as Tcl extensions with consistent options handling
   the command framework lives here
** TODO - general abstraction - jackit: sdrkit variation wrapped to jack process loop    
** TODO - sdrkit/framework.h - readonly options
** TODO - sdrkit/framework.h - command documentation strings
** TODO - sdrkit/framework.h - subcommand documentation strings
* Things already done
** DONE - MidiKey: to debounce with a period in microseconds.
   Mangled the existing Bounce class, still not quite right.
** DONE - MidiKey: to use a less ad hoc debouncer.
   Gave up on debouncing altogether, works fine with my key.
** DONE - MidiKey: to use the LUFA library for USB.
   Glen Overby's sources use LUFA, the LufaMidiKey here needs revision.
** DONE - keyer_midi.c:  to use a queuing api that looks like jack's event_in queuing. 
   Won't fit in an Altoids Smalls box.
   and doesn't scare me as bad as the current interface.
** DONE - abstract Oscillator class in a header.
** DONE - users of keyer_midi.c: to use the new queuing api.
** DONE - keyer-control: to use a dedicated keyer_tone for each keyer.
** DONE - keyer-control: to use expect to manage plugins.
   Didn't work out as I hoped.
** DONE - keyer_iambic - Rewrite the process loop -> iambic_transition
    Make it call iambic_transition at a specified granularity
    irrespective of the jack buffer size, like twice per dit clock.
** DONE - keyer-control: don't die when midi_capture device is missing
** DONE - insert license information.
** DONE - keyer_*.c: distinguish stdout and stderr better.
** DONE - keyer_framework.c: implement a tcl command framework.
** DONE - sdrkit_mtap.c: Should add MIDI input to receive the iambic shaped keying.
   That could be used to key a transmitter, play a sidetone, wiggle a
   PTT line, or flash some LED's. 

** DONE - bin/*: follow symlinked scripts back to the source directory
** DONE - bin/midiscope: display logic transitions of midi events.
** DONE - bin/scope: display audio baseband waveforms
** DONE - bin/spectrum: spectrogram display
** DONE - keyer_decode.c: rename to keyer_detime.c
** DONE - keyer-control: examine output of lsp to determine connection possibilities.
** DONE - keyer_framework.c: allow jack thread to buffer output to memory for the main thread to print. Hence input cannot block.
** DONE - bin/waterfall: persistent spectrogram display
** DONE - keyer_mix.c: to mix multiple keyer_tone channels down to a single channel.
   Does a gain block do that all by itself when jack routes multiple
   inputs?  Yes.  The problem would be in mixing multiple I/Q channels
   together. 
* Credits
  This code is derived from many sources.

  The largest debt is to the dttsp sources, Copyright (C) 2004, 2005,
  2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY.
  Many of the modules here are directly or indirectly derived from
  their code.

  A lot of other code comes from linux audio applications.

  Faust http://faust.grame.fr/
* Licensing
  Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
   
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
