#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

# package provide scope 1.0.0

package require Tk
package require sdrkit::audio-tap
package require sdrkit::jack

namespace eval ::scope {
    array set default_data {
	taps 1
	name scope
	x-zoom 0
	y-zoom 0
	x-scale 1.0
	y-scale 1.0
	label-x-scale 1.0
	label-y-scale 1.0
	connect {}
    }
}

proc scope::start-taps {w} {
    upvar #0 ::scope::$w data
    set data(tap) $data(name)_tap
    if {$data(taps) == 1} {
	::sdrkit::audio-tap $data(tap) -complex 1
	if {$data(connect) ne {}} {
	    ::sdrkit::jack connect $data(connect):out_i $data(tap):in_i
	    ::sdrkit::jack connect $data(connect):out_q $data(tap):in_q
	}
    } else {
	for {set i 1} {$i <= $data(taps)} {incr i} {

	}
    }
}

proc scope::stop-taps {w} {
    set data(tap) $data(name)_tap
    if {$data(taps) == 1} {
	catch {rename $data(tap) {}}
    } else {
	for {set i 1} {$i <= $data(taps)} {incr i} {
	    catch {rename $data(tap)$i {}}
	}
    }
}

proc scope::start {w} {
    upvar #0 ::scope::$w data
    set data(sample-rate) [sdrkit::jack sample-rate]
    set data(buffer-size) [sdrkit::jack buffer-size]
    # whatever rate I capture at, I should capture
    # a little sooner and expect to get overlaps
    for {set n 1} {1} {set n [expr {$n+$n}]} {
	set ns [expr {$n*$data(buffer-size)}]
	set nms [expr {1000*$ns/$data(sample-rate)}]
	if {$nms > 100} break
	set data(capture-samples) $ns
	set data(capture-millis) $nms
    }
    set data(capture-i) {}
    set data(capture-q) {}
    $w.m.start configure -state disabled
    $w.m.stop configure -state normal
    scope::collect $w
}

proc scope::stop {w} {
    upvar #0 ::scope::$w data
    $w.m.start configure -state normal
    $w.m.stop configure -state disabled
    $w.m.clear configure -state normal
    catch {after cancel $data(token)}
}

proc scope::clear {w} {
    upvar #0 ::scope::$w data
    $w.m.clear configure -state disabled
    foreach name {capture-i capture-q} {
	if {[info exists data($name-xy)]} {
	    $w.c coords $name-xy {0 0 0 0}
	    set data($name--xy) {}
	}
    }
}

proc scope::collect {w} {
    upvar #0 ::scope::$w data
    foreach {f b} [$data(tap) get $data(capture-samples)] break
    binary scan $b f* samples
    if { ! [info exists data(capture-start-frame)]} {
	set data(capture-start-frame) $f
	set data(capture-current-frame) $f
    } else {
	if {$f < $data(capture-current-frame)} {
	    set skip [expr {($data(capture-current-frame)-$f)}]
	    set samples [lrange $samples [expr {2*$skip}] end]
	    puts "skipped $skip samples"
	}
	set f $data(capture-current-frame)
    }
    set o [expr {$f-$data(capture-start-frame)}]
    foreach {i q} $samples {
	lappend data(capture-i-xy) $o $i
	lappend data(capture-q-xy) $o $q
	incr o
    }
    incr data(capture-current-frame) [expr {[llength $samples]/2}]
    $w.c coords capture-i $data(capture-i-xy)
    $w.c coords capture-q $data(capture-q-xy)
    $w.c configure -scrollregion [$w.c bbox all]
    set data(token) [after $data(capture-millis) [list scope::collect $w]]
}

proc scope::zoom-scale {zoom} {
    set mant [lindex {1.0 2.5 5.0} [expr {$zoom%3}]]
    return [expr {$mant*pow(10, $zoom/3)}]
}

proc scope::format-scale {scale} {
    if {[string length $scale] <= 4} {
	return $scale
    } else {
	return [format %.1e $scale]
    }
}

proc scope::zoom {w x y} {
    upvar #0 ::scope::$w data
    # zoom 0 -> 1, 1 -> 2.5, 2 -> 5, 3 -> 10, ...
    set newx [zoom-scale [incr data(x-zoom) $x]]
    set newy [zoom-scale [incr data(y-zoom) $y]]
    $w.c scale all 0 0 [expr {$newx/$data(x-scale)}] [expr {$newy/$data(y-scale)}]
    set data(x-scale) $newx
    set data(y-scale) $newy
    $w.c configure -scrollregion [$w.c bbox all]
    set data(label-x-scale) [format-scale $data(x-scale)]
    set data(label-y-scale) [format-scale $data(y-scale)]
}

proc scope::cleanup {w} {
    if {$w eq {.}} {
	stop-taps $w
    }
}

proc scope::scope {w opts} {
    upvar #0 ::scope::$w data
    array set data $opts
    ::scope::start-taps $w
    ttk::frame $w
    grid [ttk::frame $w.m] -row 0 -column 0
    pack [ttk::button $w.m.start -text {Start Capture} -state normal -command [list scope::start $w]] -side left
    pack [ttk::button $w.m.stop -text {Stop Capture} -state disabled -command [list scope::stop $w]] -side left
    pack [ttk::button $w.m.clear -text {Clear} -state disabled -command [list scope::clear $w]] -side left
    pack [ttk::button $w.m.xplus -text {+x} -command [list scope::zoom $w 1 0]] -side left
    pack [ttk::label $w.m.xlabel -textvariable ::scope::${w}(label-x-scale)] -side left
    pack [ttk::button $w.m.xminus -text {-x} -command [list scope::zoom $w -1 0]] -side left
    pack [ttk::button $w.m.yplus -text {+y} -command [list scope::zoom $w 0 1]] -side left
    pack [ttk::label $w.m.ylabel -textvariable ::scope::${w}(label-y-scale)] -side left
    pack [ttk::button $w.m.yminus -text {-y} -command [list scope::zoom $w 0 -1]] -side left
    grid [canvas $w.c] -row 1 -column 0 -sticky nsew
    grid [ttk::scrollbar $w.v] -row 1 -column 1 -sticky ns
    grid [ttk::scrollbar $w.h -orient horizontal] -row 2 -column 0 -sticky ew
    grid columnconfigure $w 0 -weight 100
    grid rowconfigure $w 1 -weight 100
    $w.c configure -xscrollcommand [list $w.h set]
    $w.c configure -yscrollcommand [list $w.v set]
    $w.h configure -command [list $w.c xview]
    $w.v configure -command [list $w.c yview]
    $w.c create line 0 0 0 0 -tags capture-i -fill red
    $w.c create line 0 0 0 0 -tags capture-q -fill green
    bind . <Destroy> [list ::scope::cleanup %W]
    return $w
}

proc main {argv} {
    array set data [array get ::scope::default_data]

    foreach {option value} $argv {
	switch -- $option {
	    -n - -name - --name {
		set data(name) $value
		wm title . $value
	    }
	    -x - --x { set data(x-scale) $value }
	    -y - --y { set data(y-scale) $value }
	    -t - --taps { set data(taps) $value }
	    -c - --connect { set data(connect) $value }
	}
    }

    pack [scope::scope .$data(name) [array get data]] -fill both -expand true
}

main $argv
