#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set libdir [file normalize [file join [file dirname [info script]] .. lib sdrkit]]
set so [info sharedlibextension]

#
# verify that each loadable library loads
# and try some other tricks
#

#
# array to identify which other tricks to try
array set data {
    keyer_ascii {keyer::ascii norm}
    keyer_detime {keyer::detime norm}
    keyer_iambic {keyer::iambic norm}
    keyer_tone {keyer::tone norm}
    agc {sdrkit::agc norm}
    atap {sdrkit::atap atap}
    audio_tap {sdrkit::audio-tap atap}
    biquad {sdrkit::biquad norm}
    constant {sdrkit::constant norm}
    fftw {sdrkit::fftw fftw}
    gain {sdrkit::gain norm}
    iq_balance {sdrkit::iq-balance norm}
    iq_swap {sdrkit::iq-swap norm}
    jack {sdrkit::jack jack}
    lo_mixer {sdrkit::lo-mixer norm}
    midi_insert {sdrkit::midi-insert norm}
    mixer {sdrkit::mixer norm}
    mono_to_iq {sdrkit::mono-to-iq norm}
    mtap {sdrkit::mtap norm}
    noise {sdrkit::noise norm}
    oscillator {sdrkit::oscillator norm}
}
array set results {
    load-succeeded 0
    load-failed 0
}
foreach file [glob [file join $libdir *$so]] {
    set module [file root [file tail $file]]
    if {[catch {load $file} error]} {
	puts "load $file -> $error"
	incr results(load-failed)
    } else {
	incr results(load-succeeded)
	if { ! [info exist data($module)]} {
	    puts "no module data for $module"
	    continue
	} 
	lassign $data($module) factory type
	switch $type {
	    norm {
		if {[catch {$factory foo} error]} {
		    puts "factory $factory failed -> $error"
		    continue
		}
		if {[catch {foo configure} error]} {
		    puts "factory $factory configure failed -> $error"
		    continue
		}
		foreach conf $error {
		    set opt [lindex $conf 0]
		    if {[catch {foo cget $opt} error]} {
			puts "factory $factory cget $opt failed -> $error"
		    }
		    if {[catch {foo cdoc $opt} error]} {
			puts "factory $factory cdoc $opt failed -> $error"
		    }
		}
		if {[catch {rename foo {}} error]} {
		    puts "rename $factory {} failed -> $error"
		}
	    }
	    jack {
	    }
	    fftw {
	    }
	}
    }
}

