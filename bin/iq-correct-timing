#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

package require sdrtcl
package require sdrtcl::jack
package require sdrtcl::iq-correct-train
package require sdrtcl::audio-tap

array set data {
    -loop 100
    -server default
    -name iq
    -tap {system:capture_2 system:capture_1}
    -mu-set {}
    -buffer 10
}

for {set i 26} {$i >= -10} {incr i -1} {
    lappend data(-mu-set) [expr {2.0**$i}]
    lappend data(selected-mus) [expr {2.0**$i}]
}

# get a buffer of samples from the tap and format as a list of floats
# make sure we get a very fresh buffer of samples
proc acquire-buffer {} {
    while {1} {
	# get the oldest buffer available
	lassign [$::data(-name)-tap get] frame buffer
	# if there is no such buffer
	if {$frame == 0} {
	    # use the last buffer we read
	    if {[info exists lbuffer]} {
		binary scan $lbuffer f* lbuffer
		return $lbuffer
	    }
	    # sleep and try again
	    after 1
	} else {
	    # remember the last buffer we read
	    set lbuffer $buffer
	}
    }
}

# format the list of floats back into a binary byte array
proc format-buffer {buffer} {
    return [binary format f* $buffer]
}

# compute the average power dBFS of the samples
proc compute-power {buffer} {
    set sum 0
    set n 0
    foreach {r i} $buffer {
	set sum [expr {$sum+$r*$r+$i*$i}]
	incr n
    }
    set mean2 [expr {$sum/$n}]
    set dBFS [expr {10 * log10($mean2+1e-16)}]
    return $dBFS
}

proc time-loop {iter command} {
    puts "time-loop iter=$iter #command=[llength $command]"
    set t0 [clock microseconds]
    for {set i 0} {$i < $iter} {incr i} {
        set result [{*}$command]
    }
    return [expr {double([clock microseconds]-$t0)/$iter}]
}

proc main {argv} {
    foreach {option value} $argv {
	puts "$option $value"
	switch -- $option {
	    -b - -buffer - --buffer { set ::data(-buffer) $value }
	    -l - -loop - --loop { set ::data(-loop) $value }
	    -n - -name - --name { set ::data(-name) $value }
	    -s - -server - --server { set ::data(-server) $value }
	    -t - -tap - --tap { set ::data(-tap) $value }
	    default { error "unknown option \"$option\"" }
	}
    }
    sdrtcl::audio-tap $::data(-name)-tap -server $::data(-server) -log2size $::data(-buffer) -log2n 2 -complex 1
    $::data(-name)-tap activate
    puts "$::data(-name)-tap activate"
    $::data(-name)-tap start
    puts "$::data(-name)-tap start"
    if {$::data(-tap) ne {}} {
	foreach in $::data(-tap) out [$::data(-name)-tap info ports] {
	    sdrtcl::jack connect $in [join [list $::data(-name)-tap $out] :]
	}
    }
    after 50

    set ::data(samples) [acquire-buffer]
    puts "[llength $::data(samples)] samples"
    set binary [format-buffer $::data(samples)]
    puts "[string length $binary] bytes of samples"
    set mu 1
    set w {0 0}
    set t0 [time-loop $::data(-loop) [list sdrtcl::iq-correct-train0 {*}$w $binary]]
    set t1 [time-loop $::data(-loop) [list sdrtcl::iq-correct-train1 $mu {*}$w $binary]]
    set t2 [time-loop $::data(-loop) [list sdrtcl::iq-correct-train2 $mu {*}$w $binary]]
    puts "$t0 usecs apply"
    puts "$t1 usecs train"
    puts "$t2 usecs stats"
    if {0} {
	foreach sr {48000 96000 192000 384000} {
	    puts "[expr {1024/double($sr)*1e6}] microseconds to process each buffer at $sr samples/second"
	}
    }
}

main $argv
