#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

package require Tk
package require panorama
package require sdrkit
package require sdrkit::jack
package require sdrkit::iq-correct
package require sdrkit::lo-mixer
package require sdrkit::gain
package require sdrkit::demod-am
package require sdrkit::demod-fm
package require sdrkit::demod-sam

#
# an sdr as a pipeline
# capture | iq-correct | lo-mixer | filter-overlap-save | gain | demod | playback
# one or more spectrum/waterfall/meter displays that can be tapped into the pipeline
# at any point.
# noise reduction and additional filtering can be added at any point.
#

array set data {
    server default
    name osc
    length 320
    freq 600.0
    min-freq -23500
    max-freq 23500
    gain -75.0
    min-gain -130.0
    max-gain 0.0
    iq-sine 0.0
    iq-gain 0.0
    noise -100.0
    iq-noise -100.0
    corrector-on 0
    corrector-mu 0.25
    corrector-wi 0.00
    corrector-wq 0.00
    corrector-ndw2 0.00
    corrector-m2dw 0.00
    corrector-ratio 0.00
    corrector-avg-ratio 0.00
    corrector-abs-mag 0.00
    corrector-abs-mag-max -5
    corrector-rel-mag 0.00
    corrector-rel-mag-min -9 corrector-rel-mag-max -8
    corrector-t {0 0 0 0 0 0 0 0}
    corrector-ws {0 0 0 0 0 0 0 0}
    corrector-dots {0 0 0 0 0 0 0 0}
    corrector-kick 0
    corrector-kick-up 6 corrector-kick-down 2
    corrector-state idle
}

namespace eval ::meters {}

##
## meter the possible iq balancing signals
## this is plotting the transform applied
## to incoming iq signals
##
proc ::meters::update {w} {
    upvar #0 ::meters::$w data
    foreach {wi wq ndw2 m2d2} [iq-correct get] break
    if {abs($wi) > 1e-12 && abs($wq) > 1e-12} {
	set xy {}
	foreach {t ct st} $data(theta-cos-sin) {
	    lappend xy [expr {$ct - $wi * $st}] [expr {$st - $wq * $ct}]
	}
	$w coords xyplot $xy
	$w scale xyplot 0 0 75 -75
	$w move xyplot 125 125
    }
    after 10 [list ::meters::update $w]
}

proc ::meters::setup {w n} {
    upvar #0 ::meters::$w data
    set data(n-theta) $n
    set data(theta-cos-sin) {}
    set pi [expr {atan2(0,-1)}]
    for {set i 0} {$i <= $n} {incr i} {
	set theta [expr {2*$pi*$i/$n}]
	lappend data(theta-cos-sin) $theta [expr {cos($theta)}] [expr {sin($theta)}]
    }
    catch {$w delete all}
    $w create line {0 0 0 0} -fill white -tags xyplot
}
proc ::meters {w args} {
    upvar #0 ::meters::$w data
    canvas $w -bg black -width 250 -height 250
    ::meters::setup $w 32
    return $w
}

##
## controller for gain
##

proc set-gain {g} {
    gain configure -gain $g
    set ::data(label-gain) [format %.2f $g]
}

##
## controller display for iq-correct
##
proc more-mu {} {
    set ::data(corrector-mu) [expr {2*$::data(corrector-mu)}]
    set ::data(label-corrector-mu) [format %.13f $::data(corrector-mu)]
    iq-correct configure -mu $::data(corrector-mu)
}
proc less-mu {} {
    set ::data(corrector-mu) [expr {$::data(corrector-mu)/2}]
    set ::data(label-corrector-mu) [format %.13f $::data(corrector-mu)]
    iq-correct configure -mu $::data(corrector-mu)
}
proc reset-ws {} {
    iq-correct reset
}
proc update-ws {} {
    foreach {wi wq ndw2 m2dw} [iq-correct get] break
    set t [sdrkit::jack frame-time]
    set b [sdrkit::jack buffer-size]
    if {$wi != 0 || $wq != 0 } {
	if {[catch {
	    # puts "$wi $wq $ndw2 $m2dw"
	    # puts "$ndw $mdw $mw"
	    # update our list of filter weights
	    lassign $::data(corrector-ws) wi1 wq1 wi2 wq2 wi3 wq3 wi4 wq4
	    set ::data(corrector-ws) [list $wi $wq $wi1 $wq1 $wi2 $wq2 $wi3 $wq3]
	    # construct the last delta
	    lassign $::data(corrector-t) t1 t2 t3 t4 t5 t6 t7 t8
	    set ::data(corrector-t) [list $t $t1 $t2 $t3 $t4 $t5 $t6 $t7]
	    set dt1 [expr {$t-$t1}]
	    set dwi0 [expr {($wi-$wi1)/$dt1}]
	    set dwq0 [expr {($wq-$wq1)/$dt1}]
	    # construct the overall delta
	    set dt4 [expr {$t-$t4}]
	    set dwi [expr {($wi-$wi4)/$dt4}]
	    set dwq [expr {($wq-$wq4)/$dt4}]
	    set len2 [expr {$dwi*$dwi+$dwq*$dwq}]
	    # update the dot signal
	    incr ::data(corrector-kick) [expr {-[lindex $::data(corrector-dots) 0]}]
	    set ::data(corrector-dots) [lrange $::data(corrector-dots) 1 end]
	    set newdot [expr {$len2 > 0 && 0.7 <= (($dwi0*$dwi+$dwq0*$dwq)/$len2)}]
	    incr ::data(corrector-kick) $newdot
	    lappend ::data(corrector-dots) $newdot
	    set ::data(label-corrector-kick) $::data(corrector-kick)
	    if {1} {
		set ndw [expr {sqrt($ndw2)/$b}]
		set mdw [expr {sqrt($m2dw)/$b}]
		set mw [expr {sqrt($wi*$wi+$wq*$wq)}]
		set ratio [expr {log10(1.0e-100+$ndw/$mdw)}]
		set {abs-mag} [expr {log10(1.0e-100+$mdw)}]
		set {rel-mag} [expr {log10(1.0e-100+$mdw/$mw)}]
	    } else {
		set mw2 [expr {$wi*$wi+$wq*$wq}]
		set ratio [expr {log10(1.0e-100+$ndw2/$m2dw)}]
		set {abs-mag} [expr {log10(1.0e-100+$m2dw)}]
		set {rel-mag} [expr {log10(1.0e-100+$m2dw/$mw2)}]
	    }
	    foreach v {ratio abs-mag rel-mag} {
		set ::data(corrector-$v) [set $v]
		set ::data(label-corrector-$v) [format %.2f $::data(corrector-$v)]
	    }
	    foreach v {wi wq ndw2 m2dw} {
		set ::data(corrector-$v) [expr {($::data(corrector-$v)+[set $v])/2}]
		set ::data(label-corrector-$v) [format %.10g $::data(corrector-$v)]
	    }
	    # the problem with the kick reading is that the very next kick reading
	    # is going to share 7 readings with the previous reading
	    switch $::data(corrector-state) {
		idle {
		    ## in idle state we look for a kick of 8 to shift to converge
		    ## we need to maintain a level of mu that allows the kick to be seen
		    ## so filter coefficients cannot be frozen, then need to be turning over
		    ## this might introduce some phase noise
		    if {$::data(corrector-kick) > $::data(corrector-kick-up)} {
			set ::data(corrector-state) converge
			more-mu
		    } elseif {$::data(corrector-rel-mag) < $::data(corrector-rel-mag-min)} {
			more-mu
		    } elseif {$::data(corrector-rel-mag) > $::data(corrector-rel-mag-max)} {
			less-mu
		    }

		}
		converge {
		    ## in converge state we look a decay in the kick signal to shift to relax
		    ## mu is large, so we need to observe the level of the error signal
		    ## and adjust to keep the filter from going into oscillation or chaos
		    if {$::data(corrector-abs-mag) > $::data(corrector-abs-mag-max)} {
			less-mu
		    } elseif {$::data(corrector-rel-mag) < $::data(corrector-rel-mag-max)} {
			set ::data(corrector-state) idle
		    } elseif {$::data(corrector-kick) < $::data(corrector-kick-down)} {
			less-mu
		    } elseif {$::data(corrector-kick) > $::data(corrector-kick-up)} {
			more-mu
		    }
		}
	    }
	    set ::data(label-corrector-state) $::data(corrector-state)
	} error]} {
	    puts "$error: $::errorInfo"
	    if {$::data(corrector-on)} corrector-onoff
	}
    }
    after 20 [list update-ws]
}

proc corrector-onoff {} {
    if {$::data(corrector-on)} {
	#puts "iq-correct reset to -mu $::data(corrector-mu)"
	iq-correct reset
	iq-correct configure -mu 1
    } else {
	#puts "iq-correct muted to 0"
	iq-correct configure -mu 0
	iq-correct reset
    }
}

proc shutdown {w} {
    if {$w eq {.}} {
	rename iq-correct {}
	rename gain {}
    }
}

proc main {argv} {
    if {$::data(max-freq) > [sdrkit::jack sample-rate]/4} {
	set ::data(max-freq) [expr {[sdrkit::jack sample-rate]/4.01}]
    }
    foreach {option value} $argv {
	switch -- $option {
	    -n - -name - --name { set ::data(name) $value }
	    -s - -server - --server { set ::data(server) $value }
	    -l - -length - --length { set ::data(length) $value }
	    -f - -freq - --freq - -frequency - --frequency { set ::data(freq) $value }
	    -min-freq - --min-freq { set ::data(min-freq) $value }
	    -max-freq - --max-freq { set ::data(max-freq) $value }
	    -g - -gain - --gain { set ::data(gain) $value }
	    -min-gain - --min-gain { set ::data(min-gain) $value }
	    -max-gain - --max-gain { set ::data(max-gain) $value }
	    default { error "unknown option \"$option\"" }
	}
    }

    ## sdrkit::oscillator osc
    ## sdrkit::oscillator-zd osc
    ## sdrkit::noise noise
    ## sdrkit::iq-noise iq-noise
    ## sdrkit::iq-balance iq-balance
    sdrkit::iq-correct iq-correct
    sdrkit::lo-mixer lo-mixer -freq 10000
    sdrkit::gain gain
    sdrkit::demod-sam demod
    
    wm title . sdrkit:radio

    set row 0
    grid [panorama .pan -width 1024] -row $row -column 0 -columnspan 6 -sticky nsew
    incr row
    grid [ttk::label .blk$row -text {Gain}] -row $row -column 0 -columnspan 3
    incr row
    grid [ttk::label .gain$row-l -textvar ::data(label-gain) -width 10 -anchor e] -row $row -column 0
    grid [ttk::label .gain$row-u -text {dB}] -row $row -column 1
    grid [ttk::scale .gain$row-s -from -100.00 -to 100.00 -command set-iq-gain -variable ::data(gain) -length $::data(length)] -row $row -column 2 -sticky ew
    set ::data(gain) -100.0
    set-gain -100.0
    .gain$row-s configure -command [list set-gain]
    incr row
    grid [ttk::label .blk$row -text {Corrector}] -row $row -column 0 -columnspan 3
    incr row
    grid [ttk::frame .blk$row] -row $row -column 0 -columnspan 3
    foreach item {mu wi wq ndw2 m2dw} {
	pack [ttk::label .blk$row.l-$item -text $item] -side left
	pack [ttk::label .blk$row.v-$item -textvariable ::data(label-corrector-$item) -width 15] -side left
	set ::data(label-corrector-$item) [format %.13f $::data(corrector-$item)]
    }
    incr row
    grid [ttk::frame .blk$row] -row $row -column 0 -columnspan 3
    foreach item {state ratio kick abs-mag rel-mag} {
	pack [ttk::label .blk$row.l-$item -text $item] -side left
	pack [ttk::label .blk$row.v-$item -textvariable ::data(label-corrector-$item) -width 10] -side left
	if {$item eq {state}} {
	    set ::data(label-corrector-$item) $::data(corrector-$item)
	} else {
	    set ::data(label-corrector-$item) [format %.2f $::data(corrector-$item)]
	}
    }
    incr row
    grid [ttk::frame .blk$row] -row $row -column 0 -columnspan 3
    pack [ttk::checkbutton .blk$row.onoff -text {Enable} -variable ::data(corrector-on) -onvalue 1 -offvalue 0 -command corrector-onoff] -side left
    pack [ttk::button .blk$row.more-mu -text {Less mu} -command [list less-mu]] -side left
    pack [ttk::button .blk$row.less-mu -text {More mu} -command [list more-mu]] -side left
    pack [ttk::button .blk$row.reset-ws -text {Reset wi/wq} -command [list reset-ws]] -side left
    incr row

    set row 1
    grid [meters .blk2$row] -row $row -column 3 -columnspan 3 -rowspan 10
    ::meters::update .blk2$row
    grid columnconfigure . 2 -weight 100
    grid columnconfigure . 5 -weight 100
    grid rowconfigure . 0 -weight 100

    sdrkit::jack connect system:capture_1 iq-correct:in_q
    sdrkit::jack connect system:capture_2 iq-correct:in_i
    sdrkit::jack connect iq-correct:out_i capture_spectrum_1:in_i
    sdrkit::jack connect iq-correct:out_q capture_spectrum_1:in_q
    sdrkit::jack connect iq-correct:out_i lo-mixer:in_i
    sdrkit::jack connect iq-correct:out_q lo-mixer:in_q
    sdrkit::jack connect lo-mixer:out_i gain:in_i
    sdrkit::jack connect lo-mixer:out_q gain:in_q
    sdrkit::jack connect gain:out_i demod:in_i
    sdrkit::jack connect gain:out_q demod:in_q
    sdrkit::jack connect demod:out_i audioadapter:playback_1
    sdrkit::jack connect demod:out_q audioadapter:playback_2
    corrector-onoff
    update-ws
    bind . <Destroy> [list shutdown %W]
}

main $argv
