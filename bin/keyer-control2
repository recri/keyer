#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-

lappend auto_path [file join [file dirname [info script]] .. lib]

package require Tk
package require keyer
package require sdrkit
package require keyer-control

#
# default option set
#

array set opts {
    ascii 1
    iambic 1

    iambic-chan 1
    iambic-note 0
    ascii-chan 1
    ascii-note 0

    ascii_tone-freq 700
    ascii_tone-gain -30
    ascii_tone-rise 5
    ascii_tone-fall 5

    ascii-wpm 15
    ascii-word 50
    ascii-dah 3
    ascii-ies 1
    ascii-ils 3
    ascii-iws 7

    iambic_tone-freq 750
    iambic_tone-gain -30
    iambic_tone-rise 5
    iambic_tone-fall 5

    iambic-wpm 15
    iambic-word 50
    iambic-dah 3
    iambic-ies 1
    iambic-ils 3
    iambic-iws 7
    iambic-mode A
    iambic-alsp 0
    iambic-awsp 0
    iambic-swap 0
}

#
# get the options for the client
#
proc client-opts {client} {
    global opts
    foreach name [array names opts $client-*] {
	set val $opts($name)
	set name [string range $name [expr {1+[string length $client]}] end]
	lappend args "-$name" $val
    }
    return $args
}

#
# initialize the clients
#
proc client-init {} {
    global opts

    # start jack?

    # look for zombie helpers?
    set ports [sdrkit::jack list-ports]
    foreach port [dict keys $ports] {
	foreach conn [dict get $ports $port connections] {
	    switch -glob $line {
		ascii:* -
		iambic:* -
		ascii_tone:* -
		iambic_tone:* {
		    error "the [lindex [split $line :] 0] client is still running"
		}
	    }
	}
	switch -glob $port {
	    system:midi_capture_* {
		set midi_capture $port
	    }
	}
    }
    # make helpers
    set clients {}
    set connects {}
    # make the ascii keyer
    if {$opts(ascii)} {
        keyer::ascii ascii {*}[client-opts ascii]
	lappend clients ascii
	keyer::tone ascii_tone {*}[client-opts ascii_tone]
	lappend clients ascii_tone
	lappend connects {sdrkit::jack connect ascii:midi_out ascii_tone:midi_in}
	lappend connects {sdrkit::jack connect ascii_tone:out_i system:playback_1}
	lappend connects {sdrkit::jack connect ascii_tone:out_q system:playback_2}
    } else {
	lappend clients {} {}
    }
    # make the iambic keyer
    if {$opts(iambic)} {
	if { ! [info exists midi_capture]} {
	    error "no midi_capture port for keyer connection"
	}
	# plug-open keyer::iambic iambic
	keyer::iambic iambic {*}[client-opts iambic]
	lappend clients iambic
	keyer::tone iambic_tone {*}[client-opts iambic_tone]
	lappend clients iambic_tone
	lappend connects [list sdrkit::jack connect $midi_capture iambic:midi_in]
	lappend connects {sdrkit::jack connect iambic:midi_out iambic_tone:midi_in}
	lappend connects {sdrkit::jack connect iambic_tone:out_i system:playback_1}
	lappend connects {sdrkit::jack connect iambic_tone:out_q system:playback_2}
    } else {
	lappend clients {} {}
    }
    # make the connections
    foreach cmd $connects {
	if {[catch "eval $cmd" error]} {
	    puts "$cmd: yielded $error"
	}
    }
    return $clients
}

#
# 
#
proc main {argv} {
    global opts

    foreach {opt value} $argv {
	if {[info exists opts([string range $opt 2 end])]} {
	    set opts([string range $opt 2 end]) $value
	} elseif  {[info exists opts([string range $opt 1 end])]} {
	    set opts([string range $opt 1 end]) $value 
	} else {
	    error "unknown option: \"$opt\""
	}
    }
    if {$opts(ascii) || $opts(iambic)} {
	keyer-control .ctl {*}[client-init] [array get opts]
	bind . <Destroy> [list ui-close %W]
	if {$opts(ascii)} {
	    bind . <KeyPress> [list ascii puts %A]
	}
    } else {
	error "no keyers to control"
    }
}

main $argv