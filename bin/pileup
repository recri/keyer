#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

###
### original readme file
###

# pileup - CW pileup program for Linux
# 	
# This program is based on sccw - Soundcard CW for Linux by Steven J. Merrifield
# VK3ESM sjm@ee.latrobe.edu.au http://livewire.ee.latrobe.edu.au. I have modified
# its use from a morse code tutor into a pileup program using multiple SoundBlaster
# voices.
# 
# -----------------------------------------------------------------------------
# 
# "Pileup" is a morse code program which generates callsigns using
# a specified number of the SoundBlaster's voices. This simulates the sound of
# a CW pileup. The greater the number of voices the more difficult the program is.
# 
# The idea is based on the tapes used at Amateur Radio Conventions to test 
# people's CW skills. However it is more random and can be made more difficult!
# 
# The callsigns sent are those worked by M6A in the 1996 CQ WW CW contest to
# add some realism.
# 
# Build instructions:
# 1. Type "make"  to produce the executable "pileup"
# 2. As root type "make install". This makes "pileup" a setuid root program.
#    This is required as low level code is used to address the SoundBlater 
#    card requiring root privileges.
# 
# The program uses LinuxThreads by Xavier Leroy (Xavier.Leroy@inria.fr)
# (a copy of which is provided with the pileup TAR file). The pileup program 
# is by default statically linked with the libpthread.a library (a copy of 
# which is provided with the pileup TAR file). The pileup program also requires 
# pthread.h (also enclosed with the pileup TAR file).
# 
# As LinuxThreads uses the clone() system call a kernel 2.0+ is required.
# Version 1.0 of the pileup program (which can be used with a 1.2.* kernel
# is available from http://www.babbage.demon.co.uk/pileup.html).
# 
# -----------------------------------------------------------------------------
# 
# The program can be run in two modes - Competition or Practice. 
# 
# a. Competition mode sends 50 callsigns and you enter each callsign copied 
# using the keyboard (pressing ENTER after each callsign). Partial callsigns 
# are allowed. After the 50 callsigns are sent your score is determined and
# the list of 50 sent callsigns displayed along with the received callsigns.
# Please send your scores to richard@babbage.demon.co.uk to add to the
# Pilup Score List!
# 
# b. Practice mode sends the whole contents of the calls.dat file displaying
# each callsign as it is sent.
# 
# Use:
# 1. Type "pileup" to run the program
# 2. The program then prompts for the number of voices. Enter a number from
#    1 to 9 inclusive. The higher the number of voices the greater the
#    cacophony and the greater the difficulty. A value of 2 is a good starting
#    point.
# 3. The program then prompts for the CW speed. Enter a value in words per
#    minutes (e.g 25). Note that this will be the *slowest* speed used!
# 4. The program then prompts for Competition or Practice mode. Enter 'c'
#    for competition mode, 'p' for practice mode.
# 5. Start copying those callsigns (and typing them into the keyboard if
#    you are in competition mode)!
# 
# -----------------------------------------------------------------------------
# 
# Features v1.0:
# 1. Up to 9 voices can be sent (I find that 3 voices are enough!);
# 2. Each voice is faster in speed and lower in volume than the previous to 
#    simulate the "layering" of stations found in pileups;
# 3. The tone of each call is different in the pileup to simulate the
#    spread of stations in a pileup;
# 
# New Features v1.1:
# 1. Added a competition mode. 50 callsigns are sent and your copying
#    ability is scored. The greater the accuracy the greater the score. A
#    list of high scores can be found at 
#    http://www.babbage.demon.co.uk/pileup.html
# 2. Multi-threaded using LinuxThreads.
# 
# -----------------------------------------------------------------------------
# 
# To do list:
# 1. Add QRM/QRN noises
# 2. Add a difficulty level
# 3. Add curses interface 
# 
# Any bugs, suggestions etc to richard@babbage.demon.co.uk
#
# ---------------------------------------------------------------------------
# 
# Richard Everitt G4ZFE
# richard@babbage.demon.co.uk
# http://www.babbage.demon.co.uk
# 

###
### adaptation to keyer by Roger E Critchlow Jr, AD5DZ
### rec@elf.org
### http://elf.org
###
### notes on keyer adaptation
### 1) there is no fixed maximum number of voices, but Jack gives up around?
### 2) don't type your answers, key them back
###

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

package require Tk

package require keyer::ascii
package require keyer::detime
package require keyer::iambic
package require keyer::tone
package require keyer::ptt
package require keyer::ptt-mute
package require keyer::debounce
package require sdrkit::jack
package require sdrkit::gain
package require sdrkit::noise

package require keyer-control
package require hurricane
package require capture
package require morse::morse

#
# default options
# The callsigns worked by M6A in the 1996 CQ WW CW contest
#
namespace eval ::main {
    array set data {
	state 0

	game-menues {
	    mode mode {} {menu {callsigns} {7 dit words} {9 dit words} {11 dit words} {13 dit} {15 dit} {17 dit} {19 dit} {21 dit} {23 dit} {25 dit} } {}
	    voices {N voices} {} {menu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30} {}
	    n-items {N items} {} {menu 10 50 100 500 1000 5000 10000 50000} {}
	    wpm {base speed} words/minute {scale 5 60} {}
	    wpm-range {speed range} words/minute {scale 0 20} {}
	    gain {base gain} dB {scale 0 -160} {}
	    gain-range {gain range} dB {scale 160 -160} {}
	    noise {noise level} dB {scale 0 -160} {noise configure -gain}
	    output-gain {output gain} dB {scale 0 -160} {pileup configure -gain}
	}

	mode {7 dit words}
	voices 1
	n-items 10
	wpm 10
	wpm-range 20
	tone 500
	tone-range 300
	gain -10
	gain-range -10
	noise -30
	output-gain -30

	number_session 0
	sent {}
	max_speed 0

	play-panel-update-simulate-delay 25
	play-codes-to-draw {}
	drawn-items {}
    }
    # characters grouped by number of dit clocks
    # excluding the inter-letter space that follows
    array set dits {
	1 "e"
	3 "it"
	5 "ans"
	7 "dhmru"
	9 "5bfgklvw"
	11 "!%46copxz"
	13 "+/37=jqy"
	15 "\"(*-28?"
	17 "\$.19:;@_"
	19 "'),0"
    }
}

proc ::main::heard_clear {} {
    set ::main::data(sent) {}
    set ::main::data(unmatched) {}
    .sent.sent delete 0.0 end
}

proc ::main::heard_callsign {call code} {
    lappend ::main::data(sent) [list $call $code]
    lappend ::main::data(unmatched) $code
    .sent.sent insert end "$call $code\n"
    .sent.sent see end
}
    
proc ::main::translate {dict call} {
    return [text-to-morse $dict $call]
}
    
proc ::main::draw_callsign {call speed tone gain code} {
    lappend ::main::data(play-codes-to-draw) [list $call $speed $tone $gain $code]
    #puts "draw_callsign $call $speed $tone $gain $code"
}

proc ::main::hear_callsign {call voice code continuation} {
    if {[ascii$voice pending]} {
	set ::main::data(after-$voice) [after 100 [list ::main::hear_callsign $call $voice $code $continuation]]
    } else {
	heard_callsign $call $code
	set ::main::data(after-$voice) [eval $continuation]
    }
}

proc ::main::send_callsign {call voice speed tone gain continuation} {
    set ::main::data(max_speed) [expr {max($::main::data(max_speed), $speed)}]
    tone$voice configure -freq $tone -gain $gain
    ascii$voice configure -wpm $speed
    ascii$voice puts $call
    set code [translate [ascii$voice cget -dict] $call]
    draw_callsign $call $speed $tone $gain $code
    hear_callsign $call $voice $code $continuation
}

proc ::main::listen_clear {} {
    set ::main::data(matched) {}
    .rcvd.rcvd delete 0.0 end
    .rcvd.rcvd tag configure correct -foreground green
    .rcvd.rcvd tag configure wrong -foreground red
}

proc ::main::listen_for_echoes {echo} {
    append echo [iambic_detime gets]
    set echoes [split $echo \n]
    if {[llength $echoes] > 1} {
	set echo [lindex $echoes end]
	foreach item [lrange $echoes 0 end-1] {
	    set item [string trim $item]
	    lappend ::main::data(rcvd) $item
	    set i [lsearch $::main::data(unmatched) $item]
	    if {$i >= 0} {
		set ::main::data(unmatched) [lreplace $::main::data(unmatched) $i $i]
		lappend ::main::data(matched) $item
		.rcvd.rcvd tag add correct end-1 end
	    } else {
		.rcvd.rcvd tag add wrong end-1 end
	    }
	    .rcvd.rcvd insert end $item\n
	}
    }
    after 250 [list ::main::listen_for_echoes $echo]
}

proc ::main::sound_voice {voice} {
    if {$::main::data(number_session) > 0} {
	# reduce the count to be sent
	incr ::main::data(number_session) -1
	# get the callsign to be sent
	set call [lindex $::main::data(items) 0]; set ::main::data(items) [lrange $::main::data(items) 1 end]
	# choose a random speed
	set speed [expr {rand() * $::main::data(wpm-range) + $::main::data(wpm)}]
	# choose a random tone
	set tone [expr {(rand() * $::main::data(tone-range)) + $::main::data(tone)}]
	# choose a random gain
	set gain [expr {(rand() * $::main::data(gain-range)) + $::main::data(gain)}]
	# choose the timeout between the end of this call
	# and the start of the next call on this voice
	set timeout [expr {int(rand () * 3000)}]
	# send the callsign and wait for it to finish
	send_callsign $call $voice $speed $tone $gain [list after $timeout [list ::main::sound_voice $voice]]
    } else {
	stop_voice $voice
    }
}

proc ::main::start_voice {voice} {
    # mark us as active
    incr ::main::data(active-voices)
    set ::main::data(voice-$voice) {}
    # start keyer
    keyer::ascii ascii$voice
    keyer::tone tone$voice
    # keyer::detime detime$voice
    # connect
    sdrkit::jack connect ascii$voice:midi_out tone$voice:midi_in
    sdrkit::jack connect tone$voice:out_i pileup:in_i
    sdrkit::jack connect tone$voice:out_q pileup:in_q
    # sdrkit::jack connect ascii$voice:midi_out detime$voice:midi_in
    # start loop until all sent
    after [expr {int(rand () * 3000)}] [list ::main::sound_voice $voice]
}

proc ::main::stop_voice {voice} {
    if {[info exists ::main::data(voice-$voice)]} {
	unset ::main::data(voice-$voice)
	incr ::main::data(active-voices) -1
	catch {after cancel $::main::data(after-$voice)}
	rename ascii$voice {}
	rename tone$voice {}
	# rename detime$voice {}
    }
}

proc ::main::check_if_finished {} {
    if {$::main::data(number_session) > 0 || $::main::data(active-voices) > 0} {
	after 100 ::main::check_if_finished
    } else {
	stop
    }
}

proc ::main::choose_items {n list} {
    set choices {}
    set length [llength $list]
    while {[incr n -1] >= 0} {
	lappend choices [lindex $list [expr {int(rand()*$length)}]]
    }
    return $choices
}

proc ::main::start {} {
    # change button state
    .play.m.start configure -state disabled
    #.play.m.pause configure -state normal
    .play.m.stop  configure -state normal
    set ::main::data(state) 1
    # choose mode
    switch $::main::data(mode) {
	callsigns {
	    set ::main::data(number_session) $::main::data(n-items)
	    set ::main::data(items) [choose_items $::main::data(number_session) [morse-pileup-callsigns]]
	}
	default {
	    set ::main::data(number_session) $::main::data(n-items)
	    set dits [lindex $::main::data(mode) 0]
	    set words [morse-words-of-length [heckler cget -dict] $dits]
	    set ::main::data(items) [choose_items $::main::data(number_session) $words]
	}
    }
    # clear sent
    ::main::heard_clear
    # clear received
    ::main::listen_clear
    # start voices
    set ::main::data(active-voices) 0
    for {set voice 0} {$voice < $::main::data(voices)} {incr voice} {
	start_voice $voice
    }
    # listen for echoes
    ::main::listen_for_echoes {}
    # wait for done
    ::main::check_if_finished
}

proc ::main:pause {} {
    # change button state
    .play.m.start configure -state normal
    #.play.m.pause configure -state disabled
    .play.m.stop  configure -state normal
    set ::main::data(state) 2
}

proc ::main::stop {} {
    # change button state
    .play.m.start configure -state normal
    #.play.m.pause configure -state disabled
    .play.m.stop  configure -state disabled
    set ::main::data(state) 0
    for {set voice 0} {$voice < $::main::data(voices)} {incr voice} {
	stop_voice $voice
    }
}

##
## user interface
##
proc ::main::close-window {w ew} {
    if {$w eq $ew} {
	foreach x $::main::data(on-exit) {
	    catch $x
	}
	::main::stop
    }
}

proc ::main::about-panel {w} {
    ttk::frame $w
    pack [text $w.t] -fill both -expand true
    $w.t insert end {
 Welcome to Pileup V 2011!  This is an update of:

     pileup - CW pileup program for Linux by Richard Everitt G4ZFE
 	
     This program is based on sccw - Soundcard CW for Linux by Steven J. Merrifield
     VK3ESM sjm@ee.latrobe.edu.au http://livewire.ee.latrobe.edu.au. I have modified
     its use from a morse code tutor into a pileup program using multiple SoundBlaster
     voices.

 The update involves replacing the SoundBlaster with the Jack Audio Connection Kit and
 using Tcl/Tk wrappers to assemble and control the signal processing graph.  The number
 of simultaneous voices is limited to around 18, at which point client creation starts
 failing.	

 Oh, your typing skills are of no use here, you need to key in the answers.
 
 In fact, stop trying to translate morse into characters at all for a while: just practice
 hearing the patterns and remembering them long enough to echo them back.  It may be that
 a little ear-hand practice will build up your ability to copy.
} 
    return $w
}

proc ::main::sent-panel {w} {
    ttk::frame $w
    grid [text $w.sent -yscrollcommand [list $w.vsent set]] -row 0 -column 0 -sticky nsew
    grid [ttk::scrollbar $w.vsent -orient vertical -command [list $w.sent yview]] -row 0 -column 1 -sticky ns
    grid columnconfigure $w 0 -weight 100
    return $w
}

proc ::main::rcvd-panel-trace-fired {w name1 name2 op} {
    upvar #0 ${name1}($name2) input
    # puts "trace-fired $input received"
    $w.rcvd insert end $input
    set input {}
}

proc ::main::rcvd-panel {w} {
    ttk::frame $w
    grid [text $w.rcvd -yscrollcommand [list $w.vrcvd set]] -row 0 -column 0 -sticky nsew
    grid [ttk::scrollbar $w.vrcvd -orient vertical -command [list $w.rcvd yview]] -row 0 -column 1 -sticky ns
    grid columnconfigure $w 0 -weight 100
    trace add variable ::main::data(keyer-panel-rcvd) write [list ::main::rcvd-panel-trace-fired $w]
    return $w
}

proc ::main::play-panel-window-configure {w cw wd ht} {
    if {$w eq $cw} {
	# puts "configure $w $cw $wd $ht"
    }
}
proc ::main::play-panel-window-destroy {w dw} {
    # puts "destroy $w ..."
}

##
## this is an {x y x y ...} list of
## frequency vs magnitude in dB full scale
##
proc ::main::play-panel-update {w xy} {
    ::hurricane::update $w.hurricane $xy
}

proc ::main::play-panel-setup-drawing {w call speed tone gain code} {
    ## pixels/second at play-panel-update-simulate update rate
    set pps [expr {1000/$::main::data(play-panel-update-simulate-delay)}]
    ## pixels/window width and height in waterfall
    set wd [winfo width $w.hurricane]
    set ht [winfo height $w.hurricane]
    ## dits/second at call sending speed words/minute*dits/word*minute/second
    set dps [expr {$speed*50.0*1/60.0}]
    ## pixels/dit
    set ppd [expr {$pps/$dps}]
    ## y for tone
    set y [expr {(($tone-$::main::data(tone))/$::main::data(tone-range))*$ht}]
    ## pick a color
    set color white;		# some function of gain
    ## draw a series of lines
    set c $code
    set x $wd
    ## remember where they are
    set items {}
    set nitem [llength $::main::data(drawn-items)]
    while {[string length $c] > 0} {
	switch -exact -- [string index $c 0] {
	    . {
		# draw a dit
		lappend items [$w.hurricane create line $x $y [expr {$x+$ppd}] $y -fill $color -tags code-$nitem]
		# skip to the end of the space after the dit
		set x [expr {$x+$ppd+$ppd}]
	    }
	    - {
		# draw a dah
		lappend items [$w.hurricane create line $x $y [expr {$x+3*$ppd}] $y -fill $color -tags code-$nitem]
		# skip to the end of the space after the dit
		set x [expr {$x+3*$ppd+$ppd}]
	    }
	    { } {
		# skip to the end of the space after the character
		set x [expr {$x+3*$ppd-$ppd}]
	    }
	}
	set c [string range $c 1 end]
    }
    lappend ::main::data(drawn-items) [list $call $speed $tone $gain $code $items]
}

proc ::main::play-panel-update-simulate {w} {
    set drawings $::main::data(play-codes-to-draw)
    set ::main::data(play-codes-to-draw) {}
    foreach p $drawings {
	play-panel-setup-drawing $w {*}$p
    }
    set height [winfo height $w.hurricane]
    set min [expr {$::main::data(tone)}]
    set range [expr {$::main::data(tone-range)}]
    set dx [expr {double($range)/$height}]
    for {set i 0} {$i < $height} {incr i} {
	set x [expr {$min+$i*$dx}]
	set y [expr {-100+rand()*-20}]
	lappend xy $x $y
    }
    ::main::play-panel-update $w $xy
    after $::main::data(play-panel-update-simulate-delay) [list ::main::play-panel-update-simulate $w]
}

proc ::main::play-panel {w} {
    ttk::frame $w
    lappend ::main::data(on-exit) {rename pileup {}} {rename noise {}}
    set minf [expr {$::main::data(tone)-5}]
    set midf [expr {$::main::data(tone)+$::main::data(tone-range)*0.5}]
    set maxf [expr {$::main::data(tone)+$::main::data(tone-range)}]
    grid [hurricane $w.hurricane -min-f $minf -max-f $maxf -pal 5] -row 0 -column 0 -sticky nsew
    grid [ttk::frame $w.m] -row 1 -column 0
    grid rowconfigure $w 0 -weight 100
    grid columnconfigure $w 0 -weight 100
    pack [ttk::button $w.m.start -text start -command ::main::start -state normal] -side left
    pack [ttk::button $w.m.pause -text pause -command ::main::pause -state disabled] -side left
    pack [ttk::button $w.m.stop -text stop -command ::main::stop -state disabled] -side left
    # capturing -size sample_rate/1 would yield 1 Hz per bin,
    # -size sample_rate/10, 10Hz per bin, and so on
    # ::capture::spectrum $w -period 50 -size [sdrkit::jack sample-rate] -client ::main::play-panel-update -connect pileup
    bind . <Configure> [list ::main::play-panel-window-configure $w %W %w %h]
    bind . <Destroy> [list ::main::play-panel-window-destroy $w %W]
    #after 100 [list ::capture::start $w]
    after 100 [list ::main::play-panel-update-simulate $w]
    return $w
}

proc ::main::game-panel {w} {
    ttk::frame $w

    # menu buttons
    set row 0
    foreach {name text unit impl update} $::main::data(game-menues) {
	grid [ttk::label $w.label-$name -text $text -anchor e] -row $row -column 0 -sticky e
	set type [lindex $impl 0]
	switch $type {
	    scale {
		foreach {type from to} $impl break
		grid [ttk::scale $w.scale-$name -from $from -to $to -variable ::main::data($name) -command $update] -row $row -column 1
		grid [ttk::label $w.value-$name -textvariable ::main::data($name) -width 6] -row $row -column 2
		grid [ttk::label $w.unit-$name -text $unit -anchor w] -row $row -column 3 -sticky w
	    }
	    menu {
		grid [ttk::menubutton $w.menu-$name -textvariable ::main::data($name) -menu $w.menu-$name.m] -row $row -column 1 -sticky ew
		grid [ttk::label $w.unit-$name -text $unit -anchor w] -row $row -column 2 -sticky w
		menu $w.menu-$name.m -tearoff no
		foreach item [lrange $impl 1 end] {
		    if {$item eq {-}} {
			$w.menu-$name.m add separator
		    } else {
			$w.menu-$name.m add radiobutton -label $item -variable ::main::data($name) -value $item
		    }
		}
	    }
	}
	incr row
    }
    return $w
}

proc ::main::keyer-panel-listen {input} {
    set rcvd [$input gets]
    if {[string length $rcvd]} {
	append ::main::data(keyer-panel-rcvd) $rcvd
    }
    after 200 [list ::main::keyer-panel-listen $input]
}

proc ::main::keyer-panel {w} {
    set opts {
	ascii 0
	debounce 1
	iambic 1
	ptt 1

	debounce-verbose 0
	debounce-chan 1
	debounce-note 0
	debounce-period 0.0002
	debounce-steps 10

	iambic-verbose 0
	iambic-chan 1
	iambic-note 0
	iambic-wpm 15
	iambic-word 50
	iambic-dah 3
	iambic-ies 1
	iambic-ils 3
	iambic-iws 7
	iambic-mode A
	iambic-alsp 0
	iambic-awsp 0
	iambic-swap 0
	
	iambic_tone-verbose 0
	iambic_tone-freq 750
	iambic_tone-gain -30
	iambic_tone-rise 5
	iambic_tone-fall 5

	ptt-verbose 0
	ptt-chan 1
	ptt-note 0
	ptt-delay 0.0
	ptt-hang 1.0
    }
    keyer::debounce debounce
    keyer::iambic iambic
    keyer::tone iambic_tone
    keyer::detime iambic_detime
    keyer::ptt ptt
    lappend ::main::data(on-exit) {rename debounce {}} {rename iambic {}} {rename iambic_tone {}} {rename iambic_detime {}} {rename ptt {}}
    sdrkit::jack connect system:midi_capture_1 debounce:midi_in
    sdrkit::jack connect debounce:midi_out iambic:midi_in
    sdrkit::jack connect iambic:midi_out ptt:midi_in
    sdrkit::jack connect ptt:midi_out iambic_tone:midi_in
    sdrkit::jack connect iambic:midi_out iambic_detime:midi_in
    sdrkit::jack connect iambic_tone:out_i system:playback_1
    sdrkit::jack connect iambic_tone:out_q system:playback_2
    
    sdrkit::jack connect ptt:midi_out pileup:midi_in; # ptt mute

    after 1000 [list ::main::keyer-panel-listen iambic_detime]
    return [keyer-control $w {} {} iambic iambic_tone ptt debounce $opts]
}

proc ::main::main {argv} {
    # process options
    foreach {option value} $argv {
	switch -- $option {
	    --voices { set ::main::data(voices) $value }
	    --wpm { set ::main::data(wpm) $value }
	    --mode { set ::main::data(mode) $value }
	}
    }
    
    # persistent jack modules
    sdrkit::noise noise -gain $::main::data(noise)
    keyer::ptt-mute pileup -gain $::main::data(output-gain)
    keyer::ascii heckler
    sdrkit::jack connect noise:out_i pileup:in_i
    sdrkit::jack connect noise:out_q pileup:in_q
    sdrkit::jack connect pileup:out_i system:playback_1
    sdrkit::jack connect pileup:out_q system:playback_2
    sdrkit::jack connect heckler:out_i system:playback_1
    sdrkit::jack connect heckler:out_q system:playback_2

    # basic layout
    grid [ttk::frame .m] -row 0 -column 0 -sticky ew
    grid [ttk::notebook .pileup] -row 1 -column 0 -sticky nsew
    .pileup add [::main::play-panel .play] -text {Play}
    .pileup add [::main::game-panel .game] -text {Game Config}
    .pileup add [::main::keyer-panel .keyer] -text {Keyer Config}
    .pileup add [::main::about-panel .about] -text {About}
    .pileup add [::main::sent-panel .sent] -text {Sent Text}
    .pileup add [::main::rcvd-panel .rcvd] -text {Rcvd Text}
    
    # extra bindings
    bind . <Destroy> [list ::main::close-window . %W]
}

::main::main $argv