#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

###
### part of the original readme file
###

# pileup - CW pileup program for Linux
# 	
# This program is based on sccw - Soundcard CW for Linux by Steven J. Merrifield
# VK3ESM sjm@ee.latrobe.edu.au http://livewire.ee.latrobe.edu.au. I have modified
# its use from a morse code tutor into a pileup program using multiple SoundBlaster
# voices.
# 
# -----------------------------------------------------------------------------
# 
# "Pileup" is a morse code program which generates callsigns using
# a specified number of the SoundBlaster's voices. This simulates the sound of
# a CW pileup. The greater the number of voices the more difficult the program is.
# 
# The idea is based on the tapes used at Amateur Radio Conventions to test 
# people's CW skills. However it is more random and can be made more difficult!
# 
# The callsigns sent are those worked by M6A in the 1996 CQ WW CW contest to
# add some realism.
# [ ... ]
# ---------------------------------------------------------------------------
# 
# Richard Everitt G4ZFE
# richard@babbage.demon.co.uk
# http://www.babbage.demon.co.uk
# 

###
### adaptation to keyer by Roger E Critchlow Jr, AD5DZ
### rec@elf.org
### http://elf.org
###
### notes on keyer adaptation
### 1) there is no fixed maximum number of voices, but Jack gives up around?
### 2) don't type your answers, key them back
###

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

package require Tk

package require keyer::ascii
package require keyer::detime
package require keyer::iambic
package require keyer::tone
package require keyer::ptt
package require keyer::ptt-mute
package require keyer::debounce
package require sdrkit::jack
package require sdrkit::gain
package require sdrkit::noise

package require keyer-control
package require hurricane
package require capture
package require morse::morse

#
# default options
#
namespace eval ::main {
    array set data {
	state 0

	game-menues {
	    mode mode {} {menu {callsigns} {7 dit words} {9 dit words} {11 dit words} {13 dit words} {15 dit words}
		{17 dit words} {19 dit words} {21 dit words} {23 dit words} {25 dit words} } {}
	    voices {N voices} {} {menu 1 2 3 4 5 6 7 8 9 10 15 20 25 30 35 40} {}
	    n-items {N items} {} {menu 10 50 100 500 1000 5000 10000 50000} {}
	    wpm {base speed} words/minute {scale 5 60} {}
	    wpm-range {speed range} words/minute {scale 0 20} {}
	    tone-range {tone range} Hz {scale 0 300} {}
	    gain {base gain} dB {scale 0 -160} {}
	    gain-range {gain range} dB {scale 160 -160} {}
	    noise {noise level} dB {scale 0 -160} {noise configure -level}
	    output-gain {output gain} dB {scale 0 -160} {pileup configure -gain}
	}

	mode {7 dit words}
	voices 1
	n-items 10
	wpm 18
	wpm-range 0
	tone 700
	tone-range 300
	gain -10
	gain-range -10
	noise -30
	output-gain -30

	number_session 0
	sent {}
	max_speed 0

	last-echo {}
	play-panel-update-simulate-delay 50
	play-codes-to-draw {}
	play-codes-to-undraw {}
	drawn-items {}
	unmatched {}
	ptt 0
    }
}

proc ::main::heard_clear {} {
    set ::main::data(sent) {}
    set ::main::data(unmatched) {}
    .sent.sent delete 0.0 end
}

proc ::main::heard_callsign {call code} {
    lappend ::main::data(sent) [list $call $code]
    lappend ::main::data(unmatched) $code
    .sent.sent insert end "$call $code\n"
    .sent.sent see end
}
    
proc ::main::translate {dict call} {
    return [text-to-morse $dict $call]
}
    
proc ::main::draw_callsign {send} {
    lappend ::main::data(play-codes-to-draw) $send
}

proc ::main::undraw_callsign {send} {
    lappend ::main::data(play-codes-to-undraw) $send
}
    
proc ::main::hear_callsign {send} {
    if {$::main::data(ptt)} {
	foreach {send call voice speed tone gain code continuation} $::main::data(send-$send) break
	ascii$voice abort
	::main::undraw_callsign $send
	::main::resend_callsign $send
    } else {
	foreach {send call voice speed tone gain code continuation} $::main::data(send-$send) break
	if {[ascii$voice pending]} {
	    set ::main::data(after-$voice) [after 100 [list ::main::hear_callsign $send]]
	} else {
	    heard_callsign $call $code
	    set ::main::data(after-$voice) [eval $continuation]
	}
    }
}

proc ::main::send_callsign {send} {
    if {$::main::data(ptt)} {
	::main::resend_callsign $send
    } else {
	foreach {send call voice speed tone gain code continuation} $::main::data(send-$send) break
	set ::main::data(max_speed) [expr {max($::main::data(max_speed), $speed)}]
	tone$voice configure -freq $tone -gain $gain
	ascii$voice configure -wpm $speed
	ascii$voice puts $call
	draw_callsign $send
	hear_callsign $send
    }
}

proc ::main::resend_callsign {send} {
    if {$::main::data(ptt)} {
	after 100 [list ::main::resend_callsign $send]
    } else {
	after [expr {2000+int(rand () * 1000)}] [list ::main::send_callsign $send]
    }
}

proc ::main::listen_clear {} {
    array set ::main::data {listen-last-echo {} listen-last-echo-repeat 0 listen-matched {} listen-echoes-received {} listen-rcvd {}}
    .rcvd.rcvd delete 0.0 end
}

proc ::main::listen_score_echo {item} {
    set item [string trim $item]
    if {$item eq {}} return
    lappend ::main::data(listen-rcvd) $item
    set i [lsearch $::main::data(unmatched) $item]
    if {$i >= 0} {
	set ::main::data(unmatched) [lreplace $::main::data(unmatched) $i $i]
	lappend ::main::data(matched) $item
	.rcvd.rcvd insert end "$item [morse-to-text [heckler cget -dict] $item] correct\n"
	::main::play-score correct [morse-dit-length $item]
    } else {
	.rcvd.rcvd insert end "$item [morse-to-text [heckler cget -dict] $item] wrong\n"
	::main::play-score wrong [morse-dit-length $item]
    }
}

proc ::main::listen_for_echoes {echo detime} {
    set new [$detime gets]
    append ::main::data(listen-echoes-received) $new
    append echo $new
    if {$echo ne {}} {
	if {$echo ne $::main::data(listen-last-echo)} {
	    puts "listen_for_echoes heard {$echo} this time"
	    set ::main::data(listen-last-echo-repeat) 0
	    set ::main::data(listen-last-echo) $echo
	} else {
	    incr ::main::data(listen-last-echo-repeat)
	}
	set echoes [split $echo \n]
	puts "[llength $echoes] echoes to match, [llength $::main::data(unmatched)] unmatched, $::main::data(listen-last-echo-repeat) repeats"
	foreach item [lrange $echoes 0 end-1] {
	    ::main::listen_score_echo $item
	}
	set echo [lindex $echoes end]
	if {$::main::data(active-voices) == 0 && $::main::data(listen-last-echo-repeat) > 10} {
	    ::main::listen_score_echo $echo
	    foreach item $::main::data(unmatched) {
		::main::play-score missed [morse-dit-length $item]
	    }
	    set echo {}
	}
    }
    after 100 [list ::main::listen_for_echoes $echo $detime]
}

proc ::main::sound_voice {voice} {
    if {$::main::data(number_session) > 0} {
	# reduce the count to be sent
	incr ::main::data(number_session) -1
	# get the callsign to be sent
	set call [lindex $::main::data(items) 0]; set ::main::data(items) [lrange $::main::data(items) 1 end]
	# choose a random speed
	set speed [expr {rand() * $::main::data(wpm-range) + $::main::data(wpm)}]
	# choose a random tone
	set tone [expr {(rand() * $::main::data(tone-range)) - $::main::data(tone-range)/2 + $::main::data(tone)}]
	# choose a random gain
	set gain [expr {(rand() * $::main::data(gain-range)) + $::main::data(gain)}]
	# choose the timeout between the end of this call
	# and the start of the next call on this voice
	set timeout [expr {2000+int(rand () * 1000)}]
	# send the callsign and wait for it to finish
	# senders need to back off if the operator is replying
	# senders need to abort and retry if the operator is replying
	set send [incr ::main::data(sent-count)]
	set ::main::data(send-$send) [list $send $call $voice $speed $tone $gain [translate [ascii$voice cget -dict] $call] [list after $timeout [list ::main::sound_voice $voice]]]
	send_callsign $send
    } else {
	stop_voice $voice
    }
}

proc ::main::start_voice {voice} {
    # mark us as active
    incr ::main::data(active-voices)
    set ::main::data(voice-$voice) {}
    # start keyer
    keyer::ascii ascii$voice
    keyer::tone tone$voice
    # keyer::detime detime$voice
    # connect
    sdrkit::jack connect ascii$voice:midi_out tone$voice:midi_in
    sdrkit::jack connect tone$voice:out_i pileup:in_i
    sdrkit::jack connect tone$voice:out_q pileup:in_q
    # sdrkit::jack connect ascii$voice:midi_out detime$voice:midi_in
    # start loop until all sent
    after [expr {int(rand () * 3000)}] [list ::main::sound_voice $voice]
}

proc ::main::stop_voice {voice} {
    if {[info exists ::main::data(voice-$voice)]} {
	unset ::main::data(voice-$voice)
	incr ::main::data(active-voices) -1
	catch {after cancel $::main::data(after-$voice)}
	rename ascii$voice {}
	rename tone$voice {}
	# rename detime$voice {}
    }
}

proc ::main::check_if_finished {} {
    if {$::main::data(number_session) > 0 || $::main::data(active-voices) > 0} {
	after 100 ::main::check_if_finished
    } else {
	::main::play-stop
    }
}

proc ::main::choose_items {n list} {
    set choices {}
    set length [llength $list]
    while {[incr n -1] >= 0} {
	lappend choices [lindex $list [expr {int(rand()*$length)}]]
    }
    return $choices
}

####
#### play panel animation
####
proc ::main::play-panel-window-configure {w cw wd ht} {
    if {$w eq $cw} {
	# puts "configure $w $cw $wd $ht"
    }
}

proc ::main::play-panel-window-destroy {w dw} {
    # puts "destroy $w ..."
}

##
## this is an {x y x y ...} list of
## frequency vs magnitude in dB full scale
##
proc ::main::play-panel-update {w xy} {
    ::hurricane::update $w.hurricane $xy
}

proc ::main::play-panel-setup-drawing {w send call speed tone gain code} {
    ## pixels/second at play-panel-update-simulate update rate
    set pps [expr {1000/$::main::data(play-panel-update-simulate-delay)}]
    ## pixels/window width and height in waterfall
    set wd [winfo width $w.hurricane]
    set ht [winfo height $w.hurricane]
    ## dits/second at call sending speed words/minute*dits/word*minute/second
    set dps [expr {$speed*50.0*1/60.0}]
    ## pixels/dit
    set ppd [expr {$pps/$dps}]
    ## y for tone
    set y [expr {(($tone-$::main::data(tone)+200.0)/400.0)*$ht}]
    ## pick a color
    set color white;		# some function of gain
    ## draw a series of lines
    set c $code
    set x $wd
    ## remember where they are
    set items {}
    while {[string length $c] > 0} {
	switch -exact -- [string index $c 0] {
	    . {
		# draw a dit
		lappend items [$w.hurricane create line $x $y [expr {$x+$ppd}] $y -fill $color -tags send-$send]
		# skip to the end of the space after the dit
		set x [expr {$x+$ppd+$ppd}]
	    }
	    - {
		# draw a dah
		lappend items [$w.hurricane create line $x $y [expr {$x+3*$ppd}] $y -fill $color -tags send-$send]
		# skip to the end of the space after the dit
		set x [expr {$x+3*$ppd+$ppd}]
	    }
	    { } {
		# skip to the end of the space after the character
		set x [expr {$x+3*$ppd-$ppd}]
	    }
	}
	set c [string range $c 1 end]
    }
    lappend ::main::data(drawn-items) $send
}

proc ::main::play-panel-update-simulate {w} {
    set sendings $::main::data(play-codes-to-draw)
    set ::main::data(play-codes-to-draw) {}
    foreach send $sendings {
	foreach {send call voice speed tone gain code continuation} $::main::data(send-$send) break
	play-panel-setup-drawing $w $send $call $speed $tone $gain $code
    }
    set height [winfo height $w.hurricane]
    set min [expr {$::main::data(tone)}]
    set range [expr {$::main::data(tone-range)}]
    set dx [expr {double($range)/$height}]
    for {set i 0} {$i < $height} {incr i} {
	set x [expr {$min+$i*$dx}]
	set y [expr {-100+rand()*-20}]
	lappend xy $x $y
    }
    ::main::play-panel-update $w $xy
    set unsendings $::main::data(play-codes-to-undraw)
    set ::main::data(play-codes-to-undraw) {}
    foreach unsend $unsendings {
	$w.hurricane delete send-$unsend
    }
    after $::main::data(play-panel-update-simulate-delay) [list ::main::play-panel-update-simulate $w]
}

proc ::main::play-score {category points} {
    incr ::main::data(play-dits-$category) $points
    set y1 [winfo height .play.score]
    set y0 [expr {$y1-$::main::data(play-dits-$category)}]
    switch $category {
	wrong { set x0 0; set x1 10 }
	correct { set x0 10; set x1 20 }
	missed { set x0 20; set x1 30 }
	default { error "unknown score category $category" }
    }
    .play.score coords $category $x0 $y0 $x1 $y1
}

####
#### user interface actions
####

##
## close window handler
##
proc ::main::close-window {w ew} {
    if {$w eq $ew} {
	foreach x $::main::data(on-exit) {
	    catch $x
	}
	::main::stop
    }
}

##
## ptt signal listener
##
proc ::main::ptt-signal-listener {mtap chan note} {
    foreach item [$mtap gets] {
	foreach {frame event} $item break
	binary scan $event c* bytes
	foreach {ecmd enote vel} $bytes break
	if {($ecmd&0xff) == (0x90+($chan-1)) && $enote == $note+1} {
	    set ::main::data(ptt)  1
	} elseif {($ecmd&0xff) == (0x80+($chan-1)) && $enote == $note+1} {
	    set ::main::data(ptt)  0
	}
    }
    after 100 [list ::main::ptt-signal-listener $mtap $chan $note]
}

##
## game play panel button actions
##
proc ::main::play-start {} {
    # change button state
    .play.m.start configure -state disabled
    #.play.m.pause configure -state normal
    .play.m.stop  configure -state normal
    set ::main::data(state) 1
    # choose mode
    switch $::main::data(mode) {
	callsigns {
	    set ::main::data(number_session) $::main::data(n-items)
	    set ::main::data(items) [choose_items $::main::data(number_session) [morse-pileup-callsigns]]
	}
	default {
	    set ::main::data(number_session) $::main::data(n-items)
	    set dits [lindex $::main::data(mode) 0]
	    set words [morse-words-of-length [heckler cget -dict] $dits]
	    set ::main::data(items) [choose_items $::main::data(number_session) $words]
	}
    }
    # clear sent
    ::main::heard_clear
    # clear received
    ::main::listen_clear
    # clear score
    array set ::main::data {play-dits-correct 0 play-dits-wrong 0 play-dits-missed 0}
    # clear score bar graph
    catch {.play.score delete all}
    set ht [winfo height .play.score]
    .play.score create rectangle 0 $ht 10 $ht -fill red -tag wrong
    .play.score create rectangle 10 $ht 20 $ht -fill green -tag correct
    .play.score create rectangle 20 $ht 30 $ht -fill blue -tag missed
    # start voices
    set ::main::data(active-voices) 0
    for {set voice 0} {$voice < $::main::data(voices)} {incr voice} {
	start_voice $voice
    }
    # listen for echoes
    # ::main::listen_for_echoes_to_sent {}
    # wait for done
    ::main::check_if_finished
}

proc ::main::play-pause {} {
    # change button state
    .play.m.start configure -state normal
    #.play.m.pause configure -state disabled
    .play.m.stop  configure -state normal
    set ::main::data(state) 2
}

proc ::main::play-stop {} {
    # change button state
    .play.m.start configure -state normal
    #.play.m.pause configure -state disabled
    .play.m.stop  configure -state disabled
    set ::main::data(state) 0
    for {set voice 0} {$voice < $::main::data(voices)} {incr voice} {
	stop_voice $voice
    }
}

####
#### user interface panels
####

##
## about panel
##
proc ::main::about-panel {w} {
    ttk::frame $w
    pack [text $w.t] -fill both -expand true
    $w.t insert end {
 Welcome to Pileup!  This is an update of:

     pileup - CW pileup program for Linux by Richard Everitt G4ZFE
 	
     This program is based on sccw - Soundcard CW for Linux by Steven J.
     Merrifield VK3ESM sjm@ee.latrobe.edu.au http://livewire.ee.latrobe.edu.au.
     I have modified its use from a morse code tutor into a pileup program
     using multiple SoundBlaster voices.

This update involves replacing the SoundBlaster with the Jack Audio Connection
Kit and using Tcl/Tk wrappers to assemble and control the signal processing
graph.  The number of simultaneous voices is limited, but not very limited.  I
have had 25 different voices running on my laptop and I was sufficiently
overwhelmed that I didn't try larger numbers.

Oh, your typing skills are of no use here, you need to key in the answers.
The program includes a MIDI based iambic keyer.  The hardware interface to
connect your paddle or straight key to this program is very simple and
affordable.	
 
The program runs in callsign mode, where the original pileup set of callsigns
is sent, or in N dit word mode, where the combinations of characters with less
than N dit clocks is sent.  In either case, your task is to copy and echo the
callsigns or words back.  You can adjust the speed, the tone range, the gain
range, and the level of the noise floor.

The idea is that you should stop trying to translate morse into characters at
all for a while, just practice hearing the patterns and remembering them long
enough to echo them back.
} 
    return $w
}

##
## texts sent panel
##
proc ::main::sent-panel {w} {
    ttk::frame $w
    grid [text $w.sent -yscrollcommand [list $w.vsent set]] -row 0 -column 0 -sticky nsew
    grid [ttk::scrollbar $w.vsent -orient vertical -command [list $w.sent yview]] -row 0 -column 1 -sticky ns
    grid columnconfigure $w 0 -weight 100
    grid rowconfigure $w 0 -weight 100
    return $w
}

##
## texts received panel
##
proc ::main::rcvd-panel {w} {
    ttk::frame $w
    grid [text $w.rcvd -yscrollcommand [list $w.vrcvd set]] -row 0 -column 0 -sticky nsew
    grid [ttk::scrollbar $w.vrcvd -orient vertical -command [list $w.rcvd yview]] -row 0 -column 1 -sticky ns
    grid columnconfigure $w 0 -weight 100
    grid rowconfigure $w 0 -weight 100
    return $w
}

##
## game play panel
##
proc ::main::play-panel {w} {
    ttk::frame $w
    lappend ::main::data(on-exit) {rename pileup {}} {rename noise {}}
    set minf [expr {$::main::data(tone)-5}]
    set midf [expr {$::main::data(tone)+$::main::data(tone-range)*0.5}]
    set maxf [expr {$::main::data(tone)+$::main::data(tone-range)}]
    grid [canvas $w.score -width 30] -row 0 -column 0 -sticky ns
    grid [hurricane $w.hurricane -min-f $minf -max-f $maxf -pal 5] -row 0 -column 1 -sticky nsew
    grid [ttk::frame $w.m] -row 1 -column 0 -columnspan 2
    grid rowconfigure $w 0 -weight 100
    grid columnconfigure $w 1 -weight 100
    pack [ttk::button $w.m.start -text start -command ::main::play-start -state normal] -side left
    pack [ttk::button $w.m.pause -text pause -command ::main::play-pause -state disabled] -side left
    pack [ttk::button $w.m.stop -text stop -command ::main::play-stop -state disabled] -side left
    array set ::main::data {play-dits-correct 0 play-dits-wrong 0 play-dits-missed 0}
    pack [ttk::label $w.m.correct-l -text Correct:] -side left
    pack [ttk::label $w.m.correct -textvar ::main::data(play-dits-correct) -width 4] -side left
    pack [ttk::label $w.m.wrong-l -text Wrong:] -side left
    pack [ttk::label $w.m.wrong -textvar ::main::data(play-dits-wrong) -width 4] -side left
    pack [ttk::label $w.m.missed-l -text Missed:] -side left
    pack [ttk::label $w.m.missed -textvar ::main::data(play-dits-missed) -width 4] -side left
    bind . <Configure> [list ::main::play-panel-window-configure $w %W %w %h]
    bind . <Destroy> [list ::main::play-panel-window-destroy $w %W]
    ## first part concerning a real waterfall capture
    # capturing -size sample_rate/1 would yield 1 Hz per bin,
    # -size sample_rate/10, 10Hz per bin, and so on
    # ::capture::spectrum $w -period 50 -size [sdrkit::jack sample-rate] -client ::main::play-panel-update -connect pileup
    #after 100 [list ::capture::start $w]
    ## second part concerning a simulated waterfall capture
    after 100 [list ::main::play-panel-update-simulate $w]
    return $w
}

##
## game configuration panel
##
proc ::main::game-panel {w} {
    ttk::frame $w

    # menu buttons
    set row 0
    foreach {name text unit impl update} $::main::data(game-menues) {
	grid [ttk::label $w.label-$name -text $text -anchor e] -row $row -column 0 -sticky e
	set type [lindex $impl 0]
	switch $type {
	    scale {
		foreach {type from to} $impl break
		grid [ttk::scale $w.scale-$name -from $from -to $to -variable ::main::data($name) -command $update] -row $row -column 1
		grid [ttk::label $w.value-$name -textvariable ::main::data($name) -width 6] -row $row -column 2
		grid [ttk::label $w.unit-$name -text $unit -anchor w] -row $row -column 3 -sticky w
	    }
	    menu {
		grid [ttk::menubutton $w.menu-$name -textvariable ::main::data($name) -menu $w.menu-$name.m] -row $row -column 1 -sticky ew
		grid [ttk::label $w.unit-$name -text $unit -anchor w] -row $row -column 2 -sticky w
		menu $w.menu-$name.m -tearoff no
		foreach item [lrange $impl 1 end] {
		    if {$item eq {-}} {
			$w.menu-$name.m add separator
		    } else {
			$w.menu-$name.m add radiobutton -label $item -variable ::main::data($name) -value $item
		    }
		}
	    }
	}
	incr row
    }
    return $w
}

##
## keyer configuration panel
##
proc ::main::keyer-panel {w} {
    set opts {
	ascii 0
	debounce 1
	iambic 1
	ptt 1

	layout 1

	client-ascii {}
	client-ascii_tone {}
	client-iambic iambic
	client-iambic_tone iambic_tone
	client-ptt ptt
	client-debounce debounce

	debounce-verbose 0
	debounce-chan 1
	debounce-note 0
	debounce-period 0.0002
	debounce-steps 6

	iambic-verbose 0
	iambic-chan 1
	iambic-note 0
	iambic-wpm 15
	iambic-word 50
	iambic-dah 3
	iambic-ies 1
	iambic-ils 3
	iambic-iws 7
	iambic-mode A
	iambic-alsp 0
	iambic-awsp 0
	iambic-swap 0
	
	iambic_tone-verbose 0
	iambic_tone-freq 750
	iambic_tone-gain -30
	iambic_tone-rise 5
	iambic_tone-fall 5

	ptt-verbose 0
	ptt-chan 1
	ptt-note 0
	ptt-delay 0.0
	ptt-hang 1.0
    }
    return [keyer-control $w $opts]
}

##
## process options, build interface, start background listeners
##
proc ::main::main {argv} {
    # process options
    foreach {option value} $argv {
	switch -- $option {
	    --voices { set ::main::data(voices) $value }
	    --wpm { set ::main::data(wpm) $value }
	    --mode { set ::main::data(mode) $value }
	}
    }
    
    # persistent jack/sdrkit modules
    sdrkit::jack-client jack;					# jack of all trades
    sdrkit::noise noise -level $::main::data(noise);		# noise floor
    sdrkit::mtap ptt_mtap;					# midi tap to receive ptt
    keyer::ptt-mute pileup -gain $::main::data(output-gain);	# mute receiver on transmit
    keyer::ascii heckler;					# will be commenting on your progress
    keyer::debounce debounce;					# key debouncer
    keyer::iambic iambic;					# iambic keyer
    keyer::tone iambic_tone;					# iambic tone
    keyer::detime iambic_detime;				# iambic decoder to dits and dahs
    keyer::ptt ptt;						# iambic ptt switch

    # non-persistent are the ascii keyers and tone generators which generate the pileup
    # they get built when the pileup starts and deleted as they finish their work

    # persistent jack connections
    jack connect noise:out_i pileup:in_i;			# noise to both channels of pileup
    jack connect noise:out_q pileup:in_q
    jack connect pileup:out_i system:playback_1;		# pileup to system playback
    jack connect pileup:out_q system:playback_2
    jack connect heckler:out_i system:playback_1;		# heckler to system playback
    jack connect heckler:out_q system:playback_2
    jack connect system:midi_capture_1 debounce:midi_in;	# system midi capture to debouncer
    jack connect debounce:midi_out iambic:midi_in;		# debouncer to keyer
    jack connect iambic:midi_out ptt:midi_in;			# keyer to ptt splitter
    jack connect ptt:midi_out iambic_tone:midi_in;		# splitter to tone generator
    jack connect ptt:midi_out iambic_detime:midi_in;		# splitter to detimer
    jack connect iambic_tone:out_i system:playback_1;		# tone to system playback
    jack connect iambic_tone:out_q system:playback_2
    jack connect ptt:midi_out pileup:midi_in;			# ptt mute line
    jack connect ptt:midi_out ptt_mtap:midi_in;			# ptt feedback line

    # cleanup - the after echoes are more pleasing if we shut down rather than just exiting.
    foreach module {jack noise ptt_mtap pileup heckler debounce iambic iambic_tone iambic_detime ptt} {
	lappend ::main::data(on-exit) [list rename $module {}]
    }

    # basic layout
    grid [ttk::frame .m] -row 0 -column 0 -sticky ew
    grid [ttk::notebook .pileup] -row 1 -column 0 -sticky nsew
    grid columnconfigure . 0 -weight 100
    grid rowconfigure . 1 -weight 100
    .pileup add [::main::play-panel .play] -text {Play}
    .pileup add [::main::game-panel .game] -text {Game Config}
    .pileup add [::main::keyer-panel .keyer] -text {Keyer Config}
    .pileup add [::main::about-panel .about] -text {About}
    .pileup add [::main::sent-panel .sent] -text {Sent Text}
    .pileup add [::main::rcvd-panel .rcvd] -text {Rcvd Text}
    
    # extra bindings
    bind . <Destroy> [list ::main::close-window . %W]

    # configure listener to keyer input
    after 100 [list ::main::listen_for_echoes {} iambic_detime]
    
    # configure listener to ptt signal, should have used capture
    ptt_mtap start
    after 100 [list ::main::ptt-signal-listener ptt_mtap [ptt cget -chan] [ptt cget -note]]
}

::main::main $argv