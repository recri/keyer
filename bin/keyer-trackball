#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

#
# a simple program to play with the blackberry trackball in the midi keyer
#
# we use a midi-tap connected to system:midi_capture_1 to listen to keyer
# events, and a midi-insert connected to system:midi_playback_1 to echo
# events back to the keyer.
# The paddle and button signals are marked by lighting up colored patches
# of window and to enable the leds on the keyer with the same color.
# Trackball motion controls a cross hair on another patch of window.
#
# the midi-insert is also looped back to the midi-tap so we can monitor
# the events sent to the keyer.
#
package require Tk

package require sdrtcl::midi-tap
package require sdrtcl::midi-insert
# package require keyer::debounce
package require sdrtcl::jack

array set data {
    track-x-origin 64 track-y-origin 64
    track-x-offset 0 track-y-offset 0
    red-state 0 red-after {} red-level 0 red-target 0 red-note 7
    green-state 0 green-after {} green-level 0 green-target 0 green-note 6
    blue-state 0 blue-after {} blue-level 0 blue-target 0 blue-note 8
    white-state 0 white-after {} white-level 0 white-target 0 white-note 5
}

proc midi-transmit {cmd note vel} { midi-out puts [binary format ccc $cmd $note $vel] }

#
# poll input and deliver to receiver
#
proc midi-poll {input receiver} {
    set events [$input get]
    if {$events ne {}} {
	$receiver $events
    }
    after 100 [list midi-poll $input $receiver]
}

#
# receive input from midi poll
#
proc midi-receiver {events} {
    foreach e $events {
	lassign $e frame event
	binary scan $event c* bytes
	switch [llength $bytes] {
	    3 {
		lassign $bytes cmd note vel
		set cmd [format %02x [expr {$cmd&0xff}]]
		switch -glob $cmd {
		    8* {	# note off
			switch $note {
			    0 { dit-off }
			    1 { dah-off }
			    2 { but-off }
			    3 { # track ball
			    }
			    4 { # track ball
			    }
			    5 - 6 - 7 - 8 {
				# led loop back
				.mon.n$note configure -bg black
			    }
			    default {
			    }
			}
		    }
		    9* {	# note on
			switch $note {
			    0 { dit-on }
			    1 { dah-on }
			    2 { but-on }
			    3 { # track ball
				set ::data(track-y-offset) [expr {$::data(track-y-offset)-[expr {$vel-64}]}]
				set y [expr {$::data(track-y-offset)+$::data(track-y-origin)}]
				.track coords horizontal 0 $y [winfo width .track] $y
			    }
			    4 { # track ball
				set ::data(track-x-offset) [expr {$::data(track-x-offset)+[expr {$vel-64}]}]
				set x [expr {$::data(track-x-offset)+$::data(track-x-origin)}]
				.track coords vertical $x 0 $x [winfo height .track]
			    }
			    5 - 6 - 7 - 8 {
				# led loop back
				set lev [expr {($vel*2)&255}]
				foreach pat [array names ::data *-note] {
				    if {$::data($pat) == $note} {
					switch $pat {
					    white-note { set color \#[format {%02x%02x%02x} $lev $lev $lev] }
					    red-note   { set color \#[format {%02x0000} $lev] }
					    green-note { set color \#[format {00%02x00} $lev] }
					    blue-note  { set color \#[format {0000%02x} $lev] }
					    default {
						error "$pat didn't match a switch case"
					    }
					}
					break
				    }
				}
				.mon.n$note configure -bg $color
			    }
			    default {
			    }
			}
		    }
		    default { puts "received $cmd $note $vel" }
		}
	    }
	    default { puts "received $bytes" }
	}
    }
}

proc dit-off {} { .dit configure -bg grey; led-off red }
proc dah-off {} { .dah configure -bg grey; led-off blue }
proc but-off {} { .but configure -bg grey; led-off white }
proc dit-on {} { .dit configure -bg red; led-on red }
proc dah-on {} { .dah configure -bg blue; led-on blue }
proc but-on {} { .but configure -bg white; led-on white }

proc led-run {note} {
    switch $::data($note-state) {
	0 { # falling
	    midi-transmit 0x90 $::data($note-note) $::data($note-level)
	    if {[incr ::data($note-level) -1] == $::data($note-target)} {
		set ::data($note-state) 2
	    }
	    set ::data($note-after) [after 10 [list led-run $note]]
	}
	1 { # rising
	    midi-transmit 0x90 $::data($note-note) $::data($note-level)
	    if {[incr ::data($note-level) 1] == $::data($note-target)} {
		set ::data($note-state) 3
	    }
	    set ::data($note-after) [after 10 [list led-run $note]]
	}
	2 { # settled low
	    midi-transmit 0x80 $::data($note-note) 0
	    set ::data($note-after) {}
	}
	3 { # settled high
	    set ::data($note-after) {}
	}
    }
}

proc led-start {note onoff} {
    if {$::data($note-state) != $onoff} {
	set ::data($note-state) $onoff
	if {$onoff} {
	    set ::data($note-target) 127
	} else {
	    set ::data($note-target) 0
	}
    }
    if {$::data($note-after) eq {}} {
	led-run $note
    }
}

proc led-on {note} { led-start $note 1 }
proc led-off {note} { led-start $note 0 }

proc green-led-off {} { led-off green; after 2000 green-led-on }
proc green-led-on {} { led-on green; after 2000 green-led-off }
proc green-led-pulse {} { green-led-on }

proc draw-lines {w wd ht} {
    set ::data(track-x-origin) [expr {$wd/2}]
    set ::data(track-y-origin) [expr {$ht/2}]
    set x [expr {$::data(track-x-origin)+$::data(track-x-offset)}]
    set y [expr {$::data(track-y-origin)+$::data(track-y-offset)}]
    $w coords vertical $x 0 $x $ht
    $w coords horizontal 0 $y $wd $y
}

#
# process options
#
proc main {argv} {
    grid [canvas .dit -width 43 -height 43] -row 0 -column 0 -sticky ew
    grid [canvas .but -width 43 -height 43] -row 0 -column 1 -sticky ew
    grid [canvas .dah -width 43 -height 43] -row 0 -column 2 -sticky ew
    grid [canvas .track -width 128 -height 128] -row 1 -column 0 -columnspan 3 -sticky nsew
    grid [ttk::frame .mon] -row 2 -column 0 -columnspan 3 -sticky ew
    grid [canvas .mon.n5 -width 32 -height 32] -row 0 -column 0
    grid [canvas .mon.n6 -width 32 -height 32] -row 0 -column 1
    grid [canvas .mon.n7 -width 32 -height 32] -row 0 -column 2
    grid [canvas .mon.n8 -width 32 -height 32] -row 0 -column 3
    grid columnconfigure . 0 -weight 100
    grid columnconfigure . 1 -weight 100
    grid columnconfigure . 2 -weight 100
    grid rowconfigure . 1 -weight 100
    .track create line 0 0 0 0 -tag vertical
    .track create line 0 0 0 0 -tag horizontal
    bind .track <Configure> [list draw-lines %W %w %h]
    sdrtcl::midi-tap midi-in
    sdrtcl::midi-insert midi-out
    # keyer::debounce debounce
    # sdrtcl::jack connect system:midi_capture_1 debounce:midi_in
    # sdrtcl::jack connect debounce:midi_out midi-in:midi_in
    sdrtcl::jack connect system:midi_capture_1 midi-in:midi_in
    sdrtcl::jack connect midi-out:midi_out system:midi_playback_1
    sdrtcl::jack connect midi-out:midi_out midi-in:midi_in
    midi-in start
    midi-poll midi-in midi-receiver
    green-led-pulse
}

main $argv
