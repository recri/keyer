#!/usr/bin/wish8.6
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# Copyright (C) 2018 by Roger E Critchlow Jr, Charlestown, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

# this is the mega-keyer script
# start arbitrary collections of sdrtcl components
# wire up their options into a dialbook
# hide, merge, or fuse options
# save the result as a preset command for later access
#

#
# use the script location to find the rest of the libraries
#
set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
set dirname [file dirname $script]

#
# append the ../lib directory to the Tcl search path
#
lappend auto_path [file join $dirname .. lib]

package require snit
namespace eval ::sdrtk {}
package require sdrtk::dialbook

#
# utilities
#
proc read-file {file} {
    set fp [open $file r]
    set data [read $fp]
    close $fp
    return $data
}
proc write-file {file data} {
    set fp [open $file w]
    puts -nonewline $fp $data
    close $fp
}

#
# value enumerations for a few options
#

# these are filter/fft windowing functions
package require sdrtcl::window
proc get-window-types {} {
    catch { sdrtcl::window foo 512 } error
    regexp {^unknown window type, should be one of (.*)$} $error all error
    regsub -all {, (or )?} $error { } error
    set error [lsort $error]
    set i [lsearch $error {none}]
    if {$i >= 0} {
	set error [concat none [lreplace $error $i $i]]
    }
    return $error
}

# these are morse code dictionaries
package require morse::dicts
proc get-morse-dicts {} { 
    return [concat {builtin} [morse-dicts]]
}

# these are the iambic keyers
proc get-iambic-keyers {} { 
    return [lmap x [lsearch -glob -all -inline [::koptions packages] *keyer-iambic-*] {lindex [split $x -] end}]
}

#
# component/option manager
#
package require snit
namespace eval ::keyer {}

snit::type keyer::options {
    variable options -array {}

    variable data -array {
	pkgs {}
	comps {}
	opts {}
	handler {}
	busy {}
	favor {}
	merge {}
	hide {}
	volatile {}
    }

    constructor {args} {
	# $self configurelist $args

	set data(opts) [dict create]
	set data(busy) [dict create]
	set data(comps) [dict create]
	set data(pkgs) [dict create]

	$self find-packages
	$self process-volatile
    }

    # the part dealing with options

    method get-opts {} { return [dict keys $data(opts)] }

    method is-option {opt} { return [dict exists $data(opts) $opt] }
    method exists {opt key} { return [dict exists $data(opts) $opt $key] }
    method get {opt key} { return [dict get $data(opts) $opt $key] }
    method set {opt key val} { dict set data(opts) $opt $key $val }

    method is-described {opt} { return [$self exists $opt described] }
    method is-processed {opt} { return [$self exists $opt processed] }
    method is-ronly {opt} { return [$self get $opt ronly] }
    method is-conly {opt} { return [$self get $opt conly] }
    method is-favor {opt} { return [$self get $opt favor] }
    method is-hide {opt} { return [$self get $opt hide] }
    method is-volatile {opt} { return [$self get $opt volatile] }

    method get-default {opt} { return [$self get $opt cdefault] }
    method get-value {opt} { return [$self get $opt cvalue] }
    method set-value {opt val} { return [$self set $opt cvalue $val] }
    method is-default {opt} {
	if {[$self is-readonly $opt]} { return 1 }
	if {[$self get-default $opt] eq $options($opt)} { return 1 }
	return 0
    }

    method component-opts {opt} {
	set d [dict get $data(opts) $opt]
	set w [dict get $d window]
	if {$w ne {}} { return [list $w [dict get $d opt]] }
	return [list [dict get $d name] [dict get $d opt]]
    }

    method add-favor {args} { lappend data(favor) {*}$args }
    method has-favor {} { return [expr {$data(favor) ne {}}] }
    method get-favor {} { return $data(favor) }

    method add-merge {args} { lappend data(merge) {*}$args }
    method has-merge {} { return [expr {$data(merge) ne {}}] }
    method get-merge {} { return $data(merge) }

    method add-hide {args} { lappend data(hide) {*}$args }
    method has-hide {} { return [expr {$data(hide) ne {}}] }
    method get-hide {} { return $data(hide) }

    method add-volatile {args} { lappend data(volatile) {*}$args }
    method has-volatile {} { return [expr {$data(volatile) ne {}}] }
    method get-volatile {} { return $data(volatile) }
    method process-volatile {} {
	foreach {opt call opt2 var} [$self get-volatile] {
	    set val [$call cget $opt2]
	    if {$val ne [set $var]} { set $var $val }
	}
	after 25 [mymethod process-volatile]
    }

    method describe {dict otype args} { 
	set opt [dict get $dict text]
	set options($opt) [dict get $dict cvalue]
	# puts "keyer-options describe options($opt) is $options($opt)"
	dict set dict type $otype
	dict set dict described 1
	dict set dict readout {}
	foreach {key val} $args {
	    if {[string index $key 0] eq {-}} {
		dict lappend dict readout $key $val
	    } else {
		dict set dict $key $val
	    }
	}
	dict set data(opts) $opt $dict
	if {[$self is-volatile $opt]} { $self add-volatile $opt [dict get $dict call] [dict get $dict opt] [myvar options($opt)] }
    }

    #
    # dial setting, most options are delegated to the dialbook
    # one dial for setting everything.  So this is where the
    # dialbook delegates everything to be set.
    #
    # there's a trickiness, the sdrtcl widgets that implement jack
    # dsp can be too busy to process options, so we may need to
    # wait until the previous setting has completed.  This is all
    # to avoiding expensive computations in the inner dsp loop, and
    # getting.
    #
    # then also we should be debouncing a lot of option setting to
    # avoid overwhelming thins.
    #
    # should wrap this into a snit type, ideally responisble for
    # constructing the dialbook pages and managing the options
    # list and aliases and so on.
    # 
    # okay, this should be the snit type for the top level component
    # and all the composite named options are actually options for
    # this component which it resolves into calls to subname suboption
    # it also handles:
    # 1) backpressure in the form of subname is-busy
    # 2) value debouncing
    # 3) option merging and chaining
    #
    # it also handles the options dictionary, options definitions, and options descriptions
    # 
    method configure {args} {
	set n [llength $args]
	switch $n {
	    0 {
		# full configure dump
		return [lmap o [$self get-opts] {$self configure $o}]
	    }
	    1 {
		# one option configure dump
		set o [lindex $args 0]
		return [list $o [$self get $o cname] [$self get $o cclass] [$self get $o dvalue] $options($o)]
	    }
	}
	if {($n&1) != 0} {
	    error "configure requires an even number of arguments"
	}
	foreach {opt val} $args {	
	    if { ! [$self is-option $opt]} {
		error "$opt is not defined in keyer-options::configure"
	    }
	    if {[$self is-ronly $opt]} continue
	    if {[$self get-value $opt] eq $val} continue
	    $self set-value $opt $val
	    if {[catch {set options($opt) $val} result]} {
		puts "keyer::options configure $opt $val: {set options($opt) $val} threw $result"
	    }
	    foreach {comp opt2} [$self component-opts $opt] {
		# puts "keyer-options::configure $comp $opt2"
		dict set data(busy) $comp $opt2 $val
		# puts "keyer-options::configure try: $comp is-busy"
		if { ! [$comp is-busy]} {
		    set opts [dict get $data(busy) $comp]
		    if {[catch {
			# puts "keyer-options::configure try: $comp configure $opts"
			$comp configure {*}$opts
			dict unset data(busy) $comp
		    } error]} {
			puts "configure {$comp configure $opts} threw {$error}"
		    }
		} elseif {$data(handler) eq {}} {
		    # puts "$comp is-busy"
		    set data(handler) [after 100 [mymethod configure-timeout]]
		}
	    }
	}
    }
	
    method configure-timeout {} {
	dict for {comp opts} $data(busy) {
	    if { ! [$comp is-busy]} {
		if {[catch {
		    $comp configure {*}$opts
		    dict unset data(busy) $comp
		} error]} {
		    puts "keyer-options::configure-timeout {$comp configure $opts} threw {$error}"
		}
	    } else {
		# puts "$comp is-busy"
	    }
	}
	if {[dict size $data(busy)] > 0} {
	    set data(handler) [after 100 [mymethod configure-timeout]]
	} else {
	    set data(handler) {}
	}
    }
    
    method cget {opt} {
	if {[$self is-option $opt]} {
	    if {[$self is-volatile $opt]} {
		foreach {name opt2} [$self component-opts $opt] break
		set val [$name cget $opt2]
		if {$val ne $options($opt)} { set options($opt) $val } 
	    }
	    return $options($opt)
	}
	error "keyer-options::cget $opt is not defined"
    }
    
    method cvar {opt} {
	if {[$self is-option $opt]} { return [myvar options($opt)] }
	error "keyer-options::cvar $opt is not defined"
    }

    method populate-option {name opt option} {
	# look for further guidance
	
	switch -glob -- [list [dict get $option factory] $opt] {
	    {* -server} - 
	    {* -client} { $self describe $option text ronly 1 hide 1 conly 1 -graticule 1 }
	    {* -verbose} { $self describe $option ivalue ronly 1 hide 1 conly 1 -min 0 -max 10 -graticule 12 -steps-per-div 1 }
	    {* -chan} { $self describe $option ivalue -min 1 -max 16 -graticule 16 -steps-per-div 1 }
	    {* -note} { $self describe $option ivalue -min 0 -max 127 -graticule 16 -steps-per-div 8 }
	    {* -wpm} { $self describe $option value -format %.1f -units wpm -min 5.0 -max 120.0 -step 0.5 -graticule 20 -steps-per-div 10 }
	    {* -swap} - 
	    {* -mdit} - 
	    {* -mdah} - 
	    {* -mide} - 
	    {* -alsp} - 
	    {* -awsp} { $self describe $option bool }
	    {* -mode} { $self describe $option enum -values {A B} -graticule 12 -graticule-used 2}
	    {* -word} { $self describe $option enum -values {50 60} -units dits -graticule 12 -graticule-used 2}
	    {*keyer* -dit} - 
	    {*keyer* -dah} - 
	    {* -ies} - 
	    {* -ils} - 
	    {* -iws} { 
		set cdefault [dict get $option cdefault]
		set min [expr {$cdefault-0.5}]
		set max [expr {$cdefault+0.5}]
		$self describe $option value -format %.1f -min $min -max $max -step 0.1 -units dits
		#puts "$self describe $name $opt -value $cvalue -min $min -max $max -step 0.1 -units dits"
	    }
	    {* -weight} - 
	    {* -ratio} { $self describe $option value -format %.1f -min 25.0 -max 75.0 -step 0.1 -units % -graticule 20 -steps-per-div 50}
	    {* -comp} { $self describe $option value -format %.1f -min -15.0 -max 15.0 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	    {* -freq} { $self describe $option ivalue -min -1000 -max 1000 -units Hz -graticule 20 -steps-per-div 100}
	    {* -rise} - 
	    {* -fall} - 
	    {* -ramp} { $self describe $option value -format %.1f -min 0.0 -max 15.0 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	    {* -window} { $self describe $option enum -values [lrange [get-window-types] 1 end] }
	    {* -window2} { $self describe $option enum -values [get-window-types] }
	    {* -gain} { $self describe $option value -format %.1f -min -50 -max 3 -step 0.1 -units dB -graticule 20 -steps-per-div 50}
	    {* -delay} { $self describe $option value -format %.1f -min 0.0 -max 1000 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	    {* -hang} { $self describe $option value -format %.1f -min 0.0 -max 1000 -step 0.1 -units ms -graticule 20 -steps-per-div 50 }
	    {*spectrum* -period} {  $self describe $option ivalue -min 1 -max 500 -units ms -graticule 20 -steps-per-div 25 }
	    {*debounce* -period} { $self describe $option value -format %.3f -min 0.1 -max 50 -step 0.1 -units ms -graticule 20 -steps-per-div 25 }
	    {*debounce* -steps} { $self describe $option ivalue -min 1 -max 32 -units steps -graticule 20 -steps-per-div 1}
	    {*insert* -dit} - 
	    {*insert* -dah} - 
	    {* -key} - 
	    {*insert* -ptt} - 
	    {* -key-4} - 
	    {* -key-5} { $self describe $option enum -values {none Shift_L Control_L Alt_L Shift_R Control_R Alt_R}  -graticule 12 -graticule-used 7 }
	    {*insert* -window} { $self describe $option enum -values {none . .dial} -graticule 12 -graticule-used 3}
	    {* -dict} { $self describe $option enum -values [get-morse-dicts] }
	    {* -bandwidth} { $self describe $option freq -format %.0f -min 10 -max 1000 -step 1 -units Hz -graticule 20 -steps-per-div 50}
	    {* -on} - 
	    {* -off} { $self describe $option value -format %.1f -min 0.0 -max 5.0 -step 0.1 -graticule 20 -steps-per-div 5}
	    {* -timeout} { $self describe $option ivalue -min 0 -max 1000 -units frames -graticule 20 -steps-per-div 50}
	    {* -estimate} { $self describe $option ivalue -min 10 -max 1000 -units frames }
	    {* -discover} { $self describe $option text hide 1 }
	    {* -n-rx} -
	    {* -speed} -
	    {* -peer} -
	    {* -gateware-version} -
	    {* -code-version} -
	    {* -board-id} -
	    {* -mac-addr} -
	    {* -mcp4662} -
	    {* -fixed-ip} - 
	    {* -fixed-mac} -
	    {* -n-hw-rx} -
	    {* -wb-fmt} -
	    {* -build-id} -
	    {* -gateware-minor} -
	    {* -serial} { $self describe $option text }
	    {* -bandscope} { $self describe $option bool }
	    {* -hw-dash} -
	    {* -raw-hw-dash} -
	    {* -hw-dot} -
	    {* -raw-hw-dot} -
	    {* -hw-ptt} - 
	    {* -raw-hw-ptt} -
	    {* -overload} - 
	    {* -raw-overload} -
	    {* -recovery} - 
	    {* -raw-recovery} -
	    {* -tx-iq-fifo} - 
	    {* -raw-tx-iq-fifo} -
	    {* -temperature} - 
	    {* -raw-temperature} - 
	    {* -avg-temperature} - 
	    {* -fwd-power} - 
	    {* -raw-fwd-power} -
	    {* -avg-fwd-power} -
	    {* -rev-power} - 
	    {* -raw-rev-power} -
	    {* -avg-rev-power} -
	    {* -pa-current} -
	    {* -raw-pa-current} -
	    {* -avg-pa-current} { 
		$self describe $option text ronly 1 volatile 1
	    }
	    {* -rx-calls} -
	    {* -tx-calls} -
	    {* -bs-calls} -
	    {* -rx-dropped} -
	    {* -rx-outofseq} {
		$self describe $option text ronly 1 volatile 1
	    }
	    {* -mox} { $self describe $option bool }
	    {* -filters} { $self describe $option ivalue -min 0 -max 255 }
	    {* -lna-db} { $self describe $option ivalue -min -12 -max 48 -units dB }
	    {* -f-tx} - 
	    {* -f-rx*} { 
		# Transmitter NCO frequency
		# Receiver NCO frequency.
		set hide 0
		if {[regexp {^-f-rx(\d+)$} $opt all irx]} { if {$irx > 6} { set hide 1 } }
		$self describe $option freq hide $hide -units Hz -format %.0f -min 1 -max 29999999 -step 1 -graticule 20 -steps-per-div 500
		
	    }
	    {* -level} { $self describe $option freq -format %.0f -min 0 -max 255 -step 1 }
	    {* -not-sync} -
	    {* -duplex} -
	    {* -pa} -
	    {* -low-pwr} -
	    {* -pure-signal} -
	    {* -bias-adjust} -
	    {* -vna} -
	    {* -vna-started} -
	    {* -vna-fixed-rx-gain} -
	    {* -alex-manual-mode} - 
	    {* -tune-request} -
	    {* -hermes-lite-lna} -
	    {* -cwx} -
	    {* -reset-hl2-on-disconnect} { $self describe $option bool }
	    {* -vna-count} {
	    }
	    {* -i2c-rx-filter} -
	    {* -i2c-tx-filter} { $self describe $option ivalue -min 0 -max 255 }
	    {* -cw-hang-time} { $self describe $option ivalue dvalue 10 -min 0 -max 1023 -units ms }
	    {* -tx-buffer-latency} { $self describe $option ivalue dvalue 10 -min 0 -max 31 -units ms }
	    {* -ptt-hang-time} { $self describe $option ivalue dvalue 4 -min 0 -max 31 -units ms }
	    {* -predistortion-subindex} { $self describe $option ivalue -min 0 -max 255 }
	    {* -predistortion} { $self describe $option ivalue -min 0 -max 15 }
	    {* -sentcolor} -
	    {* -unsentcolor} -
	    {* -skippedcolor} -
	    {* -background} -
	    {* -foreground} {
		# ignore these and -font for the moment, the foreground widget doesn't wrap things yet
		#$self describe $option enum -values {white black gray lightgrey red orange yellow green blue indigo violet}
	    }
	    {* -font} {
		#$self describe $option enum -values {TkFixedFont {helvetica 10} {helvetica 12} {helvetica 14}}
	    }
	    {* -size} { $self describe $option enum -values {8 16 32 64 128 256 512 1024 2048 4096 8192 16384} -graticule 12}
	    {* -planbits} { $self describe $option ivalue -min 0 -max 127}
	    {* -direction} {$self describe $option enum -values {-1 1} -graticule 12 -graticule-used 2}
	    {* -polyphase} { $self describe $option ivalue -min 1 -max 32 }
	    {* -result} { $self describe $option enum -values {coeff mag2 mag dB short char} -graticule 12 -graticule-used 6}
	    {* -min-f} {}
	    {* -max-f} {}
	    {* -center-freq} {}
	    {* -tuned-freq} {}
	    {* -sample-rate} { $self describe $option enum -values {48000} -graticule 12 -graticule-used 1 }
	    {*spectrum* -min} -
	    {*spectrum* -max} { $self describe $option ivalue -min -200 -max 30 -step 10 -units dB }
	    {* -zoom} { $self describe $option enum -values {0.5 1 2 4 8 16 32 64} -graticule 12 -graticule-used 8 }
	    {* -pan} { $self describe $option ivalue -min 200000 -max 200000 } 
	    {* -command} {}
	    {* -pal} { $self describe $option enum -values {0 1 2 3 4 5} -graticule 12 -graticule-used 6 }
	    {* -atten} {}
	    {* -automatic} {}
	    {* -smooth} { $self describe $option bool }
	    {* -multi} { $self describe $option ivalue -min 1 -max 64 }
	    {* -filter-low} -
	    {* -filter-high} { $self describe $option value -min -8000 -max 8000 }
	    {* -band-low} -
	    {* -band-high} { $self describe $option value -min 100 -max 29999999 }
	    {* -rx-frames-per-call} { $self describe $option text ronly 1 volatile 1 }
	    {* -tx-frames-per-call} - 
	    {* -bs-frames-per-call} { $self describe $option text ronly 1 }
	    {* -length} { $self describe $option enum -values {64 128 256 512 1024} }
	    {* -low} - 
	    {* -high} { $self describe $option value -min -8000 -max 8000 }
	    {*radio* -mode} { $self describe $option enum -values {USB LSB DSB CWU CWL AM SAM FMN DIGU DIGL} }
	    {*radio* -mute} { $self describe $option bool }
	    {*radio* -spot} { $self describe $option bool }
	    {*agc* -mode} { $self describe $option enum -values {off long slow medium fast} }
	    {*agc* -target} { $self describe $option value info {target level, linear gain} -min 0.1 -max 10 }
	    {*agc* -attack} { $self describe $option ivalue info {attack time} -min 1 -max 4 -units ms }
	    {*agc* -decay} { $self describe $option ivalue info {decay time} -min 100 -max 2000 -units ms }
	    {*agc* -slope} { $self describe $option value info {slope, as in y = slope * x + intercept} -min 0.5 -max 2 }
	    {*agc* -hang} { $self describe $option ivalue info {hang time} -min 50 -max 1000 -units ms }
	    {*agc* -fasthang} { $self describe $option ivalue info {fast hang time} -min 50 -max 200 -units ms }
	    {*agc* -max} { $self describe $option value info {max level} -min 1 -max 1e5 }
	    {*agc* -min} { $self describe $option value info {min level} -min 1e-5 -max 1 }
	    {*agc* -threshold} { $self describe $option value info {threshold level} -min 0.25 -max 4 }
	    {*iq* -swap} { $self describe $option bool }
	    {*iq* -delay} { $self describe $option enum info {delay I by one sample, no delay, or delay Q by one sample} -values {-1 0 1} }
	    {*iq-correct* -rate} { $self describe $option value info {the learning rate for the adaptive filter} -min -1e6 -max 1e6 }
	    {*leveler* -mode} { $self describe $option enum -values {off leveler} }
	    {*iambic* -keyer} { $self describe $option enum -values [get-iambic-keyers] }
	    {*meter* -reduce} { $self describe $option enum -values {abs-real abs-imag max-abs mag2} }
	    {*meter* -style} { $self describe $option enum -values {s-meter} }
	    default { puts "populate $name $opt: no clues" }
	    other {
		snit::enum	sdrtype::spec-size	-values {width/8 width/4 width/2 width width*2 width*4 width*8}
	    }
	}
    }

    #
    # the part dealing with components
    #
    method is-component {name} { return [dict exists $data(comps) $name] }

    method find-packages {} {
	# get the directory name of the script
	set dirname [file dirname [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]]

	# find the list of sdrtcl::*, sdrtk::*, and sdrtcltk::* packages
	foreach lib {sdrtcl sdrtk sdrtcltk} {
	    set pkgIndex [file join $dirname .. lib $lib pkgIndex.tcl]
	    set pfp [open $pkgIndex r]
	    foreach line [split [string trim [read-file $pkgIndex]] \n] {
		if {[regexp "${lib}::" $line]} {
		    dict set data(pkgs) [lindex $line 2] {}
		}
	    }
	}
    }

    method packages {} { return [dict keys $data(pkgs)] }
    
    method parse {composite} {
	# first part identifies the sdrtcl component
	# second part is the jack client name
	if {[llength [split $composite @]] == 2} {
	    return [concat $composite [split $composite @]]
	} else {
	    return [list $composite $composite $composite]
	}
    }
    
    method find-factory {composite factory} {
	# search through the sdrtcl/sdrtk/sdrtcltk component list
	# for components which match $factory
	# exact match to tail of name first, then with glob on tail
	set candidates [lsearch -all -inline [$self packages] *$factory]
	if {[llength $candidates] == 0} {
	    set candidates [lsearch -all -inline [$self packages] *$factory*]
	}
	if {[llength $candidates] == 0} { error "no match for component '$composite'" }
	if {[llength $candidates] > 1} { 
	    error "too many matches for component '$composite', '[join $candidates {, }]'"
	}
	# we found one candidate
	set factory [lindex $candidates 0]
	return $factory
    }
    
    method load {composite} {
	# parse the composite into parts
	foreach {composite factory name} [$self parse $composite] break
	set factory [$self find-factory $composite $factory]
	# require the implementation, only loads once
	package require $factory
	# instantiate component
	# and activate if necessary
	set args {}
	switch -glob $factory {
	    sdrtcl::* { 
		if {[get-server] ne {}} { lappend args -server [get-server] }
		set window {}
		$factory ::$name {*}$args
		$name activate
	    }
	    sdrtk::* { 
		toplevel .$name -class "keyer/$name"
		wm title .$name "keyer/$name"
		set window .$name.$name
		# no  {*}$args because it's only sdrtcl -server
		pack [$factory $window] -side top -expand true -fill both
	    }
	    sdrtcltk::* {
		if {[get-server] ne {}} { lappend args -server [get-server] }
		toplevel .$name -class "keyer/$name"
		wm title .$name "keyer/$name"
		set window .$name.$name
		pack [$factory $window {*}$args] -side top -expand true -fill both
		$window activate
	    }
	    default { error "$factory did not match switch" }
	}
	return [list $name $factory $window $composite]
    }
    
    method define {name factory window composite} {
	dict set kcomps $name [dict create name $name factory $factory window $window composite $composite]
	#dict lappend kpkgs $factory $name
    }
    
    method process {composite} {
	foreach {name factory window composite} [$self load $composite] break
	$self define $name $factory $window $composite
	$self populate $name $factory $window $composite
    }
    
    method populate {name factory window composite} {
	if {$window ne {}} {
	    set call $window
	    set opts [$window exposed-options]
	} else {
	    set call $name
	    set opts [$name info options]
	}
	dict set components $name call $call
	foreach opt $opts {
	    # $opt is the option name used in direct configure and cget commands to $comp
	    if {[$self is-option -$name$opt]} { error "keyer-components::populate: $name $opt ... is a duplicate" }
	    set result [$call configure $opt]
	    foreach {copt cname cclass cdefault cvalue} $result break
	    # $copt should be $opt
	    if {$opt ne $copt} { error "keyer-components::populate: $call configure $opt returned a different option name $copt" }
	    # $cname is the option name in the option database (not used here)
	    # $cclass is the option class name in the option database (not used here)
	    # $cdefault is the default value
	    # $cvalue is the current value
	    if {[catch {$call info option $opt} info]} { set info [$call info-option $opt] }
	    # $info is the tool tip for the option
	    set merge [the-merge $opt]; # the merge pattern that matched this opt
	    set hide [expr {[is-hide $opt] || [is-hide -$name$opt]}];    # the opt matched a hide pattern
	    set favor [is-favor $opt];  # the opt is in the favorite list
	    set argvopts [is-argvopts $opt]; # the opt was in the argv
	    set option [dict create \
			    text -$name$opt factory $factory name $name opt $opt window $window call $call \
			    cname $cname cclass $cclass cdefault $cdefault cvalue $cvalue info $info type none \
			    merge $merge hide $hide favor $favor ronly 0 conly 0 volatile 0 isargv $argvopts \
			    composite $composite]
	    # $option is the option dict for -$name$opt
	    $self populate-option $name $opt $option
	}
    }
}

# initialize data variables
set ::data(main) [dict create -server {} -favor {} -argvopts {}]

#
# miscellaneous accessors
# global names stored in dict as dict set ::data(main) $name $val
#
proc get-var {var} { return [dict get $::data(main) $var] }
proc has-var {var} { return [dict exists $::data(main) $var] }
proc set-var {var val} { return [dict set ::data(main) $var $val] }
proc lappend-var {var args} { dict lappend ::data(main) $var {*}$args }

#
# manage option preferences
# match patterns in lists
#
proc the-match {opt list} {
    foreach pat $list { if {[string match $pat $opt]} { return $pat } }
    return {}
}
proc is-matched {opt list} { return [expr {[the-match $opt $list] ne {}}] }

# these are options and groups of options collected from argv
proc get-server {} { return [get-var -server] }
proc has-server {} { return [has-var -server] }
proc set-server {val} { set-var -server $val }

proc get-title {} { return [get-var -title] }
proc has-title {} { return [has-var -title] }
proc set-title {val} { set-var -title $val }

proc get-grid {} { return [get-var -grid] }
proc has-grid {} { return [has-var -grid] }
proc set-grid {val} { set-var -grid $val }

proc get-tree {} { return [get-var -tree] }
proc has-tree {} { return [has-var -tree] }
proc set-tree {val} { set-var -tree $val }

proc get-start {} { return [get-var -start] }
proc has-start {} { return [has-var -start] }
proc lappend-start {args} { lappend-var -start {*}$args }

proc get-argvopts {} { return [get-var -argvopts] }
proc lappend-argvopts {args} { lappend-var -argvopts {*}$args }
proc is-argvopts {o} { return [is-matched $o [get-argvopts]] }

proc get-favor {} { return [::koptions get-favor] }
proc has-favor {} { return [::koptions has-favor] }
proc lappend-favor {args} { ::koptions add-favor {*}$args }
proc the-favor {o} { return [the-match $o [::koptions get-favor]] }
proc is-favor {o} { return [is-matched $o [::koptions get-favor]] }

proc has-merge {} { return [::koptions has-merge] }
proc lappend-merge {args} { ::koptions add-merge {*}$args }
proc the-merge {o} { return [the-match $o [::koptions get-merge]] }

proc get-hide {} { return [::koptions get-hide] }
proc has-hide {} { return [::koptions has-hide] }
proc lappend-hide {args} { ::koptions add-hide {*}$args }
proc is-hide {o} { return [is-matched $o [::koptions get-hide]] }

# user interface components
# primary user interface component is the dialbook
# which isn't finished.

#
# update the window
# this doesn't work when -wpm, -window, and -window2 aren't obvious
# extracted from keyer-options::configure-timeout when merged into koptions
# hmm, none of this is going to work any more, and it should be lower 
# after idle [list update-window-title]
#
proc update-window-title {} {
    if {0} {
	if {[info exists ::value(-wpm)] && [info exists ::value(-window2)]} {
	    if {$::value(-window2) ne {none}} {
		set title "recri keyer $::value(-wpm) wpm $::value(-window)*$::value(-window2)"
	    } else {
		set title "recri keyer $::value(-wpm) wpm $::value(-window)"
	    }
	} elseif {[info exists ::value(-freq)] && [info exists ::value(-window2)]} {
	    if {$::value(-window2) ne {none}} {
		set title "recri keyer $::value(-freq) Hz $::value(-window)*$::value(-window2)"
	    } else {
		set title "recri keyer $::value(-freq) Hz $::value(-window)"
	    }
	} else {
	    set title "recri keyer"
	}
    }
    set title {recri keyer}
    if {[has-title]} { set title [get-title] }
    wm title . $title
    set-title $title
}

#
# load the main ui for the program
#
proc load-ui {} {
    set args {}
    if {[has-grid]} { lappend args -grid [get-grid] }
    if {[has-tree]} { lappend args -tree [get-tree] }
    #.p add [::sdrtk::dialbook .p.dial {*}$args]
    #toplevel .dial
    wm title . keyer/dial
    pack [::sdrtk::dialbook .dial {*}$args]
    array set compid {}
    foreach text [::koptions get-opts] {
	set cvalue [::koptions cget $text]
	set type [::koptions get $text type]
	set name [::koptions get $text name]
	set opt [::koptions get $text opt]
	set info [::koptions get $text info]
	set readout [::koptions get $text readout]
	set var [::koptions cvar $text]
	
	# if already processed, error
	if {[::koptions is-processed $text]} { error "$text already processed" }
	::koptions set $text processed 1
	
	if {[is-hide $text]} continue
	
	set w .dial.x$text
	package require sdrtk::readout-$type
	sdrtk::readout-$type $w -dialbook .dial \
	    -text $text -info $info {*}$readout \
	    -value $cvalue -variable $var -command [list ::koptions configure $text]
	#if {$text in {-key-wpm -key-weight}} { $w test }
	.dial add $w $name $type -text $text
    }
    if {[.dial select] eq {}} { .dial select 0 }
}

#
# setups are macros defining component instances with additional information
# setups bind an implementation to a instance and supply some option values
# saving all setups in one file makes it hard to change the prebuilt setups
# should only save those which are different from the prebuilt defaults
# and should save setup name to ~/.config/keyer/setups/name.tcl
#

package require getstring
namespace import getstring::*

snit::type keyer::setups {

    variable setups [dict create]
    
    constructor {args} {
	$self load-setups
    }

    method add-setup {name val} { dict set setups $name $val }
    method is-setup {name} { return [dict exists $setups $name] }

    method get-names {} { return [dict keys $setups] }
    method get-start {name} { return [dict get $setups $name start] }
    method get-info {name} { return [dict get $setups $name info] }
    method get-ports {name} { return [dict get $setups $name ports] }
    method get-connect {name} { return [dict get $setups $name connect] }

    method build-command-line {} {
	set argv [file tail $::script]
	if {[get-server] ne {}} { lappend argv -server [get-server] }
	lappend argv -start [get-start]
	# prefer specifically named options
	# to the ones that are only inferred from component inspection
	foreach opt [::koptions get-opts] {
	    if { ! [::koptions is-default $opt]} {
		lappend argv $opt $::value($opt)
	    }
	}
	# now find the pertinent -merge -hide etc lists
	if {[has-merge]} { lappend argv -merge [lsort -unique [get-merge]] }
	if {[has-hide]} { lappend argv -hide [lsort -unique [get-hide]] }
	return $argv
    }

    method save-current-setup {} {
	# prompt for name
	if {[tk_getString .gs text "Name for setup:"] && [tk_getString .gs info "Description:"]} {
	    $self add-setup $text [dict create start [$self build-command-line] info $info]
	    $self save-setups
	}
    }

    method save-setups {} {
	# only save setups that do not match default setups
	set defs [$self default-setups]
	set fp [open ~/.config/keyer/setups.tcl w]
	puts $fp "dict create {*}{"
	dict for {key value} $setups {
	    if {[dict exists $defs $key] && $value eq [dict get $defs $key]} continue
	    puts $fp "  $key { [string trim $value] }"
	}
	puts $fp "}"
	close $fp
    }
    
    method merge-default-setups {} {
	set up 0
	dict for {key value} [$self default-setups] {
	    if { ! [dict exists $setups $key] } {
		dict set setups $key $value
		incr up
	    }
	}
	return $up
    }
    
    method init-setups {} {
	# config file does not exist or error reading it
	if { ! [file exists ~/.config]} { file mkdir ~/.config }
	if { ! [file exists ~/.config/keyer]} { file mkdir ~/.config/keyer }
	set setups [$self default-setups]
	$self save-setups
	if {[catch {source ~/.config/keyer/setups.tcl} result]} {
	    error "failed to create default configs: $result"
	}
    }
    
    method load-setups {} {
	if { ! [file exists ~/.config/keyer/setups.tcl] || 
	     [catch {source ~/.config/keyer/setups.tcl} result]} {
	    $self init-setups
	} else {
	    set setups $result
	    if {[$self merge-default-setups]} {
		$self save-setups
	    }
	}
    }
    
    method default-setups {} {
	#
	# connection hints
	#  -connect system-midi>key>kyo>system-audio
	#  -connect system-midi>key2>kyo2>system-audio
	#  -connect kbd>kbo>system-audio
	#  -connect kbd2>kbo2>system-audio
	#  -connect >ptt>
	#  -connect >deb>
	#  -connect cas>key*
	#  -connect (kyo|kbo)*>detone>out (or receiver stream?)
	#
	
	return [dict create {*}{ 
	    key {
		start { keyer -start {keyer-iambic@key keyer-tone@kyo} -key-wpm 16 -kyo-ramp 4.0 -key-mode B -key-alsp 1 }
		info { iambic keyer and a keyed oscillator }
		connect { key:midi_out kyo:midi_in }
		ports { key:midi_in kyo:midi_out kyo:out_i kyo:out_q }
	    }
	    key2 { 
		start {keyer -start {keyer-iambic@key2 keyer-tone@kyo2} -key2-wpm 16 -key2-note 2 -key2-mode B -key2-alsp 1 -kyo2-ramp 4.0 -kyo2-note 2 }
		info { second iambic keyer and keyed oscillator }
		connect { key2:midi_out kyo2:midi_in }
		ports { key2:midi_in kyo2:midi_out kyo2:out_i kyo2:out_q }
	    }
	    kbd {
		start { keyer -start {cw-encode-input@kbd keyer-tone@kbo} -kbd-wpm 80 -kbo-ramp 6.6 }
		info {keyboard keyer and a keyed oscillator}
		connect { kbd:midi_out kyo:midi_in }
		ports { kyo:midi_out kyo:out_i kyo:out_q }
	    }
	    kbd2 {
		start { keyer -start {cw-encode-input@kbd2 keyer-tone@kbo2} -kbd2-wpm 80 -kbo2-ramp 6.6 }
		info {second keyboard keyer and a keyed oscillator}
		connect { kbd2:midi_out kyo2:midi_in }
		ports { kyo2:midi_out kyo2:out_i kyo2:out_q }
	    }
	    ptt {
		start { keyer -start {keyer-ptt@ptt} }
		info {push-to-talk switch with tx delay}
	    }
	    deb {
		start { keyer -start {keyer-debounce@deb} }
		info {key contact debouncer}
	    }
	    cas {
		start { keyer -start {midi-insert-key@cas} -cas-dit Alt_R -cas-dah Control_R }
		info {midi events from keyboard keys}
	    }
	    tap {
		start { keyer -start {midi-tap-view@tap} }
		info {midi monitor for timing events}
	    }
	    tap2 {
		start { keyer -start {midi-tap-view@tap2} }
		info {second midi monitor for timing events}
	    }
	    out {
		start { keyer -start {cw-decode-view@out} -out-freq 700 -out-wpm 16 }
		info {audio to ascii morse decoder}
	    }
	    hl {
		start { keyer -start {hl-connect@hl} -hl-client hl -hide {-hl-raw-* -hl-avg-* -hl-hw-*} }
		info { hermes lite udp jack connection }
	    }
	    hlt {
		start { keyer -start {hl-test@hlt} -kyo-gain -6 -hl-low-pwr 1 -hl-lna-db 14 -hl-pa 0 }
		info { hermes lite test dashboard }
	    }
	    spec {
		start { keyer -start {spectrum-waterfall-view@spec}}
		info { spectrum and waterfall display }
	    }
	    spec2 {
		start { keyer -start {spectrum-waterfall-view@spec2}}
		info { spectrum and waterfall display }
	    }
	    filt {
		start { keyer -start {filter-overlap-save@filt} -filt-low 0 -filt-high 1400 }
		info { overlap save bandpass filter }
	    }
	    test {
		start { keyer key hl hlt spec filt -tree 1 } 
		info { hermes lite test app }
	    }
	    nod {
		start { keyer -hide {*-dit *-dah *-ies *-ils *-iws *-alsp *-awsp *-word} }
		info {hide esoteric keyer options}
	    }
	    1ch {
		start { keyer -merge {*-chan *-note} }
		info {merge midi channel and note options}
	    }
	}]
    }
}
proc is-setup {name} { return [::setups is-setup $name] }
proc get-setup-names {} { return [::setups get-names] }
proc get-setup-info {name} { return [::setups get-info $name] }
proc get-setup-start {name} { return [::setups get-start $name] }


snit::type keyer::main {
}

#
#
#
proc usage-message {} {
    puts "usage: keyer setup ..."
    puts "setups: [get-setup-names]"
    foreach s [get-setup-names] {
	puts "  $s: [get-setup-info $s]"
    }
    exit 1
}

#
# process a list of arguments, always formatted as -option value pairs
#
proc main-argv {argv} {
    # peel off any number of setup names
    while {[llength $argv] > 0 && [is-setup [lindex $argv 0]]} {
	set v [lindex $argv 0]
	set argv [lrange $argv 1 end]
	main-argv [lrange [get-setup-start $v] 1 end]
    }
    foreach {opt val} $argv {
	# -server - jack server
	# -title - window title
	# -run - saved setups to run
	# -start - components to start
	# -favor - option patterns to favor
	# -hide - option patterns to hide
	# -merge - option patterns to merge
	# -grid 1 - use dialbook grid setup
	# -tree 1 - use dialbook tree setup
	# otherwise - -option value pair to apply to parts
	switch -- $opt { 
	    -server { set-server $val }
	    -title { set-title $val }
	    -run { foreach v $val { main-argv [lrange [get-setup-start $v] 1 end] } }
	    -start { lappend-start {*}$val }
	    -favor { lappend-favor {*}$val }
	    -hide { lappend-hide {*}$val }
	    -merge { lappend-merge {*}$val }
	    -grid { set-grid $val }
	    -tree { set-tree $val }
	    default { lappend-argvopts $opt $val }
	}
    }
}

package require sdrtcl::jack-client
sdrtcl::jack-client jack

proc manage-connections {} {
    # puts [jack list-ports]
}

proc main {argv} {
    
    # style, abolish invisible indicators
    # these apply to the -grid displayed widgets
    ttk::style configure "." -indicatordiameter 12
    ttk::style configure TCheckbutton -relief raised
    ttk::style configure TRadiobutton -relief raised
    
    # make label frame labels larger
    ttk::style configure TLabelframe.Label -font {Helvetica 14}

    # load or create ~/.config/keyer/setups.tcl
    ::keyer::setups ::setups
    
    # make a usage message
    if {$argv eq {} || $argv eq {help}} { usage-message }
    
    # initialize options/components database
    keyer::options ::koptions

    # process arguments, first pass just to collect everything
    main-argv $argv
    
    # start components and collect their options
    # puts "main: has-start [has-start]"
    if { ! [has-start]} { usage-message }
    
    foreach composite [get-start] { ::koptions process $composite }
    
    # process command line options for additional option definitions
    foreach {opt val} [get-argvopts] {
	if {[::koptions is-option $opt]} continue; # already defined
	#error "undefined option: $opt $val"
	# something missing here? - FIX.ME?
    }
    
    # build the ui with the extracted options
    load-ui
    
    # load the options collected from the command line
    foreach {opt val} [get-argvopts] { 
	if {[catch {::koptions configure $opt $val} error]} {
	    puts "koptions configure threw $error"
	    # if the $opt is -$comp for one of the setup components,
	    # then apply it to each opt value pair in $val to get
	    # -$comp$opt $value
	    if {[llength $val] > 1 && ([llength $val]&1) == 0} {
		foreach {option value} $val {
		    if {[catch {::koptions configure $opt$option $value} error2]} {
			puts "bad option: $opt $val"
		    }
		}
	    } else {
		puts "bad option: $opt $val"
	    }
	}
    }
    
    # install application icon
    set dir [file join $::dirname .. icons]
    image create photo icon1 -file [file join $dir qrv96.png]
    image create photo icon2 -file [file join $dir qrv48.png]
    wm iconphoto . -default icon1 icon2
    # update window title
    update-window-title
    
    manage-connections
}

main $argv

# current todo
# [x] fix the volatile polling
# [x] wrap the setups in a snit::type
# [ ] wrap the loose options in a snit::type
# [ ] implement option -merge
# [ ] implement option -chain
# [x] create treeview to organize options, etc.
# [x] all-options subtree with all options present
# [x] merge all options and details into one dict.
# [ ] dial-faves subtree with dial favorites
# [ ] types subtree specifying options on values for shared types
# [ ] out-connections subtree listing components and their sinks
# [ ] in-connections subtree listing components and their sources
# [ ] auto connection hints
# [ ] jackd start hints
# [ ] start jackd if necessary, retain connection to server messages
# [ ] perform connections if necessary
# [x] readout-values should limit dial movement to range of choices
# [x] readout-* should have consistent locations
# [x] make the window'ed components into sdrtk::packages
# [x] make mixed windowed dsp components into sdrtcltk::packages
# [ ] implement the snit info vs sdrtcl info fix
# [ ] make a readout-vfo which tunes nicely
# [x] bring up the overlap-save passband filter
# [x] bring up the polyphase spectrum/waterfall (which should run as a separate process?)
# [ ] run the polyphase spectrum/waterfall as a separate process/thread
# [ ] aggressive UI debouncing on all tunable components
# [ ] rewire the spectrum waterfall to the tuner.
# [ ] rewrite the tuner/radio component that switches bandpass filter and spectrum display
#	of bandpass envelope, and the modem bank
# [ ] can start qjackctl from the command line with a specified patch
#     qjackctl --start -active-patchbay=[path] --server-name=[label] --preset=[label]
#     but it may not be activated?
#
# old todo list
# [-] make the -rise-fall option sort after the -rise and -fall that it joins
# [-] make the -rise-fall option update the displayed -rise and -fall option values too
# [x] replace -rise-fall with -ramp option in the keyer-tone itself
# [x] wrap more of this into snit
# [x] generate the command line for a configured setup, save it, restore it
# [x] start using tklib
# [x] prompt for name for saved setup
# [ ] balloon help for options
# [ ] balloon help for setups
# [ ] balloon help for components
# [x] add empty units box to readout-enum
# [ ] implement dialbook dial labels
# [ ] implement recursive dialbook, where groups of related, boring options are pushed down into boxes
# [ ] implement dialbook detents and dial limits so it doesn't just spin.
# [x] allow keyer setup1 setup2 ... as syntactic sugar
# [x] end timer loop when cwtext queue empties
# [ ] end timer loop when dialbook-set queue empties
# [ ] implement midi -> OSC bridge (easy)
# [ ] implement OSC -> MIDI bridge (not so easy, alsa sequencer?)
# 
