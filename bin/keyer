#!/usr/bin/wish8.6
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# Copyright (C) 2018 by Roger E Critchlow Jr, Charlestown, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

# this is the mega-keyer script
# start arbitrary collections of sdrtcl components
# wire up their options into a dialbook
# hide, merge, or fuse options
# save the result as a preset command for later access
#
# current todo
# [x] create treeview to organize options, etc.
# [x] all-options subtree with all options present
# [ ] merge all options and details into one dict.
# [ ] dial-faves subtree with dial favorites
# [ ] types subtree specifying options on values for shared types
# [ ] out-connections subtree listing components and their sinks
# [ ] in-connections subtree listing components and their sources
# [ ] auto connection hints
# [ ] jackd start hints
# [ ] start jackd if necessary, retain connecton to server messages
# [ ] perform connections if necessary
# [ ] readout-values should limit dial movement to range of choices
# [ ] readout-* should have consistent locations
# [ ] make the window'ed components into sdrtk::packages
# [ ] implement the snit info vs sdrtcl info fix
# [ ] make a readout-vfo which tunes nicely
# [ ] bring up the overlap-save passband filter
# [ ] bring up the polyphase spectrum/waterfall (which should run as a separate process?)
# 
#
# old todo list
# [-] make the -rise-fall option sort after the -rise and -fall that it joins
# [-] make the -rise-fall option update the displayed -rise and -fall option values too
# [x] replace -rise-fall with -ramp option in the keyer-tone itself
# [x] wrap more of this into snit
# [x] generate the command line for a configured setup, save it, restore it
# [x] start using tklib
# [x] prompt for name for saved setup
# [ ] balloon help for options
# [ ] balloon help for setups
# [ ] balloon help for components
# [x] add empty units box to readout-enum
# [ ] implement dialbook dial labels
# [ ] implement recursive dialbook, where groups of related, boring options are pushed down into boxes
# [ ] implement dialbook detents and dial limits so it doesn't just spin.
# [x] allow keyer setup1 setup2 ... as syntactic sugar
# [x] end timer loop when cwtext queue empties
# [ ] end timer loop when dialbook-set queue empties
# [ ] implement midi -> OSC bridge (easy)
# [ ] implement OSC -> MIDI bridge (not so easy, alsa sequencer?)
# 

#
# use the script location to find the rest of the libraries
#
set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
set dirname [file dirname $script]

#
# append the ../lib directory to the Tcl search path
#
lappend auto_path [file join $dirname .. lib]

#
# find the list of sdrtcl::* and sdrtcltk::* packages
#
proc read-file {file} { set fp [open $file r]; set data [read $fp]; close $fp; return $data }
set packages {}
foreach lib {sdrtcl sdrtcltk} {
    set pkgIndex [file join $dirname .. lib $lib pkgIndex.tcl]
    set pfp [open $pkgIndex r]
    foreach line [split [string trim [read-file $pkgIndex]] \n] {
	if {[regexp "${lib}::" $line]} {
	    lappend packages [lindex $line 2]
	}
    }
}
#puts $packages
#exit 0
#set packages [exec grep sdrtcl:: [file join $dirname .. lib sdrtcl pkgIndex.tcl] | awk {{print $3}} | sed -e s/sdrtcl:://g]

#
# utilities
#
proc read-file {file} {
    set fp [open $file r]
    set data [read $fp]
    close $fp
    return $data
}
proc write-file {file data} {
    set fp [open $file w]
    puts -nonewline $fp $data
    close $fp
}

# initialize
set ::data(main) [dict create -server {} -hide {} -merge {} -argvopts {} -ronly {} -conly {} -volatile {}]

#
# miscellaneous accessors
#
proc get-var {var} { return [dict get $::data(main) $var] }
proc set-var {var val} { return [dict set ::data(main) $var $val] }
proc has-var {var} { return [dict exists $::data(main) $var] }
proc lappend-var {var args} { dict lappend ::data(main) $var {*}$args }

proc has-setups {} { return [has-var -setups] }
proc get-setups {} { return [get-var -setups] }
proc set-setups {val} { set-var -setups $val }
proc add-setup {name val} {
    set old [get-setups]
    dict set old $name $val
    set-setups $old
}
proc get-setup {name} { return [dict get [get-setups] $name] }

# -tap
foreach x {-server -iambic -ascii -detime -title -start -argvopts -merge -hide -ronly -conly -volatile -grid -tree} {
    proc get$x {} "return \[get-var $x]"
    proc set$x {args} "lappend-var $x {*}\$args"
    proc lappend$x {args} "lappend-var $x {*}\$args"
    proc has$x {} "return \[has-var $x]"
}

#
# manage option preferences
# some of these should match patterns in the lists
#
proc the-match {opt list} {
    foreach pat $list { if {[string match $pat $opt]} { return $pat } }
    return {}
}
proc is-matched {opt list} { return [expr {[the-match $opt $list] ne {}}] }


proc the-hide {opt} { return [the-match $opt [get-hide]] }
proc the-merge {opt} { return [the-match $opt [get-merge]] }

foreach x {-hide -merge} {
    proc is$x {o} "return \[is-matched \$o \[get$x]]"
}
foreach x {-argvopts -ronly -conly -volatile} {
    proc is$x {o} "return \[expr {\$o in \[get$x]}]"
}

# options are created in component specific versions -$comp$opt
# or as merged versions where all identically spelled options
# are set as a group

set ::data(all-options) [dict create];	# qualified option names
array set ::value {};			# updated whenever option is configured

proc opt-is-defined {opt} { return [dict exists $::data(all-options) $opt] }

proc opt-get-val {opt key} { return [dict get $::data(all-options) $opt $key] }
proc opt-set-val {opt key val} { dict set ::data(all-options) $opt $key $val }
proc opt-is-ronly {opt} { return [opt-get-val $opt ronly] }
proc opt-is-conly {opt} { return [opt-get-val $opt conly] }
proc opt-get-value {opt} { return [opt-get-val $opt cvalue] }
proc opt-get-default {opt} { return [opt-get-val $opt cdefault] }
proc opt-set-value {opt val} { return [opt-set-val $opt cvalue $val] }
proc opt-set-default {opt val} { return [opt-set-val $opt cdefault $val] }

proc opt-create {text name opt {window {}}} {
    return [dict create text $text name $name opt $opt window $window factory {} hide {} merge {} ronly 0 conly 0 volatile 0 described 0]
}

proc opt-define {text name opt {window {}}} {
    #puts "opt-define {$text} {$name} {$opt}"
    if {[dict exists $::data(all-options) $text]} { error "opt-define $text $name $opt: duplicate definition" }
    if {$text ne "-$name$opt"} { error "opt-define $text $name $opt - unexpected pattern" }
    dict set ::data(all-options) $text [opt-create $text $name $opt $window]
    return [dict get $::data(all-options) $text]
}

proc opt-component-opts {opt} {
    #set old [dict get $::data(defines) $opt]
    #set new [list [dict get $::data(all-options) $opt comp] [dict get $::data(all-options) $opt opt2]]
    #if {$old ne $new} { error "opt-component-opts $opt: old ne new, ie {$old} ne {$new}" }
    return [list [dict get $::data(all-options) $opt name] [dict get $::data(all-options) $opt opt]]
}

proc opt-get-opts {} {
    return [dict keys $::data(all-options)] 
}

proc opt-describe {dict type args} { 
    dict set dict type $type
    dict set dict described 1
    dict set dict readout {}
    foreach {key val} $args {
	if {[string index $key 0] eq {-}} {
	    dict lappend dict readout $key $val
	} else {
	    dict set dict $key $val
	}
    }
    set text [dict get $dict text]
    dict set ::data(all-options) $text $dict
    #dict set ::data(desc) $text $dict
    #dict lappend ::data(desc) opts $text
}

proc opts-with-descriptions {} { return [dict keys $::data(all-options)] }
proc opt-description {opt} { return [dict get $::data(all-options) $opt] }

#proc composite-is-defined {comp} { return [dict exists $::data(composites) $comp] }
proc composite-define {name factory window composite} { dict set ::data(composites) $name [dict create name $name factory $factory window $window composite $composite]}
#proc composites {} { return [dict keys $::data(composites)] }

proc composite-parse {composite} {
    # first part identifies the sdrtcl component
    # second part is the jack client name
    if {[llength [split $composite @]] == 2} {
	return [concat $composite [split $composite @]]
    } else {
	return [list $composite $composite $composite]
    }
}

proc composite-load {composite} {
    foreach {composite factory name} [composite-parse $composite] break

    # special case insert selected iambic keyer
    # should just make the iambic keyer a selected option in the keyer
    if {$factory eq {iambic} && [has-iambic]} { set name [get-iambic] }

    # search through the sdrtcl/sdrtk/sdrtcltk component list
    # for components which match $factory
    # going to make sdrtk and sdrtcltk component lists, too
    set candidates [lsearch -all -inline $::packages *$factory*]
    puts "$factory matches $candidates"
    if {[llength $candidates] == 0} { error "no match for component '$composite'" }
    if {[llength $candidates] > 1} { error "too many matches for component '$composite', '[join $candidates {, }]'" }
    # we found one candidate
    set factory [lindex $candidates 0]
    # load the implementation
    package require $factory
    # instantiate component
    # and activate if necessary
    set args {}
    if {[has-server] && [get-server] ne {}} {
	lappend args -server [get-server]
    }
    switch -glob $factory {
	sdrtcl::* { 
	    set window {}
	    $factory $name {*}$args
	    $name activate
	}
	sdrtk::* { 
	    set window .$name
	    toplevel $window
	    pack [$factory $window.$name {*}$args] -side top -expand true -fill both
	}
	sdrtcltk::* {
	    set window .$name
	    toplevel $window
	    pack [$factory $window.$name {*}$args] -side top -expand true -fill both
	    puts "$window.$name activate"
	    $window.$name activate
	}
	default { error "$factory did not match switch" }
    }
    # remember this
    return [list $name $factory $window.$name $composite]
}

# user interface components
# primary user interface component is the dialbook
# which isn't finished.

package require snit
namespace eval ::sdrtk {}
package require sdrtk::dialbook
package require sdrtk::readout-bool
package require sdrtk::readout-enum
package require sdrtk::readout-freq
package require sdrtk::readout-value
package require sdrtk::readout-text

# these are filter/fft windowing functions
package require sdrtcl::window
proc get-window-types {} {
    catch { sdrtcl::window foo 512 } error
    regexp {^unknown window type, should be one of (.*)$} $error all error
    regsub -all {, (or )?} $error { } error
    set error [lsort $error]
    set i [lsearch $error {none}]
    if {$i >= 0} {
	set error [concat none [lreplace $error $i $i]]
    }
    return $error
}

# these are morse code dictionaries
package require morse::dicts
proc get-morse-dicts {} {
    return [concat {builtin} [morse-dicts]]
}

# add any special sauce appropriate to a particular option
proc populate-option {name opt option} {
    # puts "populate-option $name $opt $option"
    # look for further guidance
    switch -glob -- $opt {
	-server - -client { opt-describe $option text ronly 1 hide 1 conly 1 -graticule 1 }
	-verbose { opt-describe $option value ronly 1 hide 1 conly 1 -format %.0f -min 0 -max 10 -graticule 12 -steps-per-div 1 }
	-chan { opt-describe $option value -format %.0f -min 1 -max 16 -graticule 12 -steps-per-div 1 }
	-note { opt-describe $option value -format %.0f -min 0 -max 127 -graticule 12 -steps-per-div 1 }
	-wpm { opt-describe $option value -format %.1f -units wpm -min 5.0 -max 120.0 -step 0.5 -graticule 20 -steps-per-div 10 }
	-swap - -mdit - -mdah - -mide - -alsp - -awsp { opt-describe $option bool }
	-mode { opt-describe $option enum -values {A B} }
	-word { opt-describe $option enum -values {50 60} -units dits }
	-dit - -dah - -ies - -ils - -iws { 
	    set cdefault [dict get $option cdefault]
	    set min [expr {$cdefault-0.5}]
	    set max [expr {$cdefault+0.5}]
	    opt-describe $option value -format %.1f -min $min -max $max -step 0.1 -units dits
	    #puts "opt-describe $name $opt -value $cvalue -min $min -max $max -step 0.1 -units dits"
	}
	-weight - -ratio { opt-describe $option value -format %.1f -min 25.0 -max 75.0 -step 0.1 -units % -graticule 20 -steps-per-div 50}
	-comp { opt-describe $option value -format %.1f -min -15.0 -max 15.0 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	-freq { opt-describe $option value -format %.0f -min 500 -max 6000 -step 1 -units Hz -graticule 20 -steps-per-div 100}
	-rise - -fall - -ramp { opt-describe $option value -format %.1f -min 0.0 -max 15.0 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	-window { opt-describe $option enum -values [lrange [get-window-types] 1 end] }
	-window2 { opt-describe $option enum -values [get-window-types] }
	-gain { opt-describe $option value -format %.1f -min -50 -max 3 -step 0.1 -units dB -graticule 20 -steps-per-div 50}
	-delay { opt-describe $option value -format %.1f -min 0.0 -max 1000 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	-hang { opt-describe $option value -format %.1f -min 0.0 -max 1000 -step 0.1 -units ms -graticule 20 -steps-per-div 50 }
	-period { opt-describe $option value -format %.3f -min 0.0 -max 1.000 -step 0.001 -units ms -graticule 20 -steps-per-div 50}
	-steps { opt-describe $option value -format %.0f -min 1 -max 32 -step 1 -units steps -graticule 20 -steps-per-div 1}
	-key-dit - -key-dah - -key-key - -key-ptt - -key-4 - -key-5 { opt-describe $option enum -values {none Shift_L Control_L Alt_L Shift_R Control_R Alt_R} }
	-key-window { opt-describe $option enum -values {none . .dial} }
	-dict { opt-describe $option enum -values [get-morse-dicts] }
	-bandwidth { opt-describe $option freq -format %.0f -min 10 -max 1000 -step 1 -units Hz -graticule 20 -steps-per-div 50}
	-on - -off { opt-describe $option value -format %.1f -min 0.0 -max 5.0 -step 0.1 -graticule 20 -steps-per-div 5}
	-timeout { opt-describe $option value -format %.0f -min 0 -max 1000 -step 1 -units frames -graticule 20 -steps-per-div 50}
	-estimate { opt-describe $option value -format %.0f -min 10 -max 1000 -step 1 -units frames }
	-n-rx - -speed - -peer - -gateware-version - -code-version - -board-id - -mac-addr - -mcp4662 -
	-fixed-ip - -fixed-mac - -n-hw-rx - -wb-fmt - -build-id - -gateware-minor - -serial { opt-describe $option text ronly 1 }
	-bandscope { opt-describe $option bool }
	-hw-dash - -hw-dot - -hw-ptt - -overload - -recovery - -tx-iq-fifo - -temperature - -fwd-power -
	-rev-power - -pa-current { opt-describe $option text ronly 1 volatile 1 }
	-mox { opt-describe $option bool }
	-filters { opt-describe $option value -format %.0f -min 0 -max 255 -step 1 }
	-lna-db { opt-describe $option value -format %.0f -min -12 -max 48 -step 1 -units dB }
	-f-tx - -f-rx1 - -f-rx2 - -f-rx3 - -f-rx4 - -f-rx5 - -f-rx6 - -f-rx7 - -f-rx8 - -f-rx9 - -f-rx10 - -f-rx11 - -f-rx12 { 
	    # Transmitter NCO frequency
	    # Receiver NCO frequency.
	    set hide 0
	    if {[regexp {^-f-rx(\d+)$} $opt all irx]} { if {$irx > 6} { set hide 1 } }
	    opt-describe $option freq hide $hide -units Hz -format %.0f -min 1 -max 29999999 -step 1
	}
	-level { opt-describe $option freq -format %.0f -min 0 -max 255 -step 1 }
	-not-sync - -duplex - -pa - -low-pwr - -pure-signal - -bias-adjust - -vna - -vna-started - -vna-fixed-rx-gain -
	-alex-manual-mode - -tune-request - -hermes-lite-lna - -cwx - -reset-hl2-on-disconnect { opt-describe $option bool }
	-vna-count {
	}
	-i2c-rx-filter - -i2c-tx-filter { opt-describe $option value -format %.0f -min 0 -max 255 }
	-cw-hang-time { opt-describe $option value dvalue 10 -format %.0f -units ms -min 0 -max 1023 }
	-tx-buffer-latency { opt-describe $option value dvalue 10 -format %.0f -units ms -min 0 -max 31 }
	-ptt-hang-time { opt-describe $option value dvalue 4 -format %.0f -units ms -min 0 -max 31 }
	-predistortion-subindex { opt-describe $option value -format %.0f -min 0 -max 255 }
	-predistortion { opt-describe $option value -format %.0f -min 0 -max 15 }
	-sentcolor - -unsentcolor - -skippedcolor - -background {
	    # ignore these and -font for the moment, the foreground widget doesn't wrap things yet
	    #opt-describe $option enum -values {white black gray lightgrey red orange yellow green blue indigo violet}
	}
	-font {
	    #opt-describe $option enum -values {TkFixedFont {helvetica 10} {helvetica 12} {helvetica 14}}
	}
	default { puts "populate-option $name $opt: no clues" }
    }
}

# go through the components and build the database of options
proc composite-populate-options {name factory window composite} {
    # $component is the component $factory
    # $name is the component instance
    # puts "composite-populate-options $name $factory $window $composite"
    if {$window ne {}} {
	set call $window
	set options [$window exposed-options]
    } else {
	set call $name
	set options [$name info options]
    }
    foreach opt $options {
	# $opt is the option name used in direct configure and cget commands to $comp
	if {[opt-is-defined -$name$opt]} { error "composite-populate-options: $name $opt ... is a duplicate" }
	foreach {copt cname cclass cdefault cvalue} [$call configure $opt] break
	# $copt should be $opt
	if {$opt ne $copt} { error "composite-populate-options: $call configure $opt returned a different option name $copt" }
	# $cname is the option name in the option database (not used here)
	# $cclass is the option class name in the option database (not used here)
	# $cdefault is the default value
	# $cvalue is the current value
	if {[catch {$call info option $opt} info]} { set info [$call info-option $opt] }
	# $info is the tool tip for the option
	set option [dict create \
			text -$name$opt factory $factory name $name opt $opt window $window cname $cname cclass $cclass \
			cdefault $cdefault cvalue $cvalue info $info type none merge [the-merge $opt] hide [the-hide $opt] \
			ronly [is-ronly $opt] conly [is-conly $opt] volatile [is-volatile $opt] isargv [is-argvopts $opt] \
			composite $composite]
	# $option is the option dict for -$name$opt
	populate-option $name $opt $option
    }
}

#
# update the window
# this doesn't work when -wpm, -window, and -window2 aren't obvious
#
proc update-window-title {} {
    if {0} {
	if {[info exists ::value(-wpm)] && [info exists ::value(-window2)]} {
	    if {$::value(-window2) ne {none}} {
		set title "recri keyer $::value(-wpm) wpm $::value(-window)*$::value(-window2)"
	    } else {
		set title "recri keyer $::value(-wpm) wpm $::value(-window)"
	    }
	} elseif {[info exists ::value(-freq)] && [info exists ::value(-window2)]} {
	    if {$::value(-window2) ne {none}} {
		set title "recri keyer $::value(-freq) Hz $::value(-window)*$::value(-window2)"
	    } else {
		set title "recri keyer $::value(-freq) Hz $::value(-window)"
	    }
	} else {
	    set title "recri keyer"
	}
    }
    set title {recri keyer}
    if {[has-title]} { set title [get-title] }
    wm title . $title
    set-title $title
}

#
# dial setting, most options are delegated to the dialbook
# one dial for setting everything.
#
# there's a trickiness, the sdrtcl widgets that implement jack
# dsp can be too busy to process options, so we may need to
# wait until the previous setting has completed.  This is all
# to avoiding expensive computations in the inner dsp loop, and
# getting.
#
# should wrap this into a snit type, ideally responisble for
# constructing the dialbook pages and managing the options
# list and aliases and so on.
#
set handler {}

proc dial-set {opt val} {
    #puts "dial-set $opt $val opt-is-defined [opt-is-defined $opt] and $::value($opt)"
    if {[opt-is-defined $opt]} {
	if {[opt-is-ronly $opt]} return
	if {[opt-get-value $opt] eq $val} return
	# puts "dial-set $opt $val when $::value($opt)"
	opt-set-value $opt $val
	set ::value($opt) $val
	foreach {comp opt2} [opt-component-opts $opt] {
	    dict set ::data(busy) $comp $opt2 $val
	    if { ! [$comp is-busy]} {
		set opts [dict get $::data(busy) $comp]
		if {[catch {
		    $comp configure {*}$opts
		    dict unset ::data(busy) $comp
		} error]} {
		    puts "dial-set {$comp configure $opts} threw {$error}"
		}
	    } elseif {$::handler eq {}} {
		# puts "$comp is-busy"
		set ::handler [after 100 dial-set-timeout]
	    }
	}
    } else {
	error "$opt is not defined in dial-set"
    }
}

proc dial-set-timeout {} {
    dict for {comp opts} $::data(busy) {
	if { ! [$comp is-busy]} {
	    if {[catch {
		$comp configure {*}$opts
		dict unset ::data(busy) $comp
	    } error]} {
		puts "dial-set {$comp configure $opts} threw {$error}"
	    }
	} else {
	    # puts "$comp is-busy"
	}
    }
    # hmm, none of this is going to work any more, and it should be lower 
    after idle [list update-window-title]
    if {[dict size $::data(busy)] > 0} {
	set ::handler [after 100 dial-set-timeout]
    } else {
	set ::handler {}
    }
}

proc dial-set-init {} {
    set ::data(busy) [dict create]
    # dial-set-timeout
}

#
# these widgets, and others to come, get defined in setups
# which can draw from sdrtk:: or sdrtcltk::, so these sources
# move into ../lib/sdrtk or ../lib/sdrtcltk.
#
# cwtext window is a live text entry for sending to the ascii-keyer
# cw-text simply supplies bindings for a menu and an abort key
# the escape key binding could move to cwtext itself, or be bound
# onto . so it works where ever you focused input.
#
package require sdrtk::cwtext

snit::widgetadaptor cw-text {
    
    delegate method * to hull
    delegate option * to hull
    
    constructor {args} {
	installhull using sdrtk::cwtext
	$self configure -width 30 -height 15 -exportselection true {*}$args
	bind $win <ButtonPress-3> [mymethod option-menu %X %Y]
	bind $win <Escape> [mymethod stop-sending]
    }

    method is-busy {} { return 0 }

    method exposed-options {} { return {-sentcolor -unsentcolor -skippedcolor -background -font} }

    method {info-option -sentcolor} {} { return {set the color of the sent text} }
    method {info-option -unsentcolor} {} { return {set the color of the yet to be sent text} }
    method {info-option -skippedcolor} {} { return {set the color of the unsent text which will not be sent} }
    method {info-option -background} {} { return {set the background color of the text} }
    method {info-option -font} {} { return {choose the font of the text} }

    method option-menu {x y} {
	if { ! [winfo exists $win.m] } {
	    menu $win.m -tearoff no
	    $win.m add command -label {Stop sending} -command [mymethod stop-sending]
	    $win.m add command -label {Clear window} -command [mymethod clear]
	    $win.m add separator
	    $win.m add command -label {Send file} -command [mymethod choose file]
	    $win.m add separator
	    $win.m add command -label {Font} -command [mymethod choose font]
	    $win.m add command -label {Background} -command [mymethod choose background]
	    $win.m add command -label {Sent Color} -command [mymethod choose sentcolor]
	    $win.m add command -label {Unsent Color} -command [mymethod choose unsentcolor]
	    $win.m add command -label {Skipped Color} -command [mymethod choose skippedcolor]
	}
	tk_popup $win.m $x $y
    }
}

#
# read only text widget, receiving decoded morse
#
package require morse::morse
package require morse::itu
package require morse::dicts

snit::widgetadaptor ro-text {
    option -detime -default {}
    option -dict -default fldigi
    
    method delete {args} { }
    method insert {args} { }
    
    delegate method * to hull
    delegate option * to hull
    
    delegate method ins to hull as insert
    delegate method del to hull as delete
    
    variable handler {}
    variable code {}
    
    method is-busy {} { return 0 }
    # {-color1 -color2 -background}
    method exposed-options {} { return {} }

    method timeout {} {
	#$w insert end [morse-to-text [morse-itu-dict] [[get-detime] get]]
	# get new text
	set text [$options(-detime) get]
	# insert into output display
	$self ins end $text
	$self see end
	# append to accumulated code
	append code $text
	while {[regexp {^([^ ]*) (.*)$} $code all symbol rest]} {
	    if {$symbol ne {}} {
		# each symbol must be terminated by a space
		# replace symbol and space with translation
		$self del end-[string length $code]chars-1chars end
		$self ins end "[morse-to-text [$options(-dict)] $symbol]$rest"
	    } else {
		# an extra space indicates a word space
		# and it's already there
	    }
	    set code $rest
	}
	set handler [after 250 [mymethod timeout]]
    }

    method save {} {
	set filename [tk_getSaveFile -title {Log to file}]
	if {$filename ne {}} {
	    write-file $filename [$self get 1.0 end]
	}
    }

    method clear {} {
	$self del 1.0 end
    }

    method option-menu {x y} {
	if { ! [winfo exists $win.m] } {
	    menu $win.m -tearoff no
	    $win.m add command -label {Clear} -command [mymethod clear]
	    $win.m add separator
	    $win.m add command -label {Save To File} -command [mymethod save]
	}
	tk_popup $win.m $x $y
    }

    constructor {args} {
	installhull using text
	$self configure -width 30 -height 15 -exportselection true {*}$args
	bind $win <ButtonPress-3> [mymethod option-menu %X %Y]
	set handler [after 100 [mymethod timeout]]
	# $self ins end "This is the ro-text window for keyer-detime\n"
    }
}

#
# load the entire ui for the program
#
proc load-ui {} {

    # all of this should be replaced by explicitly
    # naming sdrtk:: or sdrtcltk:: components in setups
    # they each go into a toplevel window, and toplevels
    # may be combined edge-to-edge or tab-merge-tearoff
    # by drag and drop.
    
    # memories-widget
    # if {[has-memories]} { ... }
    if {[has-ascii]} {
	set i 0
	foreach asc [get-ascii] {
	    puts "toplevel .ascii$i"
	    toplevel .ascii$i
	    wm title .ascii$i keyer/keybd/$i
	    pack [cw-text .ascii$i.$asc -ascii $asc] -fill both -expand true
	    composite-populate-options $asc cw-text .ascii$i.$asc {}
	    incr i
	}
    }
    if {[has-detime]} {
	set i 0
	foreach det [get-detime] {
	    puts "toplevel .detime$i"
	    toplevel .detime$i
	    wm title .detime$i keyer/decode/$i
	    pack [ro-text .detime$i.$det -detime $det -dict fldigi] -fill both -expand true
	    composite-populate-options $det ro-text .detime$i.$det {}
	    incr i
	}
    }
#
#    if {[has-tap]} {
#	package require sdrtcltk::midi-tap-view
#	set i 0
#	foreach tap [get-tap] {
#	    puts "toplevel .tap$i"
#	    toplevel .tap$i
#	    wm title .tap$i keyer/midi-tap/$i
#	    pack [sdrtcltk::midi-tap-view .tap$i.$tap -tap $tap] -fill both -expand true
#	    composite-populate-options midi-tap-view $tap .tap$i.$tap
#	    incr i
#	}
#    }
    
    set args {}
    if {[has-grid]} { lappend args -grid [get-grid] }
    if {[has-tree]} { lappend args -tree [get-tree] }
    #.p add [::sdrtk::dialbook .p.dial {*}$args]
    toplevel .dial
    wm title .dial keyer/dialbook
    pack [::sdrtk::dialbook .dial.book {*}$args]
    array set compid {}
    foreach text [opts-with-descriptions] {
	set desc [opt-description $text]
	foreach var [dict keys $desc] {
	    set $var [dict get $desc $var]
	}
	# puts "load-ui $text value $cvalue type $type name $name readout $readout"
	
	# if already processed, error
	if {[info exists ::value($text)]} { error "::value($text) already processed" }
	
	# if no value in definitions, error
	if { ! [info exists cvalue]} { error "no cvalue extracted from option $text" }

	# set up the details display
	set ::value($text) $cvalue
	
	if {[is-hide $text]} continue
	
	lappend readout -value $cvalue -variable ::value($text) -command [list dial-set $text]
	set w .dial.book.x$text
	switch $type {
	    bool { sdrtk::readout-bool $w -dialbook .dial.book -text $text -info $info {*}$readout }
	    enum { sdrtk::readout-enum $w -dialbook .dial.book -text $text -info $info {*}$readout }
	    freq { sdrtk::readout-freq $w -dialbook .dial.book -text $text -info $info {*}$readout }
	    value { sdrtk::readout-value $w -dialbook .dial.book -text $text -info $info {*}$readout }
	    text { sdrtk::readout-text $w -dialbook .dial.book -text $text -info $info {*}$readout }
	    core { sdrtk::readout-core $w -dialbook .dial.book -text $text -info $info {*}$readout }
	    default { error "unanticipated type \"$type\"" }
	}
	#if {$text in {-key-wpm -key-weight}} { $w test }
	.dial.book add $w $name $type -text [$w cget -text]
    }
    if {[.dial.book select] eq {}} { .dial.book select 0 }
}

#
# setups bind an implementaion to a instance and supply some option values
# saving all setups in a file makes it hard to change the prebuilt setups
# should only save those which are different from the prebuilt defaults
#
package require getstring
namespace import getstring::*

proc is-setup {name} {
    return [dict exists [get-setups] $name]
}
proc get-setup-names {} {
    return [lsearch -inline -glob -all -not [dict keys [get-setups]] info-*]
}
proc setup-v0-style {setups} {
    # v0 had setup names but no setup info-names
    set info 0
    set setup 0
    set keys [dict keys $setups]
    foreach key $keys {
	if {[string match $key info-*]} {
	    incr info
	} elseif {[dict exists $setups info-$key]} {
	    incr setup
	}
    }
    return [expr {$info == 0 && $setup == 0}]
}
proc setup-upgrade-v0-v1 {setups} {
    set defs [default-setups]
    foreach key [dict keys $setups] {
	if {[dict exists $defs info-$key]} {
	    set info [dict get $defs info-$key]
	} else {
	    set info {}
	}
	dict set setups info-$key $info
    }
    return $setups
}
proc save-current-setup {} {
    # prompt for name?
    if {[tk_getString .gs text "Name for setup:"]} {
	if {[tk_getString .gs info "Description:"]} {
	    add-setup $text [build-command-line]
	    add-setup info-$text $info
	    save-setups
	}
    }
}
proc save-setups {} {
    set fp [open ~/.config/keyer/keyer.tcl w]
    puts $fp "dict create {*}{"
    dict for {key value} [get-setups] {
	puts $fp "  $key { [string trim $value] }"
    }
    puts $fp "}"
    close $fp
}
proc default-setups {} {
    # connection hints
    #  -connect system-midi>key>kyo>system-audio
    #  -connect system-midi>key2>kyo2>system-audio
    #  -connect kbd>kbo>system-audio
    #  -connect kbd2>kbo2>system-audio
    #  -connect >ptt>
    #  -connect >deb>
    #  -connect cas>key*
    #  -connect (kyo|kbo)*>detone>out (or receiver stream?)
    #
    return [dict create {*}{ 
	key { keyer -start {iambic@key keyer-tone@kyo} -key-wpm 16 -kyo-ramp 4.0 -key-mode B -key-alsp 1 }
	key2 { keyer -start {iambic@key2 keyer-tone@kyo2} -key2-wpm 16 -key2-note 2 -key2-mode B -key2-alsp 1 -kyo2-ramp 4.0 -kyo2-note 2 }
	kbd { keyer -start {ascii@kbd keyer-tone@kbo} -kbd-wpm 80 -kbo-ramp 6.6 }
	kbd2 { keyer -start {ascii@kbd2 keyer-tone@kbo2} -kbd2-wpm 80 -kbo2-ramp 6.6 }
	ptt { keyer -start {keyer-ptt@ptt} }
	deb { keyer -start {keyer-debounce@deb}}
	cas { keyer -start {midi-insert-key@cas} -cas-key-dit Alt_R -cas-key-dah Control_R}
	tap { keyer -start {midi-tap-view@tap} }
	tap2 { keyer -start {midi-tap-view@tap2} }
	out { keyer -start {keyer-detone@detone keyer-detime@out} -detone-freq 700 -out-wpm 16 }
	nod { keyer -hide {*-dit *-dah *-ies *-ils *-iws *-alsp *-awsp *-word} }
	1ch { keyer -merge {*-chan *-note} }
	key+kbd { keyer -run {key kbd}}
	key+out { keyer -run {key out}}
	key+kbd+out { keyer -run {key kbd out} }
	hl { keyer -start hl-connect@hl -hl-client hl }
	info-key {iambic keyer and a keyed oscillator}
	info-key2 {second iambic keyer and keyed oscillator}
	info-kbd {keyboard keyer and a keyed oscillator}
	info-kbd2 {second keyboard keyer and a keyed oscillator}
	info-ptt {push-to-talk switch}
	info-deb {key contact debouncer}
	info-cas {midi events from keyboard keys}
	info-tap {midi monitor for timing events}
	info-tap2 {second midi monitor for timing events}
	info-out {audio to ascii morse decoder}
	info-nod {hide esoteric keyer options}
	info-1ch {merge midi channel and note options}
	info-key+kbd {iambic key and keyboard}
	info-key+out { iambic key and decoder }
	info-key+kbd+out { iambic key, keyboard, and decoder }
	info-hl { hermes lite udp jack connection }
    }]
}
proc merge-default-setups {} {
    set s [get-setups]
    set d [default-setups]
    set up 0
    dict for {name value} $d {
	if { ! [dict exists $s $name] } {
	    dict set s $name $value
	    incr up
	}
    }
    return $up
}
proc init-setups {} {
    # config file does not exist or error reading it
    if { ! [file exists ~/.config]} { file mkdir ~/.config }
    if { ! [file exists ~/.config/keyer]} { file mkdir ~/.config/keyer }
    set-setups [default-setups]
    # save-setups
    #if {[catch {source ~/.config/keyer/keyer.tcl} result]} {
    #	error "failed to create default configs: $result"
    #}
}
proc load-setups {} {
    if { ! [file exists ~/.config/keyer/keyer.tcl] || 
	 [catch {source ~/.config/keyer/keyer.tcl} result]} {
	init-setups
    } elseif {[setup-v0-style $result]} {
	set-setups [setup-upgrade-v0-v1 $result]
	merge-default-setups
	save-setups
    } else {
	set-setups $result
	if {[merge-default-setups]} {
	    save-setups
	}
    }
}
proc build-command-line {} {
    set argv [file tail $::script]
    if {[get-server] ne {}} { lappend argv -server [get-server] }
    lappend argv -start [get-start]
    # prefer specifically named options
    # to the ones that are only inferred from component inspection
    foreach opt [opt-get-opts] {
	if { ! [info exists ::value($opt)]} continue
	if {$::value($opt) ne $::defval($opt)} {
	    lappend argv $opt $::value($opt)
	}
    }
    # now find the pertinent -merge -hide etc lists
    if {[has-merge]} { lappend argv -merge [lsort -unique [get-merge]] }
    if {[has-hide]} { lappend argv -hide [lsort -unique [get-hide]] }
    return $argv
}
proc usage-message {} {
    # puts "[dict keys $::data(main)]"
    puts "usage: keyer setup ..."
    puts "setups: [get-setup-names]"
    foreach s [get-setup-names] {
	puts "  $s: [dict get [get-setups] info-$s]"
    }
    exit 1
}

#
# process a list of arguments, always formatted as -option value pairs
#
proc main-argv {argv} {
    # peel off any number of setup names
    while {[llength $argv] > 0 && [is-setup [lindex $argv 0]]} {
	set v [lindex $argv 0]
	set argv [lrange $argv 1 end]
	main-argv [lrange [get-setup $v] 1 end]
    }
    foreach {opt val} $argv {
	# -server - jack server
	# -title - window title
	# -run - saved setups to run
	# -start - components to start
	# -hide - option patterns to hide
	# -merge - option patterns to merge
	# -iambic - module for iambic keyer
	# -grid - use dialbook grid setup
	# -tree - use dialbook tree setup
	# otherwise - -option value pair to apply to parts
	switch -- $opt { 
	    -server { set-server $val }
	    -title { set-title $val }
	    -run { foreach v $val { main-argv [lrange [get-setup $v] 1 end] } }
	    -start { lappend-start {*}$val }
	    -hide { lappend-hide {*}$val }
	    -merge { lappend-merge {*}$val }
	    -iambic { set-iambic $val }
	    -grid { set-grid $val }
	    -tree { set-tree $val }
	    default { lappend-argvopts $opt $val }
	}
    }
}

package require sdrtcl::jack-client
sdrtcl::jack-client mgr
proc manage-connections {} {
    # puts [mgr list-ports]
}

proc main {argv} {
    
    # style, abolish invisible indicators
    ttk::style configure "." -indicatordiameter 12
    ttk::style configure TCheckbutton -relief raised
    ttk::style configure TRadiobutton -relief raised
    
    # load or create ~/.config/keyer/keyer.tcl
    load-setups
    
    # make a usage message
    if {$argv eq {} || $argv eq {help}} {
	usage-message
    }
    
    # process arguments, first pass just to collect everything
    main-argv $argv
    
    # default value for iambic
    if { ! [has-iambic] } { set-iambic keyer-iambic-ad5dz }
    
    # start components and collect their options
    if { ! [has-start]} { usage-message }

    foreach v [get-start] {
	# start one component of the program
	foreach {name factory window composite} [composite-load $v] break
	composite-define $name $factory $window $composite
	# remember if this is special
	# *::midi-tap-view { set-tap $name }
	switch -glob $factory {
	    *::keyer-ascii { set-ascii $name }
	    *::keyer-detime { set-detime $name }
	}
	# load its options
	composite-populate-options $name $factory $window $composite
    }
    
    # process command line options for additional option definitions
    foreach {opt val} [get-argvopts] {
	if {[opt-is-defined $opt]} continue; # already defined
	error "undefined option: $opt $val"
    }
    
    # initialize the dial-set timer
    dial-set-init
    
    # build the ui with the extracted options
    load-ui
    
    # load the options collected from the command line
    if {[has-argvopts]} {
	foreach {opt val} [get-argvopts] { 
	    # puts "dial-set $opt $val"
	    if {[catch {dial-set $opt $val} error]} {
		puts "dial-set threw $error"
		# if the $opt is -$comp for one of the setup components,
		# then apply it to each opt value pair in $val to get
		# -$comp$opt $value
		foreach {option value} $val {
		    if {[catch {dial-set $opt$option $value} error2]} {
			puts "bad option: $opt $val"
		    }
		}
	    }
	}
    }
    
    # install application icon
    set dir [file join $::dirname .. icons]
    image create photo icon1 -file [file join $dir qrv96.png]
    image create photo icon2 -file [file join $dir qrv48.png]
    wm iconphoto . -default icon1 icon2
    # update window title
    update-window-title

    manage-connections
}

main $argv
