#!/usr/bin/wish8.6
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# Copyright (C) 2018 by Roger E Critchlow Jr, Charlestown, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
set dirname [file dirname $script]
#
# append the ../lib directory to the Tcl search path
#
lappend auto_path [file join $dirname .. lib]

#
# find the list of sdrtcl::*
#
set packages [exec grep sdrtcl:: [file join $dirname .. lib sdrtcl pkgIndex.tcl] | awk {{print $3}} | sed -e s/sdrtcl:://g]

#
# utilities
#
proc read-file {file} {
    set fp [open $file r]
    set data [read $fp]
    close $fp
    return $data
}
proc write-file {file data} {
    set fp [open $file w]
    puts -nonewline $fp $data
    close $fp
}

#
# miscellaneous accessors
#
proc get-var {var} { return [dict get $::data(main) $var] }
proc set-var {var val} { return [dict set ::data(main) $var $val] }
proc has-var {var} { return [dict exists $::data(main) $var] }
proc lappend-var {var args} { dict lappend ::data(main) $var {*}$args }

proc has-server {} { return [has-var -server] }
proc get-server {} { return [get-var -server] }
proc set-server {server} { set-var -server $server }
proc has-dial {} { return 1 }
proc get-ascii {} { return [get-var -ascii] }
proc set-ascii {name} { set-var -ascii $name }
proc has-ascii {} { return [has-var -ascii] }
proc has-memories {} { return 0 }
proc get-detime {} { return [get-var -detime] }
proc set-detime {name} { set-var -detime $name }
proc has-detime {} { return [has-var -detime] }
proc get-insert {} { return [get-var -insert] }
proc set-insert {name} { set-var -insert $name }
proc has-insert {} { return [has-var -insert] }
proc get-tap {} { return [get-var -tap ] }
proc set-tap {name} { set-var -tap $name }
proc has-tap {} { return [has-var -tap ] }

proc lappend-start {val} { lappend-var -start $val }

proc lappend-argvopts {args} { lappend-var -argvopts {*}$args }
proc has-argvopts {} { return [has-var -argvopts] }
proc get-argvopts {} { return [get-var -argvopts] }

proc get-title {} { return [get-var -title] }
proc set-title {title} { set-var -title $title }
proc has-title {} { return [has-var -title] }
proc get-prefer {} { return [get-var -prefer] }
proc set-prefer {opts} { set-var -prefer $opts }
proc has-prefer {} { return [has-var -prefer] }
proc get-hide {} { return [get-var -hide] }
proc set-hide {opts} { set-var -hide $opts }
proc has-hide {} { return [has-var -hide] }

# all components in the app share values for identically spelled options
# except where overridden
set ::data(defines) [dict create]
array set ::value {}
array set ::defval {}
proc opt-is-defined {opt} { return [dict exists $::data(defines) $opt] }
proc opt-define {opt comp {opt2 {}}} { dict lappend ::data(defines) $opt $comp [expr {$opt2 ne {} ? $opt2 : $opt}] }
proc opt-add-dependent {opt comp {opt2 {}}} { dict lappend ::data(defines) $opt $comp [expr {$opt2 ne {} ? $opt2 : $opt}]}
proc opt-component-opts {opt} { return [dict get $::data(defines) $opt] }
proc opt-primary {opt} { return [lindex [opt-components-opts $opt] 0] }
proc opt-get-opts {} { return [dict keys $::data(defines)] }

proc component-is-defined {comp} { return [dict exists $::data(components) $comp] }
proc component-define {comp} { dict set ::data(components) $comp {}}
proc components {} { return [dict keys $::data(components)] }
proc find-components {opt1 opt2} {
    array set found {}
    foreach {comp opt} [opt-component-opts $opt1] {
	set found($comp) 1
    }
    foreach {comp opt}  [opt-component-opts $opt2] {
	incr found($comp)
    }
    set result {}
    foreach comp [array names found] {
	if {$found($comp) == 2} {
	    lappend result $comp
	}
    }
    return $result
}
    
# load an sdrtcl component
# name is name1 or a name1@name2
# name1 specifies the sdrtcl component
# and name2 specifies the jack client name to use for it
# name2 defaults to name1
# name1 can be any string which uniquely identifies an sdrtcl component
# ambiguous ones throw an error with the list that matched
# 
proc sdrtcl-instance {component name2} {
    if {[has-server] && [get-server] ne {}} {
	$component $name2 -server [get-server]
    } else {
	$component $name2
    }
}

proc parse-component {name} {
    # name1 identifies the sdrtcl component
    # name2 is the jack client name
    if {[llength [split $name @]] == 2} {
	return [split $name @]
    } else {
	return [list $name $name]
    }
}
proc load-component {name} {
    foreach {name1 name2} [parse-component $name] break
    # search through the sdrtcl component list
    # for components which match name1
    set candidates {}
    foreach c $::packages {
	if {[string equal $name1 $c]} {
	    set candidates [list $c]
	    break
	} elseif {[string match *$name1* $c]} {
	    lappend candidates $c
	}
    }
    if {[llength $candidates] == 0} { error "no match for component '$name'" }
    if {[llength $candidates] > 1} { error "too many matches for component '$name', '[join $candidates {, }]'" }
    # we found one candidate
    set component [lindex $candidates 0]
    # load the implementation
    package require sdrtcl::$component
    # instantiate component
    sdrtcl-instance sdrtcl::$component $name2
    # activate component
    $name2 activate
    # remember this
    return [list $component $name2]
}

# user interface components
package require sdrtk::dialbook
package require sdrtk::readout-enum
package require sdrtk::readout-freq
package require sdrtk::readout-value
package require sdrtk::vtext

set data(options) {}

proc get-window-types {} {
    package require sdrtcl::window
    catch { sdrtcl::window foo 512 } error
    regexp {^unknown window type, should be one of (.*)$} $error all error
    regsub -all {, (or )?} $error { } error
    set error [lsort $error]
    set i [lsearch $error {none}]
    if {$i >= 0} {
	set error [concat none [lreplace $error $i $i]]
    }
    return $error
}

proc populate-option {name opt2 opt oname oclass odefault ovalue} {
    # component is the 
    # opt2 is a possibly composite name
    # opt is the option name in configure and cget commands
    # oname is the option name in the option database (not used here)
    # oclass is the option class name in the option database
    # odefault is the default value
    # ovalue is the current value
    # info is the tool tip for the option, not presently used
    set info [$name info option $opt]
    # remember the default value for command line generation
    dict set ::data(default) $opt2 $odefault
    # only keep the first of a series of definitions for the same $opt
    if {[opt-is-defined $opt2]} {
	# this is not the first appearance, daisy chain from the first
	    opt-add-dependent $opt2 $name $opt
	    return
	}
    # this is the first appearance of this $opt
    opt-define $opt2 $name $opt
    # look for further guidance
    switch -glob -- $opt2 {
	-server - -client - -verbose {
	    # these are fixed, as in not modifiable
	    # well, verbose could be, but no one wants
	    # to see this running -verbose
	}
	-chan {
	    # remember each option component name, option name, and current value
	    # the {value} is the class of readout component that handles this option
	    # the list is additional options for the readout
	    # midi channel could as well be an {enum} with 16 values.
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -format %.0f -min 1 -max 16 -step 1]
	}
	-note {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -format %.0f -min 0 -max 127 -step 1]
	}
	-wpm - -*-wpm {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -format %.1f -units wpm -min 5.0 -max 200.0 -step 0.5]
	}
	-swap - -mdit - -mdah - -mide - -alsp - -awsp {
	    lappend ::data(options) $name $opt2 $opt enum $ovalue [list -text $opt2 -info $info -values {0 1}]
	}
	-mode {
	    lappend ::data(options) $name $opt2 $opt enum $ovalue [list -text $opt2 -info $info -values {A B}]
	}
	-word {
	    lappend ::data(options) $name $opt2 $opt enum $ovalue [list -text $opt2 -info $info -units dits -values {50 60}]
	}
	-dit - -dah - -ies - -ils - -iws { 
	    set min [expr {0.5*$ovalue}]
	    set max [expr {1.5*$ovalue}]
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -format %.1f -units dits -min $min -max $max -step 0.1]
	}
	-weight - -ratio {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -format %.1f -units % -min 0.0 -max 100.0 -step 0.1]
	}
	-comp {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -format %.1f -units ms -min -15.0 -max 15.0 -step 0.1]
	}
	-freq - -*-freq {
	    lappend ::data(options) $name $opt2 $opt freq $ovalue \
		[list -text $opt2 -info $info -units Hz -format %.0f -min 500 -max 1500 -step 1]
	}
	-rise - -fall - -rise-fall - -*-rise - -*-fall - -*-rise-fall {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -units ms -format %.1f -min 0.0 -max 15.0 -step 0.1]
	}
	-window - -*-window {
	    lappend ::data(options) $name $opt2 $opt enum $ovalue \
		[list -text $opt2 -info $info -values [lrange [get-window-types] 1 end]]
	}
	-window2 - -*-window {
	    lappend ::data(options) $name $opt2 $opt enum $ovalue \
		[list -text $opt2 -info $info -values [get-window-types]]
	}
	-gain {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -units dB -format %.1f -min -50 -max 0 -step 0.1]
	}
	-delay {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -units ms -format %.2f -min 0.0 -max 1000 -step 0.01]
	}
	-hang {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -units ms -format %.1f -min 0.0 -max 1000 -step 0.1]
	}
	-period {
	    # for the debouncer
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -units ms -format %.3f -min 0.0 -max 1.000 -step 0.001]
	}
	-steps {
	    # for the debouncer
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $opt2 -info $info -format %.0f -min 1 -max 32 -step 1]
	}
	-dict {
	    # for the ascii keyer
	}
	-bandwidth {
	    # for the unkeyer detone module
	    # bandwidth BWHertz 100.0 100.0 bandwidth of output signal in Hz
	    lappend ::data(options) $name $opt2 $opt freq $ovalue \
		[list -text $opt2 -info $info -units Hz -format %.0f -min 10 -max 1000 -step 1]
	}
	default {
	    puts "$name $config [$name info option $opt]"
	}
    }
}

proc populate-component-options {component name} {
    # most of this could be greatly simplified by defining a 'type' for each
    # option which specified the kind of values, ranges, step size, etc.
    # for the options.  also of interest is whether we are dealing with a live
    # jack component or something that throw busy errors,
    # everything so far has been an sdrtcl:: jack component, but they could be 
    # wrapped, I'd almost prefer them to handle the busy defer on their own, but
    # then I'd need a timer associated to the wrappers, a type component as it
    # were.
    foreach opt [$name info options] {
	populate-option $name $opt {*}[$name configure $opt]
    }
}

# sort the options so the most used are first
# remove options 
#  pref {-wpm -swap -mode -freq -gain -rise -fall -window -window2}
#  hide {-alsp -awsp}
proc prefer-component-options {prefs} {
    set options $::data(options)
    set ::data(options) {}
    foreach {comp opt2 opt type value opts} $options {
	if {[lsearch $prefs $opt] >= 0} {
	    lappend ::data(options) $comp $opt2 $opt $type $value $opts
	}
    }
    foreach {comp opt2 opt type value opts} $options {
	if {[lsearch $prefs $opt] < 0} {
	    lappend ::data(options) $comp $opt2 $opt $type $value $opts
	}
    }
}
proc hide-component-options {hide} {
    set options $::data(options)
    set ::data(options) {}
    foreach {comp opt2 opt type value opts} $options {
	if {[lsearch $hide $opt] < 0} {
	    lappend ::data(options) $comp $opt2 $opt $type $value $opts
	}
    }
}
#
# control window.
# this one line frame controls which other windows are displayed
# and acts as a focus target for controlling the keyer while 
# minimized.
#
proc keyer-widget {w} {
    ttk::frame $w
    foreach {tag text} {
	dial Settings
	insert Keys
	memories Memories
	ascii Input
	detime Output
	tap Events
    } {
	if {[has-$tag]} {
	    ttk::checkbutton $w.$tag -text $text -variable ::data(show-$tag) -command [list keyer-widget-show $w $tag]
	    pack $w.$tag -side left
	}
    }
    return $w
}
proc keyer-widget-show {w tag} {
    if {$::data(show-$tag)} {
	.p add .p.$tag
    } else {
	.p forget .p.$tag
    }
}
#
# dial setting, most options are delegated to the dial book
# one dial for setting everything.
#
proc dial-set {opt val} {
    if {[opt-is-defined $opt]} {
	set ::value($opt) $val
	foreach {comp opt2} [opt-component-opts $opt] {
	    dict set ::data(busy) $comp $opt2 $val
	    if { ! [$comp is-busy]} {
		set opts [dict get $::data(busy) $comp]
		if {[catch {
		    $comp configure {*}$opts
		    dict unset ::data(busy) $comp
		} error]} {
		    puts "dial-set configure $opts threw $error"
		}
	    } else {
		# puts "$comp is-busy"
	    }
	}
    } else {
	error "$opt is not defined in dial-set"
    }
}

proc dial-set-timeout {} {
    dict for {comp opts} $::data(busy) {
	if { ! [$comp is-busy]} {
	    if {[catch {
		$comp configure {*}$opts
		set ::data(busy) [dict unset $::data(busy) $comp]
	    } error]} {
		puts "dial-set configure $opts threw $error"
	    }
	} else {
	    # puts "$comp is-busy"
	}
    }
    if {[info exists ::value(-wpm)] && [info exists ::value(-window2)]} {
	if {$::value(-window2) ne {none}} {
	    set title "recri keyer $::value(-wpm) wpm $::value(-window)*$::value(-window2)"
	} else {
	    set title "recri keyer $::value(-wpm) wpm $::value(-window)"
	}
    } elseif {[info exists ::value(-freq)] && [info exists ::value(-window2)]} {
	if {$::value(-window2) ne {none}} {
	    set title "recri keyer $::value(-freq) Hz $::value(-window)*$::value(-window2)"
	} else {
	    set title "recri keyer $::value(-freq) Hz $::value(-window)"
	}
    } else {
	set title "recri keyer"
    }
    if { ! [has-title] || [get-title] ne $title} {
	wm title . $title
	set-title $title
    }
    after 100 dial-set-timeout
}

proc dial-set-init {} {
    set ::data(busy) [dict create]
    dial-set-timeout
}

#
# insert window management
# a simple frame which, when focused, generates key events
# for control, alt, and shift keys
#
proc insert-widget {w} {
    ttk::frame $w
    grid [ttk::menubutton $w.dit -text Dit -menu $w.dit.m] -row 0 -column 0 -sticky ew
    menu $w.dit.m -tearoff no
    $w.dit.m add checkbutton -label {Send Dits} -variable ::data(insert-send-dits) -command [list insert-send $w dit]
    grid [ttk::menubutton $w.dah -text Dah -menu $w.dah.m] -row 0 -column 1 -sticky ew
    menu $w.dah.m -tearoff no
    $w.dit.m add checkbutton -label {Send Dahs} -variable ::data(insert-send-dahs) -command [list insert-send $w dah]
    grid [ttk::menubutton $w.key -text Key -menu $w.key.m] -row 0 -column 2 -sticky ew
    menu $w.key.m -tearoff no
    $w.key.m add checkbutton -label {Key Down} -variable ::data(insert-send-key) -command [list insert-send $w key]
    insert-widget-bind $w Shift_R key
    insert-widget-bind $w Alt_R dit
    insert-widget-bind $w Control_R dah
    return $w
}
proc insert-widget-bind {w tag element} {
    bind $w <KeyPress-$tag> [insert-key $w $element down]
    bind $w <KeyRelease-$tag> [insert-key $w $element up]
}
proc insert-send {w element} {
}
proc insert-key {w element updown} {
    switch $element {
	dit { set note 0 }
	dah { set note 1 }
	key { set note 2 }
	default { error "insert-key $w ??$element?? $updown" }
    }
    switch $updown {
	up { set cmd 0x80;	#define MIDI_NOTE_OFF
	}
	down { set cmd 0x90;	#define MIDI_NOTE_ON
	}
	default { error "insert-key $w $element ??$updown??" } 
    }
    puts "insert $cmd $::value(-chan) $::value(-note)+$note 127"
    [get-insert] puts [binary format ccc [expr {$cmd|($::value(-chan)-1)}] [expr {$::value(-note)+$note}] 127]
}
#
# cwtext window management
# cwtext window is a live text entry for sending to the ascii-keyer
#
proc cwtext-window-timeout {w} {
    # I'm seeing available taking 50-60 units per character sent
    if { (! [[get-ascii] is-busy]) && [[get-ascii] pending] < 40} {
	set text [$w nextchar]
	if {$text ne {}} {
	    [get-ascii] puts [string toupper $text]
	}
    }
    after 20 [list cwtext-window-timeout $w]
}

proc cwtext-stop-sending {w} { $w abort; [get-ascii] abort }

proc cwtext-insert-command-line {w} {
    $w insert current [build-command-line]
}

proc cwtext-option-menu {w x y} {
    if { ! [winfo exists $w.m] } {
	menu $w.m -tearoff no
	$w.m add command -label {Stop sending} -command [list cwtext-stop-sending $w]
	$w.m add command -label {Clear window} -command [list $w clear]
	$w.m add separator
	$w.m add command -label {Send file} -command [list $w choose file]
	$w.m add separator
	$w.m add command -label {Font} -command [list $w choose font]
	$w.m add command -label {Background} -command [list $w choose background]
	$w.m add command -label {Sent Color} -command [list $w choose sentcolor]
	$w.m add command -label {Unsent Color} -command [list $w choose unsentcolor]
	$w.m add command -label {Skipped Color} -command [list $w choose skippedcolor]
    }
    if {0} {
	menu $w.m -tearoff no
	menu $w.m.s -tearoff no
	menu $w.m.r -tearoff no
	foreach m {0 1 2 3 4} {
	    $w.m.s add command -label "Mem $m" -command [list cwtext-store-memory-selection $m]
	    $w.m.r add command -label "Mem $m" -command [list cwtext-send-memory $m]
	}
	$w.m add command -label {Send Selection} -command [list cwtext-send-selection $w]
	$w.m add separator
	$w.m add cascade -label {Send Saved} -menu $w.m.r
	$w.m add cascade -label {Save Selection} -menu $w.m.s
	$w.m add separator
	$w.m add command -label {Send From File} -command [list cwtext-send-file $w]
	$w.m add command -label {Insert From File} -command [list cwtext-load-file $w]
	$w.m add command -label {Save To File} -command [list cwtext-save-file $w]
	$w.m add separator
	$w.m add command -label {Stop Sending} -command [list cwtext-stop-sending $w]
	$w.m add separator
	$w.m add command -label {Insert Command Line} -command [list cwtext-insert-command-line $w]
	$w.m add command -label {Help} -command [list cwtext-help $w]
    }
    tk_popup $w.m $x $y
}
proc cwtext-widget {w} {
    package require sdrtk::cwtext
    sdrtk::cwtext $w -width 30 -height 15 -exportselection true
    bind $w <ButtonPress-3> [list cwtext-option-menu $w %X %Y]
    bind $w <Escape> [list cwtext-stop-sending $w]
    set ::data(ascii-puts) {}
    cwtext-window-timeout $w
    return $w
}

#
# read only text widget, receiving decoded morse
#
package require morse::morse
package require morse::itu

proc read-text-window-timeout {w} {
    #$w insert end [morse-to-text [morse-itu-dict] [[get-detime] get]]
    $w insert end [[get-detime] get]\n
    after 100 [list read-text-window-timeout $w]
}
proc read-text-save-file {w} {
    set filename [tk_getSaveFile -title {Log to file}]
    if {$filename ne {}} {
	write-file $filename [$w get 1.0 end]
    }
}
proc read-text-option-menu {w x y} {
    if { ! [winfo exists $w.m] } {
	menu $w.m -tearoff no
	$w.m add command -label {Save To File} -command [list read-text-save-file $w]
	
    }
    tk_popup $w.m $x $y
}
proc read-text-widget {w} {
    text $w -width 30 -height 15 -exportselection true
    bind $w <ButtonPress-3> [list read-text-option-menu $w %X %Y]
    after 100 [list read-text-window-timeout $w]
    return $w
}

#
# midi tap text widget, receiving midi events for timing check
#

set ::tapframe 0
proc tap-window-timeout {w} {
    #$w insert end [morse-to-text [morse-itu-dict] [[get-detime] get]]
    if {[[get-tap] state]} {
	foreach event [[get-tap] get] {
	    foreach {frame midi} $event break
	    binary scan $midi c* bytes
	    set out [format {%ld %ld} $frame [expr {$frame-$::tapframe}]]
	    set ::tapframe $frame
	    foreach b $bytes {
		append out [format { %02x} [expr {$b&0xff}]]
	    }
	    $w insert end $out\n
	}	
    }
    after 100 [list tap-window-timeout $w]
}
proc tap-save-file {w} {
    set filename [tk_getSaveFile -title {Midi log to file}]
    if {$filename ne {}} {
	write-file $filename [$w get 1.0 end]
    }
}
proc tap-option-menu {w x y} {
    if { ! [winfo exists $w.m] } {
	menu $w.m -tearoff no
	$w.m add command -label {Save To File} -command [list tap-save-file $w]
	$w.m add command -label {Clear} -command [list $w delete 1.0 end]
	$w.m add command -label {Start} -command [list [get-tap] start]
	$w.m add command -label {Stop} -command [list [get-tap] stop]
	
    }
    tk_popup $w.m $x $y
}
proc tap-widget {w} {
    text $w -width 30 -height 15 -exportselection true
    bind $w <ButtonPress-3> [list tap-option-menu $w %X %Y]
    [get-tap] start
    after 100 [list tap-window-timeout $w]
    return $w
}

#
# load the entire ui for the program
#
proc load-ui {} {
    pack [keyer-widget .k] -side top -fill x -expand true
    pack [ttk::panedwindow .p] -side top -fill both -expand true
    .p add [::sdrtk::dialbook .p.dial]
    foreach {comp opt2 opt type value opts} $::data(options) {
	# if already processed, skip
	if {[info exists ::value($opt2)]} continue
	set ::value($opt2) $value
	set ::defval($opt2) $value
	lappend opts -value $value -variable ::value($opt2) -command [list dial-set $opt2]
	set w x$opt2
	switch $type {
	    enum { sdrtk::readout-enum .p.dial.$w {*}$opts }
	    freq { sdrtk::readout-freq .p.dial.$w {*}$opts }
	    value { sdrtk::readout-value .p.dial.$w {*}$opts }
	    default { error "unanticipated type \"$type\"" }
	}
	.p.dial add .p.dial.$w -text [.p.dial.$w cget -text]
    }
    if {[.p.dial select] eq {}} { .p.dial select 0 }
    set ::data(show-dial) 1
    # puts "current dialbook selection {[.p.dial select]} of {[.p.dial tabs]}"
    if {[has-insert]} { 
	.p add [insert-widget .p.insert]
	set ::data(show-insert) 1
	# add options for insert widget
    }
    # memories-widget
    if {[has-ascii]} {
	.p add [cwtext-widget .p.ascii]
	set ::data(show-ascii) 1
	# add options for cwtext widget
	# -sentcolor -unsentcolor -skippedcolor -background
    }
    if {[has-detime]} {
	.p add [read-text-widget .p.detime]
	set ::data(show-detime) 1
	# add options for read-text widget
	# -color1 -color2 -background
    }
    if {[has-tap]} {
	.p add [tap-widget .p.tap]
	set ::data(show-tap) 1
	# add options for tap widget
    }
}

proc build-command-line {} {
    set argv [file normalize $::script]
    if {[get-server] ne {}} { lappend argv -server [get-server] }
    foreach start [dict get $::data(main) -start] {
	lappend argv -start $start
    }
    # prefer specifically named options
    # to the ones that are only inferred from component inspection
    foreach opt [opt-get-opts] {
	if {$::value($opt) ne $::defval($opt)} {
	    lappend argv $opt $::value($opt)
	}
    }
    return [join $argv { }]
}

proc main {argv} {
    
    # initialize
    set ::data(main) [dict create -server {} options {}]
    
    # see what jack thinks we're doing
    package require sdrtcl::jack
    set bs [sdrtcl::jack buffer-size]; # samples per buffer
    set sr [sdrtcl::jack sample-rate]; # samples per second
    
    # ms-per-buffer = ($bs samples-per-buffer) * ((1000 ms-per-second) / ($sr samples-per-second))
    set mspbs [expr {$bs * 1000.0 / $sr}]
    
    dict set ::data(main) jack buffer-size $bs
    dict set ::data(main) jack sample-rate $sr
    dict set ::data(main) jack ms-per-buffer $mspbs
    # puts "$mspbs ms per buffer"
    
    # style, abolish invisible indicators
    ttk::style configure "." -indicatordiameter 12
    ttk::style configure TCheckbutton -relief raised
    ttk::style configure TRadiobutton -relief raised
    
    # make a usage message
    if {$argv eq {} || $argv eq {help}} {
	set usage {
usage: keyer ?-start module ...? ?-option value ...?

module can be any string which uniquely specifies a package
in ~/keyer/lib/sdrtcl/pkgIndex.tcl, optionally followed by
@name to indicate that 'name' should be used as the jack
client name for the module.

option can be any option that any of the modules started
defines.

-hide '-option ...' options to be hidden in the user 
-prefer '-option ...' options to be listed first in the user interface
-title 'short string' title to be displayed in window title bar
}
	puts $usage
	# tk_messageBox -message $usage -type ok
	# destroy .
	exit 1
    }
    
    # process arguments
    foreach {opt val} $argv {
	switch -- $opt {
	    -server { set-var $opt $val }
	    -title { set-title $val }
	    -prefer { set-prefer $val }
	    -hide { set-hide $val }
	    -start {
		# start a component
		foreach {component name2} [load-component $val] break
		# remember its parts
		lappend-start $val
		component-define $name2
		# remember if this is special
		switch -glob $component {
		    keyer-ascii { set-ascii $name2 }
		    keyer-detime { set-detime $name2 }
		    midi-insert { set-insert $name2 }
		    midi-tap { set-tap $name2 }
		}
		# load its options
		populate-component-options $component $name2
	    }
	    default {
		# save command line options until everything loads
		set parts [split [string trim $opt -] -]
		if {[opt-is-defined $opt] || [llength $parts] < 2} {
		    lappend-argvopts $opt $val; # save option
		    continue
		}
		# find a prefixed component name, if any
		foreach {name option1 option2} $parts break
		if {[component-is-defined $name] } {
		    if {[llength $parts] == 2 && [opt-is-defined -$option1]} {
			# -component-option: explicit component option
			populate-option $name $opt {*}[$name configure -$option1]
		    } elseif {[llength $parts] == 3 && [opt-is-defined -$option1] && [opt-is-defined -$option2]} {
			# -component-option1-option2: explicit component joined option
			populate-option $name $opt {*}[$name configure -$option1]
			populate-option $name $opt {*}[$name configure -$option2]
		    }
		    lappend-argvopts $opt $val; # save option
		} else {
		    foreach {option1 option2} $parts break
		    if {[llength $parts] == 2 && [opt-is-defined -$option1] && [opt-is-defined -$option2]} {
			# -option1-option2: joined option
			# iterate over components with both options
			foreach name [find-components -$option1 -$option2] {
			    populate-option $name $opt {*}[$name configure -$option1]
			    populate-option $name $opt {*}[$name configure -$option2]
			}
		    }
		    lappend-argvopts $opt $val; # save option
		}
	    }
	}
    }

    # sort the preferred options to the top
    if {[has-prefer]} {
	prefer-component-options [get-prefer]
    } else {
	prefer-component-options {-wpm -swap -mode -freq -gain -rise -fall -window -window2}
    }
    # disappear options of no interest
    if {[has-hide]} {
	hide-component-options [get-hide]
    } else {
	hide-component-options {-alsp -awsp -dit -dah -ies -ils -iws -word}
    }
    
    # initialize the dial-set timer
    dial-set-init
	
    # build the ui with the extracted options
    load-ui
	
    # load the options collected from the command line
    if {[has-argvopts]} {
	foreach {opt val} [get-argvopts] { 
	    if {[catch {dial-set $opt $val} error]} {
		puts "bad option: $opt $val"
	    }
	}
    }
	
    # install application icon
    set dir [file join $::dirname .. icons]
    image create photo icon1 -file [file join $dir qrv96.png]
    image create photo icon2 -file [file join $dir qrv48.png]
    wm iconphoto . -default icon1 icon2
}

main $argv
