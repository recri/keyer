#!/usr/bin/wish8.6
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# Copyright (C) 2018 by Roger E Critchlow Jr, Charlestown, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [info script]
set dirname [file dirname $script]

#
# append the ../lib directory to the Tcl search path
#
lappend auto_path [file join $dirname .. lib]

#
# find the list of sdrtcl::*
#
set packages [exec grep sdrtcl:: [file join $dirname .. lib sdrtcl pkgIndex.tcl] | awk {{print $3}} | sed -e s/sdrtcl:://g]

#
# will need this to implement -uuid
#
package require sdrtcl::jack-client

#
# utilities
#
proc read-file {file} {
    set fp [open $file r]
    set data [read $fp]
    close $fp
    return $data
}
proc write-file {file data} {
    set fp [open $file w]
    puts -nonewline $fp $data
    close $fp
}

#
# miscellaneous accessors
#
proc get-var {var} { return [dict get $::data(main) $var] }
proc set-var {var val} { return [dict set ::data(main) $var $val] }
proc has-var {var} { return [dict exists $::data(main) $var] }
proc lappend-var {var args} { dict lappend ::data(main) $var {*}$args }
proc get-server {} { return [get-var -server] }
proc get-uuid {} { return [get-var -uuid] }
proc has-dial {} { return 1 }
proc get-keyer {} { return [get-var -keyer] }
proc set-keyer {name} { set-var -keyer $name }
proc has-keyer {} { return [has-var -keyer] }
proc get-ascii {} { return [get-var -ascii] }
proc set-ascii {name} { set-var -ascii $name }
proc has-ascii {} { return [has-var -ascii] }
proc has-memories {} { return 0 }
proc get-detime {} { return [get-var -detime] }
proc set-detime {name} { set-var -detime $name }
proc has-detime {} { return [has-var -detime] }
proc get-insert {} { return [get-var -insert] }
proc set-insert {name} { set-var -insert $name }
proc has-insert {} { return [has-var -insert] }
proc lappend-argvopts {args} { lappend-var -argvopts {*}$args }
proc has-argvopts {} { return [has-var -argvopts] }
proc get-argvopts {} { return [get-var -argvopts] }
proc get-title {} { return [get-var -title] }
proc set-title {name} { set-var -title $name }
proc has-title {} { return [has-var -title] }

# load an sdrtcl component
# name is name1 or a name1@name2
# name1 specifies the sdrtcl component
# and name2 specifies the jack client name to use for it
# name2 defaults to name1
# name1 can be any string which uniquely identifies an sdrtcl component
# ambiguous ones throw an error with the list that matched
# 
proc sdrtcl-instance {component name2} {
    set args {}
    set server [get-server]
    set uuid [get-uuid]
    if {$server ne {}} { lappend args -server $server }
    if {$uuid ne {}} { lappend args -uuid $uuid }
    $component $name2 {*}$args
}

proc load-component {name} {
    # name1 identifies the sdrtcl component
    # name2 is the jack client name
    set name1 $name
    set name2 $name
    if {[llength [split $name @]] == 2} {
	foreach {name1 name2} [split $name @] break
    }
    # search through the sdrtcl component list
    # for components which match name1
    set candidates {}
    foreach c $::packages {
	if {[string equal $name1 $c]} {
	    set candidates [list $c]
	    break
	} elseif {[string match *$name1* $c]} {
	    lappend candidates $c
	}
    }
    if {[llength $candidates] == 0} { error "no match for component '$name'" }
    if {[llength $candidates] > 1} { error "too many matches for component '$name', '[join $candidates {, }]'" }
    # we found one candidate
    set component [lindex $candidates 0]
    # load the implementation
    package require sdrtcl::$component
    # instantiate component
    sdrtcl-instance sdrtcl::$component $name2
    # activate component
    $name2 activate
    # remember this
    return [list $component $name2]
}

# user interface components
package require sdrtk::dialbook
package require sdrtk::readout-enum
package require sdrtk::readout-freq
package require sdrtk::readout-value
package require sdrtk::vtext

set data(options) {}

proc get-window-types {} {
    package require sdrtcl::window
    catch { sdrtcl::window foo 512 } error
    regexp {^unknown window type, should be one of (.*)$} $error all error
    regsub -all {, (or )?} $error { } error
    set error [lsort $error]
    set i [lsearch $error {none}]
    if {$i >= 0} {
	set error [concat none [lreplace $error $i $i]]
    }
    return $error
}

# all components in the app share values for identically spelled options
set ::data(defines) [dict create]
array set ::value {}
array set ::defval {}
proc opt-is-defined {opt} { return [dict exists $::data(defines) $opt] }
proc opt-define {opt comp} { dict lappend ::data(defines) $opt $comp }
proc opt-add-dependent {opt comp} { dict lappend ::data(defines) $opt $comp }
proc opt-components {opt} { return [dict get $::data(defines) $opt] }
proc opt-primary {opt} { return [lindex [opt-components $opt] 0] }
proc opt-get-opts {} { return [dict keys $::data(defines)] }

proc populate-component-options {component name} {
    foreach config [$name configure] {
	foreach {opt oname oclass odefault ovalue} $config break
	set info [$name info option $opt]
	
	dict set ::data(default) $opt $odefault
	# note: opt is the option name in configure and cget commands
	# oname is the option name in the option database (not used here)
	# oclass is the option class name in the option database
	# odefault is the default value
	# ovalue is the current value

	switch -- $opt {
	    -server - -client - -uuid - -verbose {
		# these are fixed, as in not modifiable
		continue 
	    }
	    -chan {
		lappend ::data(options) $name $opt value $ovalue \
		    [list -text $opt -info $info -format %.0f -min 1 -max 16 -step 1]
	    }
	    -note {
		lappend ::data(options) $name $opt value $ovalue \
		    [list -text $opt -info $info -format %.0f -min 0 -max 127 -step 1]
	    }
	    -wpm {
		lappend ::data(options) $name $opt value $ovalue \
		    [list -text $opt -info $info -format %.1f -units wpm -min 5.0 -max 200.0 -step 0.5]
	    }
	    -swap - -mdit - -mdah - -mide - -alsp - -awsp {
		lappend ::data(options) $name $opt enum $ovalue [list -text $opt -info $info -values {0 1}]
	    }
	    -mode {
		lappend ::data(options) $name $opt enum $ovalue [list -text $opt -info $info -values {A B}]
	    }
	    -word {
		lappend ::data(options) $name $opt enum $ovalue [list -text $opt -info $info -units dits -values {50 60}]
	    }
	    -dah - -ies - -ils - -iws { 
		set min [expr {0.5*$ovalue}]
		set max [expr {1.5*$ovalue}]
		lappend ::data(options) $name $opt value $ovalue \
		    [list -text $opt -info $info -format %.1f -units dits -min $min -max $max -step 0.1]
		continue
	    }
	    -weight {
		lappend ::data(options) $name $opt value $ovalue \
		    [list -text $opt -info $info -format %.0f -units percent -min 25 -max 75 -step 1]
		continue
	    }
	    -freq {
		lappend ::data(options) $name $opt freq $ovalue \
		    [list -text $opt -info $info -units Hz -format %.0f -min 500 -max 1500 -step 1]
	    }
	    -rise - -fall {
		lappend ::data(options) $name $opt value $ovalue \
		    [list -text $opt -info $info -units ms -format %.1f -min 0.1 -max 10.0 -step 0.1]
	    }
	    -window {
		lappend ::data(options) $name $opt enum $ovalue \
		    [list -text $opt -info $info -values [lrange [get-window-types] 1 end]]
	    }
	    -window2 {
		lappend ::data(options) $name $opt enum $ovalue \
		    [list -text $opt -info $info -values [get-window-types]]
	    }
	    -gain {
		lappend ::data(options) $name $opt value $ovalue \
		    [list -text $opt -info $info -units dB -format %.1f -min -50 -max 0 -step 0.1]
	    }
	    -delay {
		lappend ::data(options) $name $opt value $ovalue \
		    [list -text $opt -info $info -units ms -format %.2f -min 0.0 -max 1000 -step 0.01]
	    }
	    -hang {
		lappend ::data(options) $name $opt value $ovalue \
		    [list -text $opt -info $info -units ms -format %.1f -min 0.0 -max 1000 -step 0.1]
	    }
	    -period {
		# for the debouncer
	    }
	    -steps {
		# for the debouncer
	    }
	    -dict {
		# for the ascii keyer
	    }
	    -bandwidth {
		# for the unkeyer detone module
		# bandwidth BWHertz 100.0 100.0 bandwidth of output signal in Hz
		lappend ::data(options) $name $opt freq $ovalue \
		    [list -text $opt -info $info -units Hz -format %.0f -min 10 -max 1000 -step 1]
	    }
	    default {
		puts "$name $config [$name info option $opt]"
	    }
	}
    }
}

# sort the options so the most used are first
proc prefer-component-options {{prefs {-wpm -swap -mode -freq -gain -rise -fall -window -window2}}} {
    set options $::data(options)
    set ::data(options) {}
    foreach {comp opt type value opts} $options {
	if {[lsearch $prefs $opt] >= 0} {
	    lappend ::data(options) $comp $opt $type $value $opts
	}
    }
    foreach {comp opt type value opts} $options {
	if {[lsearch $prefs $opt] < 0} {
	    lappend ::data(options) $comp $opt $type $value $opts
	}
    }
}

#
# control window.
# this one line frame controls which other windows are displayed
# and acts as a focus target for controlling the keyer while 
# minimized.
#
proc keyer-widget {w} {
    ttk::frame $w
    foreach {tag text} {
	dial Settings
	insert Keys
	memories Memories
	ascii {Input Text}
	detime {Output Text}
    } {
	if {[has-$tag]} {
	    ttk::checkbutton $w.$tag -text $text -variable ::data(show-$tag) -command [list keyer-widget-show $w $tag]
	    pack $w.$tag -side left
	}
    }
    return $w
}
proc keyer-widget-show {w tag} {
    if {$::data(show-$tag)} {
	.p add .p.$tag
    } else {
	.p forget .p.$tag
    }
}
#
# dial setting
#
proc dial-set {opt val} {
    if {[opt-is-defined $opt]} {
	set ::value($opt) $val
	foreach comp [opt-components $opt] {
	    dict set ::data(busy) $comp $opt $val
	    if { ! [$comp is-busy]} {
		set opts [dict get $::data(busy) $comp]
		if {[catch {
		    $comp configure {*}$opts
		    set ::data(busy) [dict unset ::data(busy) $comp]
		} error]} {
		    puts "dial-set configure $opts threw $error"
		}
	    } else {
		# puts "$comp is-busy"
	    }
	}
    } else {
	error "$opt is not defined in dial-set"
    }
}

proc dial-set-timeout {} {
    dict for {comp opts} $::data(busy) {
	if { ! [$comp is-busy]} {
	    if {[catch {
		$comp configure {*}$opts
		set ::data(busy) [dict unset $::data(busy) $comp]
	    } error]} {
		puts "dial-set configure $opts threw $error"
	    }
	} else {
	    # puts "$comp is-busy"
	}
    }
    if {[info exists ::value(-wpm)] && [info exists ::value(-window2)]} {
	if {$::value(-window2) ne {none}} {
	    set title "keyer $::value(-wpm) wpm $::value(-window)*$::value(-window2)"
	} else {
	    set title "keyer $::value(-wpm) wpm $::value(-window)"
	}
    } elseif {[info exists ::value(-freq)] && [info exists ::value(-window2)]} {
	if {$::value(-window2) ne {none}} {
	    set title "keyer $::value(-freq) Hz $::value(-window)*$::value(-window2)"
	} else {
	    set title "keyer $::value(-freq) Hz $::value(-window)"
	}
    } else {
	set title "keyer"
    }
    if { ! [has-title] || [get-title] ne $title} {
	wm title . $title
	set-title $title
    }
    after 100 dial-set-timeout
}

proc dial-set-init {} {
    set ::data(busy) [dict create]
    dial-set-timeout
}

#
# insert window management
# a simple frame which, when focused, generates key events
# for control, alt, and shift keys
#
proc insert-widget {w} {
    ttk::frame $w
    grid [ttk::menubutton $w.dit -text Dit -menu $w.dit.m] -row 0 -column 0 -sticky ew
    menu $w.dit.m -tearoff no
    $w.dit.m add checkbutton -label {Send Dits} -variable ::data(insert-send-dits) -command [list insert-send $w dit]
    grid [ttk::menubutton $w.dah -text Dah -menu $w.dah.m] -row 0 -column 1 -sticky ew
    menu $w.dah.m -tearoff no
    $w.dit.m add checkbutton -label {Send Dahs} -variable ::data(insert-send-dahs) -command [list insert-send $w dah]
    grid [ttk::menubutton $w.key -text Key -menu $w.key.m] -row 0 -column 2 -sticky ew
    menu $w.key.m -tearoff no
    $w.key.m add checkbutton -label {Key Down} -variable ::data(insert-send-key) -command [list insert-send $w key]
    insert-widget-bind $w Shift_R key
    insert-widget-bind $w Alt_R dit
    insert-widget-bind $w Control_R dah
    return $w
}
proc insert-widget-bind {w tag element} {
    bind $w <KeyPress-$tag> [insert-key $w $element down]
    bind $w <KeyRelease-$tag> [insert-key $w $element up]
}
proc insert-send {w element} {
}
proc insert-key {w element updown} {
    switch $element {
	dit { set note 0 }
	dah { set note 1 }
	key { set note 2 }
	default { error "insert-key $w ??$element?? $updown" }
    }
    switch $updown {
	up { set cmd 0x80;	#define MIDI_NOTE_OFF
	}
	down { set cmd 0x90;	#define MIDI_NOTE_ON
	}
	default { error "insert-key $w $element ??$updown??" } 
    }
    puts "insert $cmd $::value(-chan) $::value(-note)+$note 127"
    [get-insert] puts [binary format ccc [expr {$cmd|($::value(-chan)-1)}] [expr {$::value(-note)+$note}] 127]
}
#
# text window management
# text window is for preparing text to send to the ascii-keyer
# could also be used to present the output from the manual key
# or cw decoded from audio.
#
proc text-window-timeout {w} {
    # I'm seeing available taking 50-60 units per character sent
    if {$::data(ascii-puts) ne {} && [[get-ascii] available] > 8192/2} {
	set text [string range $::data(ascii-puts) 0 39]
	set ::data(ascii-puts) [string range $::data(ascii-puts) 40 end]
	[get-ascii] puts [string toupper $text]
    }
    after 100 [list text-window-timeout $w]
}
proc text-send {w text} {
    append ::data(ascii-puts) $text
}
proc text-stop-sending {w} {
    set ::data(ascii-puts) {}
    [get-ascii] abort
}
proc text-store-memory-selection {m} {
    dict set ::data(memory) $m [selection get]
}
proc text-send-memory {m} {
    text-send $w [dict get $::data(memory) $m]
}
proc text-send-selection {w} {
    text-send $w [selection get]
}
proc text-load-file {w} {
    set filename [tk_getOpenFile -title {Insert from file}]
    if {$filename ne {}} {
	$w insert current [read-file $filename]
    }
}
proc text-send-file {w} {
    set filename [tk_getOpenFile -title {Send from file}]
    if {$filename ne {}} { text-send $w [read-file $filename] }
}
proc text-save-file {w} {
    set filename [tk_getSaveFile -title {Save to file}]
    if {$filename ne {}} { write-file $filename [$w get 1.0 end] }
}
proc text-insert-command-line {w} {
    $w insert current [build-command-line]
}
proc text-send-line {w} {
    set i0 [$w index {current linestart}]
    set i1 [$w index current]
    text-send $w [$w get $i0 $i1]
}
proc text-option-menu {w x y} {
    if { ! [winfo exists $w.m] } {
	menu $w.m -tearoff no
	menu $w.m.s -tearoff no
	menu $w.m.r -tearoff no
	foreach m {0 1 2 3 4} {
	    $w.m.s add command -label "Mem $m" -command [list text-store-memory-selection $m]
	    $w.m.r add command -label "Mem $m" -command [list text-send-memory $m]
	}
	$w.m add command -label {Send Selection} -command [list text-send-selection $w]
	$w.m add separator
	$w.m add cascade -label {Send Saved} -menu $w.m.r
	$w.m add cascade -label {Save Selection} -menu $w.m.s
	$w.m add separator
	$w.m add command -label {Send From File} -command [list text-send-file $w]
	$w.m add command -label {Insert From File} -command [list text-load-file $w]
	$w.m add command -label {Save To File} -command [list text-save-file $w]
	$w.m add separator
	$w.m add command -label {Stop Sending} -command [list text-stop-sending $w]
	$w.m add separator
	$w.m add command -label {Insert Command Line} -command [list text-insert-command-line $w]
	$w.m add command -label {Help} -command [list text-help $w]
    }
    tk_popup $w.m $x $y
}
proc text-widget {w} {
    text $w -width 30 -height 15 -undo true -exportselection true
    bind $w <ButtonPress-3> [list text-option-menu $w %X %Y]
    bind $w <Key-Return> +[list text-send-line $w]
    set ::data(ascii-puts) {}
    text-window-timeout $w
    return $w
}
proc text-help {w} {
    foreach tag [bind $w] {
	puts "$tag [bind $w $tag]"
    }
    foreach tag [bind Text]] {
	puts "$tag [bind Text $tag]"
    }
}

#
# read only text widget, receiving decoded morse
#
package require morse::morse
package require morse::itu

proc read-text-window-timeout {w} {
    #$w insert end [morse-to-text [morse-itu-dict] [[get-detime] get]]
    $w insert end [[get-detime] get]\n
    after 100 [list read-text-window-timeout $w]
}
proc read-text-save-file {w dolog} {
    set filename [tk_getSaveFile -title {Log to file}]
    if {$filename ne {}} {
	write-file $filename [$w get 1.0 end]
    }
}
proc read-text-option-menu {w x y} {
    if { ! [winfo exists $w.m] } {
	menu $w.m -tearoff no
	$w.m add command -label {Save To File} -command [list read-text-save-file $w]
	
    }
    tk_popup $w.m $x $y
}
proc read-text-widget {w} {
    text $w -width 30 -height 15 -exportselection true
    bind $w <ButtonPress-3> [list read-text-option-menu $w %X %Y]
    after 100 [list read-text-window-timeout $w]
    return $w
}

#
# load the entire ui for the program
#
proc load-ui {} {
    pack [keyer-widget .k] -side top -fill x -expand true
    pack [ttk::panedwindow .p] -side top -fill both -expand true
    .p add [::sdrtk::dialbook .p.dial]
    foreach {comp opt type value opts} $::data(options) {
	# only keep the first of a series of definitions for the same $opt
	if {[opt-is-defined $opt]} {
	    # this is not the first appearance, daisy chain from the first
	    opt-add-dependent $opt $comp
	    continue
	}
	# this is the first appearance of this $opt
	opt-define $opt $comp
	set ::value($opt) $value
	set ::defval($opt) $value
	lappend opts -value $value -variable ::value($opt) -command [list dial-set $opt]
	set w x$opt
	switch $type {
	    enum { sdrtk::readout-enum .p.dial.$w {*}$opts }
	    freq { sdrtk::readout-freq .p.dial.$w {*}$opts }
	    value { sdrtk::readout-value .p.dial.$w {*}$opts }
	    default { error "unanticipated type \"$type\"" }
	}
	.p.dial add .p.dial.$w -text [.p.dial.$w cget -text]
    }
    if {[.p.dial select] eq {}} { .p.dial select 0 }
    set ::data(show-dial) 1
    # puts "current dialbook selection {[.p.dial select]} of {[.p.dial tabs]}"
    if {[has-insert]} { 
	.p add [insert-widget .p.insert]
	set ::data(show-insert) 1
    }
    # memories-widget
    if {[has-ascii]} {
	.p add [text-widget .p.ascii]
	set ::data(show-ascii) 1
    }
    if {[has-detime]} {
	.p add [read-text-widget .p.detime]
	set ::data(show-detime) 1
    }
}

proc build-command-line {} {
    set argv [file normalize $::script]
    if {[get-server] ne {}} { lappend argv -server [get-server] }
    if {[get-uuid] ne {}} { lappend argv -uuid [get-uuid] }
    foreach start [dict get $::data(main) -start] {
	lappend argv -start $start
    }
    foreach opt [opt-get-opts] {
	if {$::value($opt) ne $::defval($opt)} {
	    lappend argv $opt $::value($opt)
	}
    }
    return [join $argv { }]
}

proc session-event-poll {} {
    set result [jack session-poll]
    if {$result ne {}} {
	puts $result
    }
    after 100 session-event-poll
}

proc main {argv} {
    # initialize
    set ::data(main) [dict create -server {} -uuid {} options {}]

    # style, abolish invisible indicators
    ttk::style configure "." -indicatordiameter 12
    ttk::style configure TCheckbutton -relief raised
    ttk::style configure TRadiobutton -relief raised
    
    # make a usage message
    if {$argv eq {} || $argv eq {help}} {
    }

    # process arguments
    foreach {opt val} $argv {
	switch -- $opt {
	    -server {
		dict set ::data(main) $opt $val;	# select jack server
	    }
	    -uuid {
		dict set ::data(main) $opt $val;	# identify saved jack client
	    }
	    -start {
		# start the jack client machinery just once
		if {[info command jack] eq {}} {
		    sdrtcl-instance sdrtcl::jack-client jack
		    jack session-register
		    session-event-poll
		}
		# start a component
		foreach {component name2} [load-component $val] break
		# remember its parts
		dict lappend ::data(main) -start $val
		# remember if this is special
		switch -glob $component {
		    keyer-iambic-* { set-keyer $name2 }
		    keyer-ascii { set-ascii $name2 }
		    keyer-detime { set-detime $name2 }
		    midi-insert { set-insert $name2 }
		}
		# load its options
		populate-component-options $component $name2
	    }
	    default {
		# save command line options until everything loads
		lappend-var -argvopts $opt $val; # save options
	    }
	}
    }
    
    # sort the preferred options to the top
    prefer-component-options

    # initialize the dial-set timer
    dial-set-init
    
    # build the ui with the extracted options
    load-ui
    
    # load the dial-set dependent options
    
    # load the options collected from the command line
    if {[has-argvopts]} {
	foreach {opt val} [get-argvopts] { 
	    dial-set $opt $val
	}
    }
    
    # install application icon
    set dir [file join [file dirname [info script]] .. icons]
    image create photo icon1 -file [file join $dir qrv96.png]
    image create photo icon2 -file [file join $dir qrv48.png]
    wm iconphoto . -default icon1 icon2
}

main $argv

