#!/usr/bin/wish8.6
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# Copyright (C) 2018 by Roger E Critchlow Jr, Charlestown, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

# this is the mega-keyer script
# start arbitrary collections of sdrtcl components
# wire up their options into a dialbook
# hide, merge, or fuse options
# save the result as a preset command for later access
#

#
# use the script location to find the rest of the libraries
#
set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
set dirname [file dirname $script]

#
# append the ../lib directory to the Tcl search path
#
lappend auto_path [file join $dirname .. lib]

# initialize data variables
set ::data(main) [dict create -server {} -favor {} -hide {} -merge {} -argvopts {} -volatile {} -packages {}]

#
# miscellaneous accessors
# global names stored in dict as dict set ::data(main) $name $val
#
proc get-var {var} { return [dict get $::data(main) $var] }
proc has-var {var} { return [dict exists $::data(main) $var] }
proc set-var {var val} { return [dict set ::data(main) $var $val] }
proc lappend-var {var args} { dict lappend ::data(main) $var {*}$args }

# setups are macros defining component instances
proc has-setups {} { return [has-var -setups] }
proc get-setups {} { return [get-var -setups] }
proc set-setups {val} { set-var -setups $val }
proc add-setup {name val} {
    set old [get-setups]
    dict set old $name $val
    set-setups $old
}
proc get-setup {name} { return [dict get [get-setups] $name] }

# these are options and groups of options collected from argv
proc get-server {} { return [get-var -server] }
proc has-server {} { return [has-var -server] }
proc set-server {val} { set-var -server $val }
proc get-iambic {} { return [get-var -iambic] }
proc has-iambic {} { return [has-var -iambic] }
proc set-iambic {val} { set-var -iambic $val }
proc get-title {} { return [get-var -title] }
proc has-title {} { return [has-var -title] }
proc set-title {val} { set-var -title $val }
proc get-grid {} { return [get-var -grid] }
proc has-grid {} { return [has-var -grid] }
proc set-grid {val} { set-var -grid $val }
proc get-tree {} { return [get-var -tree] }
proc has-tree {} { return [has-var -tree] }
proc set-tree {val} { set-var -tree $val }

proc get-start {} { return [get-var -start] }
proc has-start {} { return [has-var -start] }
proc lappend-start {args} { lappend-var -start {*}$args }
proc get-argvopts {} { return [get-var -argvopts] }
proc has-argvopts {} { return [has-var -argvopts] }
proc lappend-argvopts {args} { lappend-var -argvopts {*}$args }
proc get-merge {} { return [get-var -merge] }
proc has-merge {} { return [has-var -merge] }
proc lappend-merge {args} { lappend-var -merge {*}$args }
proc get-favor {} { return [get-var -favor] }
proc has-favor {} { return [has-var -favor] }
proc lappend-favor {args} { lappend-var -favor {*}$args }
proc get-hide {} { return [get-var -hide] }
proc has-hide {} { return [has-var -hide] }
proc lappend-hide {args} { lappend-var -hide {*}$args }
proc set-volatile {val} { set-var -volatile $val }
proc get-volatile {} { return [get-var -volatile] }
proc lappend-volatile {args} { lappend-var -volatile {*}$args }
proc set-packages {val} { set-var -packages $val }
proc get-packages {} { return [get-var -packages] }
proc lappend-packages {args} { lappend-var -packages {*}$args }

#
# utilities
#
proc read-file {file} {
    set fp [open $file r]
    set data [read $fp]
    close $fp
    return $data
}
proc write-file {file data} {
    set fp [open $file w]
    puts -nonewline $fp $data
    close $fp
}

#
# find the list of sdrtcl::*, sdrtk::*, and sdrtcltk::* packages
#
foreach lib {sdrtcl sdrtk sdrtcltk} {
    set pkgIndex [file join $::dirname .. lib $lib pkgIndex.tcl]
    set pfp [open $pkgIndex r]
    foreach line [split [string trim [read-file $pkgIndex]] \n] {
	if {[regexp "${lib}::" $line]} {
	    lappend-packages [lindex $line 2]
	}
    }
}

#
# manage option preferences
# some of these match patterns in the lists
# some just match instances in the lists
#
proc the-match {opt list} {
    foreach pat $list { if {[string match $pat $opt]} { return $pat } }
    return {}
}
proc is-matched {opt list} { return [expr {[the-match $opt $list] ne {}}] }

proc the-favor {o} { return [the-match $o [get-favor]] }
proc is-favor {o} { return [is-matched $o [get-favor]] }
proc the-hide {o} { return [the-match $o [get-hide]] }
proc is-hide {o} { return [is-matched $o [get-hide]] }
proc the-merge {o} { return [the-match $o [get-merge]] }
proc is-merge {o} { return [is-matched $o [get-merge]] }
proc the-argvopts {o} { return [the-match $o [get-argvopts]] }
proc is-argvopts {o} { return [is-matched $o [get-argvopts]] }


# options are created in component specific versions -$name$opt
# or as merged versions where all identically spelled options
# are set as a group

set ::data(all-options) [dict create];	# qualified option names
array set ::value {};			# updated whenever option is configured

proc opt-is-defined {opt} { return [dict exists $::data(all-options) $opt] }
proc opt-is-described {opt} { return [expr {[opt-is-defined $opt] && [opt-get $opt described]}] }
proc opt-get {opt key} { return [dict get $::data(all-options) $opt $key] }
proc opt-set {opt key val} { dict set ::data(all-options) $opt $key $val }
proc opt-get-dict {opt} { return [dict get $::data(all-options) $opt] }

proc opt-is-ronly {opt} { return [opt-get $opt ronly] }
proc opt-is-conly {opt} { return [opt-get $opt conly] }
proc opt-is-favor {opt} { return [opt-get $opt favor] }
proc opt-is-hide {opt} { return [opt-get $opt hide] }
proc opt-is-volatile {opt} { return [opt-get $opt volatile] }

proc opt-get-value {opt} { return [opt-get $opt cvalue] }
proc opt-get-default {opt} { return [opt-get $opt cdefault] }
proc opt-set-value {opt val} { return [opt-set $opt cvalue $val] }

proc opt-component-opts {opt} {
    set d [dict get $::data(all-options) $opt]
    set w [dict get $d window]
    if {$w ne {}} { return [list $w [dict get $d opt]] }
    return [list [dict get $d name] [dict get $d opt]]
}

proc opt-get-opts {} { return [dict keys $::data(all-options)] }

proc opt-describe {dict type args} { 
    dict set dict type $type
    dict set dict described 1
    dict set dict readout {}
    foreach {key val} $args {
	if {[string index $key 0] eq {-}} {
	    dict lappend dict readout $key $val
	} else {
	    dict set dict $key $val
	}
    }
    dict set ::data(all-options) [dict get $dict text] $dict
}

proc opts-with-descriptions {} { return [dict keys $::data(all-options)] }
proc opt-description {opt} { return [dict get $::data(all-options) $opt] }

#proc composite-is-defined {comp} { return [dict exists $::data(composites) $comp] }
proc composite-define {name factory window composite} { dict set ::data(composites) $name [dict create name $name factory $factory window $window composite $composite]}
#proc composites {} { return [dict keys $::data(composites)] }

proc composite-parse {composite} {
    # first part identifies the sdrtcl component
    # second part is the jack client name
    if {[llength [split $composite @]] == 2} {
	return [concat $composite [split $composite @]]
    } else {
	return [list $composite $composite $composite]
    }
}

proc composite-load {composite} {
    # parse the composite into parts
    foreach {composite factory name} [composite-parse $composite] break
    # puts "composite-load $composite $factory $name"

    # special case insert selected iambic keyer
    # should just make the iambic keyer a selected option in the keyer
    if {$factory eq {iambic} && [has-iambic]} { set factory [get-iambic] }

    # search through the sdrtcl/sdrtk/sdrtcltk component list
    # for components which match $factory
    # exact match to tail of name first, then with glob on tail
    set candidates [lsearch -all -inline [get-packages] *$factory]
    if {[llength $candidates] == 0} {
	set candidates [lsearch -all -inline [get-packages] *$factory*]
    }
    if {[llength $candidates] == 0} { error "no match for component '$composite'" }
    if {[llength $candidates] > 1} { 
	error "too many matches for component '$composite', '[join $candidates {, }]'"
    }
    # we found one candidate
    set factory [lindex $candidates 0]
    # load the implementation
    package require $factory
    # instantiate component
    # and activate if necessary
    set args {}
    if {[get-server] ne {}} {
	# puts "[get-server] is {[get-server]}"
	lappend args -server [get-server]
    }
    switch -glob $factory {
	sdrtcl::* { 
	    set window {}
	    $factory $name {*}$args
	    $name activate
	}
	sdrtk::* { 
	    toplevel .$name
	    wm title .$name "keyer/$name"
	    set window .$name.$name
	    # no  {*}$args because it's only sdrtcl -server
	    pack [$factory $window] -side top -expand true -fill both
	}
	sdrtcltk::* {
	    toplevel .$name
	    wm title .$name "keyer/$name"
	    set window .$name.$name
	    pack [$factory $window {*}$args] -side top -expand true -fill both
	    $window activate
	}
	default { error "$factory did not match switch" }
    }
    # remember this
    return [list $name $factory $window $composite]
}

# user interface components
# primary user interface component is the dialbook
# which isn't finished.

package require snit
namespace eval ::sdrtk {}
package require sdrtk::dialbook

# these are filter/fft windowing functions
package require sdrtcl::window
proc get-window-types {} {
    catch { sdrtcl::window foo 512 } error
    regexp {^unknown window type, should be one of (.*)$} $error all error
    regsub -all {, (or )?} $error { } error
    set error [lsort $error]
    set i [lsearch $error {none}]
    if {$i >= 0} {
	set error [concat none [lreplace $error $i $i]]
    }
    return $error
}

# these are morse code dictionaries
package require morse::dicts
proc get-morse-dicts {} {
    return [concat {builtin} [morse-dicts]]
}

# add any special sauce appropriate to a particular option
proc populate-option {name opt option} {
    # puts "populate-option $name $opt $option"
    # look for further guidance
    
    switch -glob -- [list [dict get $option factory] $opt] {
	{* -server} - 
	{* -client} { opt-describe $option text ronly 1 hide 1 conly 1 -graticule 1 }
	{* -verbose} { opt-describe $option ivalue ronly 1 hide 1 conly 1 -min 0 -max 10 -graticule 12 -steps-per-div 1 }
	{* -chan} { opt-describe $option ivalue -min 1 -max 16 -graticule 12 -steps-per-div 1 }
	{* -note} { opt-describe $option ivalue -min 0 -max 127 -graticule 12 -steps-per-div 1 }
	{* -wpm} { opt-describe $option value -format %.1f -units wpm -min 5.0 -max 120.0 -step 0.5 -graticule 20 -steps-per-div 10 }
	{* -swap} - 
	{* -mdit} - 
	{* -mdah} - 
	{* -mide} - 
	{* -alsp} - 
	{* -awsp} { opt-describe $option bool }
	{* -mode} { opt-describe $option enum -values {A B} }
	{* -word} { opt-describe $option enum -values {50 60} -units dits }
	{*keyer* -dit} - 
	{*keyer* -dah} - 
	{* -ies} - 
	{* -ils} - 
	{* -iws} { 
	    set cdefault [dict get $option cdefault]
	    set min [expr {$cdefault-0.5}]
	    set max [expr {$cdefault+0.5}]
	    opt-describe $option value -format %.1f -min $min -max $max -step 0.1 -units dits
	    #puts "opt-describe $name $opt -value $cvalue -min $min -max $max -step 0.1 -units dits"
	}
	{* -weight} - 
	{* -ratio} { opt-describe $option value -format %.1f -min 25.0 -max 75.0 -step 0.1 -units % -graticule 20 -steps-per-div 50}
	{* -comp} { opt-describe $option value -format %.1f -min -15.0 -max 15.0 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	{* -freq} { opt-describe $option ivalue -min -1000 -max 1000 -units Hz -graticule 20 -steps-per-div 100}
	{* -rise} - 
	{* -fall} - 
	{* -ramp} { opt-describe $option value -format %.1f -min 0.0 -max 15.0 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	{* -window} { opt-describe $option enum -values [lrange [get-window-types] 1 end] }
	{* -window2} { opt-describe $option enum -values [get-window-types] }
	{* -gain} { opt-describe $option value -format %.1f -min -50 -max 3 -step 0.1 -units dB -graticule 20 -steps-per-div 50}
	{* -delay} { opt-describe $option value -format %.1f -min 0.0 -max 1000 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	{* -hang} { opt-describe $option value -format %.1f -min 0.0 -max 1000 -step 0.1 -units ms -graticule 20 -steps-per-div 50 }
	{*spectrum* -period} {  opt-describe $option ivalue -min 1 -max 500 -units ms -graticule 20 -steps-per-div 25 }
	{*debounce* -period} { opt-describe $option value -format %.3f -min 0.1 -max 50 -step 0.1 -units ms -graticule 20 -steps-per-div 25 }
	{*debounce* -steps} { opt-describe $option ivalue -min 1 -max 32 -units steps -graticule 20 -steps-per-div 1}
	{*insert* -dit} - 
	{*insert* -dah} - 
	{* -skey} - 
	{*insert* -ptt} - 
	{* -key-4} - 
	{* -key-5} { opt-describe $option enum -values {none Shift_L Control_L Alt_L Shift_R Control_R Alt_R} }
	{*insert* -window} { opt-describe $option enum -values {none . .dial} }
	{* -dict} { opt-describe $option enum -values [get-morse-dicts] }
	{* -bandwidth} { opt-describe $option freq -format %.0f -min 10 -max 1000 -step 1 -units Hz -graticule 20 -steps-per-div 50}
	{* -on} - 
	{* -off} { opt-describe $option value -format %.1f -min 0.0 -max 5.0 -step 0.1 -graticule 20 -steps-per-div 5}
	{* -timeout} { opt-describe $option ivalue -min 0 -max 1000 -units frames -graticule 20 -steps-per-div 50}
	{* -estimate} { opt-describe $option ivalue -min 10 -max 1000 -units frames }
	{* -discover} { opt-describe $option text hide 1 }
	{* -n-rx} -
	{* -speed} -
	{* -peer} -
	{* -gateware-version} -
	{* -code-version} -
	{* -board-id} -
	{* -mac-addr} -
	{* -mcp4662} -
	{* -fixed-ip} - 
	{* -fixed-mac} -
	{* -n-hw-rx} -
	{* -wb-fmt} -
	{* -build-id} -
	{* -gateware-minor} -
	{* -serial} { opt-describe $option text }
	{* -bandscope} { opt-describe $option bool }
	{* -hw-dash} -
	{* -raw-hw-dash} -
	{* -hw-dot} -
	{* -raw-hw-dot} -
	{* -hw-ptt} - 
	{* -raw-hw-ptt} -
	{* -overload} - 
	{* -raw-overload} -
	{* -recovery} - 
	{* -raw-recovery} -
	{* -tx-iq-fifo} - 
	{* -raw-tx-iq-fifo} -
	{* -temperature} - 
	{* -raw-temperature} - 
	{* -avg-temperature} - 
	{* -fwd-power} - 
	{* -raw-fwd-power} -
	{* -avg-fwd-power} -
	{* -rev-power} - 
	{* -raw-rev-power} -
	{* -avg-rev-power} -
	{* -pa-current} -
	{* -raw-pa-current} -
	{* -avg-pa-current} { 
	    opt-describe $option text ronly 1 volatile 1
	}
	{* -rx-calls} -
	{* -tx-calls} -
	{* -bs-calls} -
	{* -rx-dropped} -
	{* -rx-outofseq} {
	    opt-describe $option text ronly 1 volatile 1
	}
	{* -mox} { opt-describe $option bool }
	{* -filters} { opt-describe $option ivalue -min 0 -max 255 }
	{* -lna-db} { opt-describe $option ivalue -min -12 -max 48 -units dB }
	{* -f-tx} - 
	{* -f-rx*} { 
	    # Transmitter NCO frequency
	    # Receiver NCO frequency.
	    set hide 0
	    if {[regexp {^-f-rx(\d+)$} $opt all irx]} { if {$irx > 6} { set hide 1 } }
	    opt-describe $option freq hide $hide -units Hz -format %.0f -min 1 -max 29999999 -step 1 -graticule 20 -steps-per-div 500
	    
	}
	{* -level} { opt-describe $option freq -format %.0f -min 0 -max 255 -step 1 }
	{* -not-sync} -
	{* -duplex} -
	{* -pa} -
	{* -low-pwr} -
	{* -pure-signal} -
	{* -bias-adjust} -
	{* -vna} -
	{* -vna-started} -
	{* -vna-fixed-rx-gain} -
	{* -alex-manual-mode} - 
	{* -tune-request} -
	{* -hermes-lite-lna} -
	{* -cwx} -
	{* -reset-hl2-on-disconnect} { opt-describe $option bool }
	{* -vna-count} {
	}
	{* -i2c-rx-filter} -
	{* -i2c-tx-filter} { opt-describe $option ivalue -min 0 -max 255 }
	{* -cw-hang-time} { opt-describe $option ivalue dvalue 10 -min 0 -max 1023 -units ms }
	{* -tx-buffer-latency} { opt-describe $option ivalue dvalue 10 -min 0 -max 31 -units ms }
	{* -ptt-hang-time} { opt-describe $option ivalue dvalue 4 -min 0 -max 31 -units ms }
	{* -predistortion-subindex} { opt-describe $option ivalue -min 0 -max 255 }
	{* -predistortion} { opt-describe $option ivalue -min 0 -max 15 }
	{* -sentcolor} -
	{* -unsentcolor} -
	{* -skippedcolor} -
	{* -background} -
	{* -foreground} {
	    # ignore these and -font for the moment, the foreground widget doesn't wrap things yet
	    #opt-describe $option enum -values {white black gray lightgrey red orange yellow green blue indigo violet}
	}
	{* -font} {
	    #opt-describe $option enum -values {TkFixedFont {helvetica 10} {helvetica 12} {helvetica 14}}
	}
	{* -size} { opt-describe $option enum -values {8 16 32 64 128 256 512 1024 2048 4096 8192 16384} }
	{* -planbits} { opt-describe $option ivalue -min 0 -max 127}
	{* -direction} {opt-describe $option enum -values {-1 1} }
	{* -polyphase} { opt-describe $option ivalue -min 1 -max 32 }
	{* -result} { opt-describe $option enum -values {coeff mag2 mag dB short char}}
	{* -min-f} {}
	{* -max-f} {}
	{* -center-freq} {}
	{* -tuned-freq} {}
	{* -sample-rate} { opt-describe $option enum -values {48000} }
	{*spectrum* -min} -
	{*spectrum* -max} { opt-describe $option ivalue -min -200 -max 30 -step 10 -units dB }
	{* -zoom} { opt-describe $option enum -values {0.5 1 2 4 8 16 32 64} }
	{* -pan} { opt-describe $option ivalue -min 200000 -max 200000 } 
	{* -command} {}
	{* -pal} { opt-describe $option enum -values {0 1 2 3 4 5} }
	{* -atten} {}
	{* -automatic} {}
	{* -smooth} { opt-describe $option bool }
	{* -multi} { opt-describe $option ivalue -min 1 -max 64 }
	{* -filter-low} -
	{* -filter-high} { opt-describe $option value -min -8000 -max 8000 }
	{* -band-low} -
	{* -band-high} { opt-describe $option value -min 100 -max 29999999 }
	{* -rx-frames-per-call} { opt-describe $option text ronly 1 volatile 1 }
	{* -tx-frames-per-call} - 
	{* -bs-frames-per-call} { opt-describe $option text ronly 1 }
	{* -length} { opt-describe $option enum -values {64 128 256 512 1024} }
	{* -low} - 
	{* -high} { opt-describe $option value -min -8000 -max 8000 }
	{*radio* -mode} { opt-descrbe $option enum -values {USB LSB DSB CWU CWL AM SAM FMN DIGU DIGL} }
	{*radio* -mute} { opt-describe $option bool }
	{*radio* -spot} { opt-describe $option bool }
	{*agc* -mode} { opt-describe $option enum -values {off long slow medium fast} }
	{*agc* -target} { opt-describe $option value info {target level, linear gain} -min 0.1 -max 10 }
	{*agc* -attack} { opt-describe $option ivalue info {attack time} -min 1 -max 4 -units ms }
	{*agc* -decay} { opt-describe $option ivalue info {decay time} -min 100 -max 2000 -units ms }
	{*agc* -slope} { opt-describe $option value info {slope, as in y = slope * x + intercept} -min 0.5 -max 2 }
	{*agc* -hang} { opt-describe $option ivalue info {hang time} -min 50 -max 1000 -units ms }
	{*agc* -fasthang} { opt-describe $option ivalue info {fast hang time} -min 50 -max 200 -units ms }
	{*agc* -max} { opt-describe $option value info {max level} -min 1 -max 1e5 }
	{*agc* -min} { opt-describe $option value info {min level} -min 1e-5 -max 1 }
	{*agc* -threshold} { opt-describe $option value info {threshold level} -min 0.25 -max 4 }
	{*iq* -swap} { opt-describe $option bool }
	{*iq* -delay} { opt-describe $option enum info {delay I by one sample, no delay, or delay Q by one sample} -values {-1 0 1} }
	{*iq-correct* -rate} { opt-describe $option value info {the learning rate for the adaptive filter} -min -1e6 -max 1e6 }
	{*leveler* -mode} { opt-describe $option enum -values {off leveler} }
	{*iambic* -keyer} { opt-describe $option enum -values {none ad5dz dttsp k1el nd7pa vk6ph} }
	{*meter* -reduce} { opt-describe $option enum -values {abs-real abs-imag max-abs mag2} }
	{*meter* -style} { opt-describe $option enum -values {s-meter} }
	default { puts "populate-option $name $opt: no clues" }
	other {
snit::enum	sdrtype::spec-size	-values {width/8 width/4 width/2 width width*2 width*4 width*8}
	}
    }
}

# go through the components and build the database of options
proc composite-populate-options {name factory window composite} {
    # $component is the component $factory
    # $name is the component instance
    # puts "composite-populate-options $name $factory $window $composite"
    if {$window ne {}} {
	set call $window
	set options [$window exposed-options]
    } else {
	set call $name
	set options [$name info options]
    }
    foreach opt $options {
	# $opt is the option name used in direct configure and cget commands to $comp
	if {[opt-is-defined -$name$opt]} { error "composite-populate-options: $name $opt ... is a duplicate" }
	set result [$call configure $opt]
	# puts "$call configure $opt -> $result"
	foreach {copt cname cclass cdefault cvalue} $result break
	# $copt should be $opt
	if {$opt ne $copt} { error "composite-populate-options: $call configure $opt returned a different option name $copt" }
	# $cname is the option name in the option database (not used here)
	# $cclass is the option class name in the option database (not used here)
	# $cdefault is the default value
	# $cvalue is the current value
	if {[catch {$call info option $opt} info]} { set info [$call info-option $opt] }
	# $info is the tool tip for the option
	set merge [the-merge $opt]; # the merge pattern that matched this opt
	set hide [expr {[is-hide $opt] || [is-hide -$name$opt]}];    # the opt matched a hide pattern
	set favor [is-favor $opt];  # the opt is in the favorite list
	set argvopts [is-argvopts $opt]; # the opt was in the argv
	set option [dict create \
			text -$name$opt factory $factory name $name opt $opt window $window cname $cname cclass $cclass \
			cdefault $cdefault cvalue $cvalue info $info type none merge $merge hide $hide favor $favor \
			ronly 0 conly 0 volatile 0 isargv $argvopts composite $composite]
	# $option is the option dict for -$name$opt
	populate-option $name $opt $option
    }
}

#
# update the window
# this doesn't work when -wpm, -window, and -window2 aren't obvious
#
proc update-window-title {} {
    if {0} {
	if {[info exists ::value(-wpm)] && [info exists ::value(-window2)]} {
	    if {$::value(-window2) ne {none}} {
		set title "recri keyer $::value(-wpm) wpm $::value(-window)*$::value(-window2)"
	    } else {
		set title "recri keyer $::value(-wpm) wpm $::value(-window)"
	    }
	} elseif {[info exists ::value(-freq)] && [info exists ::value(-window2)]} {
	    if {$::value(-window2) ne {none}} {
		set title "recri keyer $::value(-freq) Hz $::value(-window)*$::value(-window2)"
	    } else {
		set title "recri keyer $::value(-freq) Hz $::value(-window)"
	    }
	} else {
	    set title "recri keyer"
	}
    }
    set title {recri keyer}
    if {[has-title]} { set title [get-title] }
    wm title . $title
    set-title $title
}

#
# dial setting, most options are delegated to the dialbook
# one dial for setting everything.
#
# there's a trickiness, the sdrtcl widgets that implement jack
# dsp can be too busy to process options, so we may need to
# wait until the previous setting has completed.  This is all
# to avoiding expensive computations in the inner dsp loop, and
# getting.
#
# should wrap this into a snit type, ideally responisble for
# constructing the dialbook pages and managing the options
# list and aliases and so on.
#
set handler {}

proc dial-set {opt val} {
    # puts "dial-set $opt $val defined [opt-is-defined $opt], ronly [opt-is-ronly $opt], value eq val [expr {[opt-get-value $opt] eq $val}]"
    if {[opt-is-defined $opt]} {
	if {[opt-is-ronly $opt]} return
	if {[opt-get-value $opt] eq $val} return
	opt-set-value $opt $val
	set ::value($opt) $val
	# puts "set ::value($opt) $val"
	foreach {comp opt2} [opt-component-opts $opt] {
	    dict set ::data(busy) $comp $opt2 $val
	    if { ! [$comp is-busy]} {
		set opts [dict get $::data(busy) $comp]
		if {[catch {
		    $comp configure {*}$opts
		    dict unset ::data(busy) $comp
		} error]} {
		    puts "dial-set {$comp configure $opts} threw {$error}"
		}
	    } elseif {$::handler eq {}} {
		# puts "$comp is-busy"
		set ::handler [after 100 dial-set-timeout]
	    }
	}
    } else {
	error "$opt is not defined in dial-set"
    }
}

proc dial-set-timeout {} {
    dict for {comp opts} $::data(busy) {
	if { ! [$comp is-busy]} {
	    if {[catch {
		$comp configure {*}$opts
		dict unset ::data(busy) $comp
	    } error]} {
		puts "dial-set {$comp configure $opts} threw {$error}"
	    }
	} else {
	    # puts "$comp is-busy"
	}
    }
    # hmm, none of this is going to work any more, and it should be lower 
    after idle [list update-window-title]
    if {[dict size $::data(busy)] > 0} {
	set ::handler [after 100 dial-set-timeout]
    } else {
	set ::handler {}
    }
}

proc dial-set-init {} {
    set ::data(busy) [dict create]
    # dial-set-timeout
}

#
# load the main ui for the program
#
proc load-ui {} {
    set args {}
    if {[has-grid]} { lappend args -grid [get-grid] }
    if {[has-tree]} { lappend args -tree [get-tree] }
    #.p add [::sdrtk::dialbook .p.dial {*}$args]
    #toplevel .dial
    wm title . keyer/dial
    pack [::sdrtk::dialbook .dial {*}$args]
    array set compid {}
    foreach text [opts-with-descriptions] {
	set desc [opt-description $text]
	set cvalue [dict get $desc cvalue]
	set type [dict get $desc type]
	set name [dict get $desc name]
	set opt [dict get $desc opt]
	set info [dict get $desc info]
	set readout [dict get $desc readout]
	
	# foreach var [dict keys $desc] { set $var [dict get $desc $var] }
	# puts "load-ui $text value $cvalue type $type name $name readout $readout"
	
	# if already processed, error
	if {[info exists ::value($text)]} { error "::value($text) already processed" }
	
	# if no value in definitions, error
	if { ! [info exists cvalue]} { error "no cvalue extracted from option $text" }

	# set up the details display
	set ::value($text) $cvalue
	
	if {[opt-is-hide $text]} continue
	
	if {[opt-is-volatile $text]} { lappend-volatile $text $name $opt }

	set w .dial.x$text
	package require sdrtk::readout-$type
	sdrtk::readout-$type $w -dialbook .dial \
	    -text $text -info $info {*}$readout \
	    -value $cvalue -variable ::value($text) -command [list dial-set $text]
	#if {$text in {-key-wpm -key-weight}} { $w test }
	.dial add $w $name $type -text [$w cget -text]
    }
    if {[.dial select] eq {}} { .dial select 0 }
    after 25 process-volatile
}

proc process-volatile {} {
    foreach {text name opt} [get-volatile] {
	set val [$name cget $opt]
	if {$val ne $::value($text)} { set ::value($text) $val }
    }
    after 25 process-volatile
}

#
# setups bind an implementaion to a instance and supply some option values
# saving all setups in a file makes it hard to change the prebuilt setups
# should only save those which are different from the prebuilt defaults
#
package require getstring
namespace import getstring::*

proc is-setup {name} {
    return [dict exists [get-setups] $name]
}
proc get-setup-names {} {
    return [lsearch -inline -glob -all -not [dict keys [get-setups]] info-*]
}
proc setup-v0-style {setups} {
    # v0 had setup names but no setup info-names
    set info 0
    set setup 0
    set keys [dict keys $setups]
    foreach key $keys {
	if {[string match $key info-*]} {
	    incr info
	} elseif {[dict exists $setups info-$key]} {
	    incr setup
	}
    }
    return [expr {$info == 0 && $setup == 0}]
}
proc setup-upgrade-v0-v1 {setups} {
    set defs [default-setups]
    foreach key [dict keys $setups] {
	if {[dict exists $defs info-$key]} {
	    set info [dict get $defs info-$key]
	} else {
	    set info {}
	}
	dict set setups info-$key $info
    }
    return $setups
}
proc save-current-setup {} {
    # prompt for name?
    if {[tk_getString .gs text "Name for setup:"]} {
	if {[tk_getString .gs info "Description:"]} {
	    add-setup $text [build-command-line]
	    add-setup info-$text $info
	    save-setups
	}
    }
}
proc save-setups {} {
    set fp [open ~/.config/keyer/keyer.tcl w]
    puts $fp "dict create {*}{"
    dict for {key value} [get-setups] {
	puts $fp "  $key { [string trim $value] }"
    }
    puts $fp "}"
    close $fp
}
proc default-setups {} {
    # rewrite so 
    #   dict get $defaults $key def -> returns the setup definition
    #   dict get $defaults $key info -> returns the setup info
    #   dict get $defaults $key connect -> returns the setup connection hints
    # at which point the key+out composite setups get to add connection hints
    # for hooking up the parts
    #
    # connection hints
    #  -connect system-midi>key>kyo>system-audio
    #  -connect system-midi>key2>kyo2>system-audio
    #  -connect kbd>kbo>system-audio
    #  -connect kbd2>kbo2>system-audio
    #  -connect >ptt>
    #  -connect >deb>
    #  -connect cas>key*
    #  -connect (kyo|kbo)*>detone>out (or receiver stream?)
    #

    return [dict create {*}{ 
	key { keyer -start {iambic@key keyer-tone@kyo} -key-wpm 16 -kyo-ramp 4.0 -key-mode B -key-alsp 1 }
	key2 { keyer -start {iambic@key2 keyer-tone@kyo2} -key2-wpm 16 -key2-note 2 -key2-mode B -key2-alsp 1 -kyo2-ramp 4.0 -kyo2-note 2 }
	kbd { keyer -start {cw-encode-input@kbd keyer-tone@kbo} -kbd-wpm 80 -kbo-ramp 6.6 }
	kbd2 { keyer -start {cw-encode-input@kbd2 keyer-tone@kbo2} -kbd2-wpm 80 -kbo2-ramp 6.6 }
	ptt { keyer -start {keyer-ptt@ptt} }
	deb { keyer -start {keyer-debounce@deb} }
	cas { keyer -start {midi-insert-key@cas} -cas-dit Alt_R -cas-dah Control_R }
	tap { keyer -start {midi-tap-view@tap} }
	tap2 { keyer -start {midi-tap-view@tap2} }
	out { keyer -start {cw-decode-view@out} -out-freq 700 -out-wpm 16 }
	hl { keyer -start {hl-connect@hl} -hl-client hl -hide {-hl-raw-* -hl-avg-* -hl-hw-*} }
	hlt { keyer -start {hl-test@hlt} -kyo-gain -6 -hl-low-pwr 1 -hl-lna-db 14 -hl-pa 0 }
	spec { keyer -start {spectrum-waterfall-view@spec}}
	spec2 { keyer -start {spectrum-waterfall-view@spec2}}
	filt { keyer -start {filter-overlap-save@filt} -filt-low 0 -filt-high 1400 }
	nod { keyer -hide {*-dit *-dah *-ies *-ils *-iws *-alsp *-awsp *-word} }
	1ch { keyer -merge {*-chan *-note} }
	test { keyer key hl hlt spec filt -tree 1 } 
	info-key {iambic keyer and a keyed oscillator}
	info-key2 {second iambic keyer and keyed oscillator}
	info-kbd {keyboard keyer and a keyed oscillator}
	info-kbd2 {second keyboard keyer and a keyed oscillator}
	info-ptt {push-to-talk switch with tx delay}
	info-deb {key contact debouncer}
	info-cas {midi events from keyboard keys}
	info-tap {midi monitor for timing events}
	info-tap2 {second midi monitor for timing events}
	info-out {audio to ascii morse decoder}
	info-hl { hermes lite udp jack connection }
	info-hlt { hermes lite test dashboard }
	info-spec { spectrum and waterfall display }
	info-spec2 { spectrum and waterfall display }
	info-filt { overlap save bandpass filter }
	info-test { hermes lite test app }
	info-nod {hide esoteric keyer options}
	info-1ch {merge midi channel and note options}
    }]
}

proc merge-default-setups {} {
    set s [get-setups]
    set d [default-setups]
    set up 0
    dict for {name value} $d {
	if { ! [dict exists $s $name] } {
	    dict set s $name $value
	    incr up
	}
    }
    return $up
}

proc init-setups {} {
    # config file does not exist or error reading it
    if { ! [file exists ~/.config]} { file mkdir ~/.config }
    if { ! [file exists ~/.config/keyer]} { file mkdir ~/.config/keyer }
    set-setups [default-setups]
    # turn off saving for the moment
    # save-setups
    #if {[catch {source ~/.config/keyer/keyer.tcl} result]} {
    #	error "failed to create default configs: $result"
    #}
}

proc load-setups {} {
    if { ! [file exists ~/.config/keyer/keyer.tcl] || 
	 [catch {source ~/.config/keyer/keyer.tcl} result]} {
	init-setups
    } elseif {[setup-v0-style $result]} {
	set-setups [setup-upgrade-v0-v1 $result]
	merge-default-setups
	save-setups
    } else {
	set-setups $result
	if {[merge-default-setups]} {
	    save-setups
	}
    }
}

#
#
#
proc build-command-line {} {
    set argv [file tail $::script]
    if {[get-server] ne {}} { lappend argv -server [get-server] }
    lappend argv -start [get-start]
    # prefer specifically named options
    # to the ones that are only inferred from component inspection
    foreach opt [opt-get-opts] {
	if { ! [info exists ::value($opt)]} continue
	if {$::value($opt) ne $::defval($opt)} {
	    lappend argv $opt $::value($opt)
	}
    }
    # now find the pertinent -merge -hide etc lists
    if {[has-merge]} { lappend argv -merge [lsort -unique [get-merge]] }
    if {[has-hide]} { lappend argv -hide [lsort -unique [get-hide]] }
    return $argv
}

proc usage-message {} {
    # puts "[dict keys $::data(main)]"
    puts "usage: keyer setup ..."
    puts "setups: [get-setup-names]"
    foreach s [get-setup-names] {
	puts "  $s: [dict get [get-setups] info-$s]"
    }
    exit 1
}

#
# process a list of arguments, always formatted as -option value pairs
#
proc main-argv {argv} {
    # peel off any number of setup names
    while {[llength $argv] > 0 && [is-setup [lindex $argv 0]]} {
	set v [lindex $argv 0]
	set argv [lrange $argv 1 end]
	main-argv [lrange [get-setup $v] 1 end]
    }
    foreach {opt val} $argv {
	# -server - jack server
	# -title - window title
	# -run - saved setups to run
	# -start - components to start
	# -favor - option patterns to favor
	# -hide - option patterns to hide
	# -merge - option patterns to merge
	# -iambic module- module for iambic keyer
	# -grid 1 - use dialbook grid setup
	# -tree 1 - use dialbook tree setup
	# otherwise - -option value pair to apply to parts
	switch -- $opt { 
	    -server { set-server $val }
	    -title { set-title $val }
	    -run { foreach v $val { main-argv [lrange [get-setup $v] 1 end] } }
	    -start { lappend-start {*}$val }
	    -favor { lappend-favor {*}$val }
	    -hide { lappend-hide {*}$val }
	    -merge { lappend-merge {*}$val }
	    -iambic { set-iambic $val }
	    -grid { set-grid $val }
	    -tree { set-tree $val }
	    default { lappend-argvopts $opt $val }
	}
    }
}

package require sdrtcl::jack-client
sdrtcl::jack-client jack

proc manage-connections {} {
    # puts [jack list-ports]
}

proc main {argv} {
    
    # style, abolish invisible indicators
    ttk::style configure "." -indicatordiameter 12
    ttk::style configure TCheckbutton -relief raised
    ttk::style configure TRadiobutton -relief raised
    
    # default server
    # set-server {}
    # puts "keyer main get-server [get-server]"
    
    # load or create ~/.config/keyer/keyer.tcl
    load-setups
    
    # make a usage message
    if {$argv eq {} || $argv eq {help}} { usage-message }
    
    # process arguments, first pass just to collect everything
    # puts "keyer main-argv $argv"
    main-argv $argv
    
    # default value for iambic
    if { ! [has-iambic] } { set-iambic keyer-iambic-ad5dz }
    # puts "has-iambic [has-iambic] get-iambic [get-iambic]"
    
    # start components and collect their options
    if { ! [has-start]} { usage-message }

    foreach v [get-start] {
	foreach {name factory window composite} [composite-load $v] break
	composite-define $name $factory $window $composite
	composite-populate-options $name $factory $window $composite
    }
    
    # process command line options for additional option definitions
    foreach {opt val} [get-argvopts] {
	if {[opt-is-defined $opt]} continue; # already defined
	#error "undefined option: $opt $val"
    }
    
    # initialize the dial-set timer
    dial-set-init
    
    # build the ui with the extracted options
    load-ui
    
    # load the options collected from the command line
    if {[has-argvopts]} {
	foreach {opt val} [get-argvopts] { 
	    # puts "dial-set $opt $val"
	    if {[catch {dial-set $opt $val} error]} {
		puts "dial-set threw $error"
		# if the $opt is -$comp for one of the setup components,
		# then apply it to each opt value pair in $val to get
		# -$comp$opt $value
		foreach {option value} $val {
		    if {[catch {dial-set $opt$option $value} error2]} {
			puts "bad option: $opt $val"
		    }
		}
	    }
	}
    }
    
    # install application icon
    set dir [file join $::dirname .. icons]
    image create photo icon1 -file [file join $dir qrv96.png]
    image create photo icon2 -file [file join $dir qrv48.png]
    wm iconphoto . -default icon1 icon2
    # update window title
    update-window-title

    manage-connections
}

main $argv

# current todo
# [x] create treeview to organize options, etc.
# [x] all-options subtree with all options present
# [x] merge all options and details into one dict.
# [ ] dial-faves subtree with dial favorites
# [ ] types subtree specifying options on values for shared types
# [ ] out-connections subtree listing components and their sinks
# [ ] in-connections subtree listing components and their sources
# [ ] auto connection hints
# [ ] jackd start hints
# [ ] start jackd if necessary, retain connection to server messages
# [ ] perform connections if necessary
# [x] readout-values should limit dial movement to range of choices
# [x] readout-* should have consistent locations
# [x] make the window'ed components into sdrtk::packages
# [x] make mixed windowed dsp components into sdrtcltk::packages
# [ ] implement the snit info vs sdrtcl info fix
# [ ] make a readout-vfo which tunes nicely
# [x] bring up the overlap-save passband filter
# [x] bring up the polyphase spectrum/waterfall (which should run as a separate process?)
# [ ] run the polyphase spectrum/waterfall as a separate process
# [ ] aggressive UI debouncing on all tunable components
# [ ] rewire the spectrum waterfall to the tuner.
# [ ] rewrite the tuner/radio component that switches bandpass filter and spectrum display
#	of bandpass envelope, and the modem bank
# [ ] can start qjackctl from the command line with a specified patch
#     qjackctl --start -active-patchbay=[path] --server-name=[label] --preset=[label]
#
# old todo list
# [-] make the -rise-fall option sort after the -rise and -fall that it joins
# [-] make the -rise-fall option update the displayed -rise and -fall option values too
# [x] replace -rise-fall with -ramp option in the keyer-tone itself
# [x] wrap more of this into snit
# [x] generate the command line for a configured setup, save it, restore it
# [x] start using tklib
# [x] prompt for name for saved setup
# [ ] balloon help for options
# [ ] balloon help for setups
# [ ] balloon help for components
# [x] add empty units box to readout-enum
# [ ] implement dialbook dial labels
# [ ] implement recursive dialbook, where groups of related, boring options are pushed down into boxes
# [ ] implement dialbook detents and dial limits so it doesn't just spin.
# [x] allow keyer setup1 setup2 ... as syntactic sugar
# [x] end timer loop when cwtext queue empties
# [ ] end timer loop when dialbook-set queue empties
# [ ] implement midi -> OSC bridge (easy)
# [ ] implement OSC -> MIDI bridge (not so easy, alsa sequencer?)
# 
