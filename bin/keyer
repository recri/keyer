#!/usr/bin/wish8.6
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# Copyright (C) 2018 by Roger E Critchlow Jr, Charlestown, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

# this is the mega-keyer script
# start arbitrary collections of sdrtcl components
# wire up their options into a dialbook
# hide, merge, or fuse options
# save the result as a preset command for later access
#

#
# use the script location to find the rest of the libraries
#
set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
set dirname [file dirname $script]

#
# append the ../lib directory to the Tcl search path
#
lappend auto_path [file join $dirname .. lib]

package require snit
namespace eval ::sdrtk {}
package require sdrtk::dialbook

#
# utilities
#
proc read-file {file} {
    set fp [open $file r]
    set data [read $fp]
    close $fp
    return $data
}
proc write-file {file data} {
    set fp [open $file w]
    puts -nonewline $fp $data
    close $fp
}

#
# value enumerations for a few options
#

# these are filter/fft windowing functions
package require sdrtcl::window
proc get-window-types {} {
    catch { sdrtcl::window foo 512 } error
    regexp {^unknown window type, should be one of (.*)$} $error all error
    regsub -all {, (or )?} $error { } error
    set error [lsort $error]
    set i [lsearch $error {none}]
    if {$i >= 0} {
	set error [concat none [lreplace $error $i $i]]
    }
    return $error
}

# these are morse code dictionaries
package require morse::dicts
proc get-morse-dicts {} { 
    return [concat {builtin} [morse-dicts]]
}

# these are the iambic keyers
proc get-iambic-keyers {} { 
    return [lmap x [lsearch -glob -all -inline [::options packages] *keyer-iambic-*] {lindex [split $x -] end}]
}

#
# component/option manager
#
package require snit
namespace eval ::keyer {}

snit::type keyer::options {
    variable options -array {}

    variable data -array {
	pkgs {}
	comps {}
	opts {}
	handler {}
	busy {}
	-favor {}
	-merge {}
	-hide {}
	volatile {}
    }

    constructor {args} {
	# $self configurelist $args

	set data(opts) [dict create]
	set data(busy) [dict create]
	set data(comps) [dict create]
	set data(pkgs) [dict create]

	$self find-packages
	$self process-volatile
    }

    # the part dealing with options

    # describe an option in detail, and define it
    method describe {dict otype args} { 
	set opt [dict get $dict text]
	set options($opt) [dict get $dict cvalue]
	# puts "keyer-options describe options($opt) is $options($opt)"
	dict set dict type $otype
	dict set dict described 1
	dict set dict readout {}
	foreach {key val} $args {
	    if {[string index $key 0] eq {-}} {
		dict lappend dict readout $key $val
	    } else {
		dict set dict $key $val
	    }
	}
	dict set data(opts) $opt $dict
	if {[$self is-volatile $opt]} { $self add-volatile $opt [dict get $dict call] [dict get $dict opt] [myvar options($opt)] }
    }

    method get-opts {} { return [dict keys $data(opts)] }

    method is-option {opt} { return [dict exists $data(opts) $opt] }
    method exists {opt key} { return [dict exists $data(opts) $opt $key] }
    method get {opt key} { return [dict get $data(opts) $opt $key] }
    method set {opt key val} { dict set data(opts) $opt $key $val }

    method is-described {opt} { return [$self exists $opt described] }
    method is-processed {opt} { return [$self exists $opt processed] }
    method is-ronly {opt} { return [$self get $opt ronly] }
    method is-conly {opt} { return [$self get $opt conly] }
    method is-favor {opt} { return [$self get $opt favor] }
    method is-hide {opt} { return [$self get $opt hide] }
    method is-volatile {opt} { return [$self get $opt volatile] }

    method get-default {opt} { return [$self get $opt cdefault] }
    method get-value {opt} { return [$self get $opt cvalue] }
    method set-value {opt val} { return [$self set $opt cvalue $val] }
    method is-default {opt} {
	if {[$self is-readonly $opt]} { return 1 }
	if {[$self get-default $opt] eq $options($opt)} { return 1 }
	return 0
    }

    method component-opts {opt} {
	set d [dict get $data(opts) $opt]
	set w [dict get $d window]
	# component definition should test for presence of is-busy method
	# ditto for activate/deactivate
	set busyness [string match sdrtcl*::* [dict get $d factory]] 
	if {$w ne {}} { return [list $w [dict get $d opt] $busyness] }
	return [list [dict get $d name] [dict get $d opt] $busyness]
    }

    # these apply to lists of options or option patterns
    # which are specified on the command line or in setups
    # which become option properties when the option matches
    # the list of patterns
    method lappend {opt args} { lappend data($opt) {*}$args }
    
    #method add-favor {args} { lappend data(favor) {*}$args }
    method has-favor {} { return [expr {$data(-favor) ne {}}] }
    method get-favor {} { return $data(-favor) }

    #method add-merge {args} { lappend data(merge) {*}$args }
    method has-merge {} { return [expr {$data(-merge) ne {}}] }
    method get-merge {} { return $data(-merge) }

    #method add-hide {args} { lappend data(hide) {*}$args }
    method has-hide {} { return [expr {$data(-hide) ne {}}] }
    method get-hide {} { return $data(-hide) }

    # this is a list of options which are volatile and must
    # be refreshed from the component where they live
    method add-volatile {args} { lappend data(volatile) {*}$args }
    method has-volatile {} { return [expr {$data(volatile) ne {}}] }
    method get-volatile {} { return $data(volatile) }
    method process-volatile {} {
	foreach {opt call opt2 var} [$self get-volatile] {
	    set val [$call cget $opt2]
	    if {$val ne [set $var]} { set $var $val }
	}
	after 25 [mymethod process-volatile]
    }

    #
    # dial setting, most options are delegated to the dialbook
    # one dial for setting everything.  So this is where the
    # dialbook delegates everything to be set.
    #
    # there's a trickiness, the sdrtcl widgets that implement jack
    # dsp can be too busy to process options, so we may need to
    # wait until the previous setting has completed.  This is all
    # to avoiding expensive computations in the inner dsp loop, and
    # getting.
    #
    # then also we should be debouncing a lot of option setting to
    # avoid overwhelming thins.
    #
    # should wrap this into a snit type, ideally responisble for
    # constructing the dialbook pages and managing the options
    # list and aliases and so on.
    # 
    # okay, this should be the snit type for the top level component
    # and all the composite named options are actually options for
    # this component which it resolves into calls to subname suboption
    # it also handles:
    # 1) backpressure in the form of subname is-busy
    # 2) value debouncing
    # 3) option merging and chaining
    #
    # it also handles the options dictionary, options definitions, and options descriptions
    # 
    method configure {args} {
	set n [llength $args]
	switch $n {
	    0 {
		# full configure dump
		return [lmap o [$self get-opts] {$self configure $o}]
	    }
	    1 {
		# one option configure dump
		set o [lindex $args 0]
		return [list $o [$self get $o cname] [$self get $o cclass] [$self get $o dvalue] $options($o)]
	    }
	}
	if {($n&1) != 0} {
	    error "configure requires an even number of arguments"
	}
	foreach {opt val} $args {	
	    $self cset $opt $val
	}
    }

    method cset {opt val} {
	if { ! [$self is-option $opt]} {
	    error "$opt is not defined in keyer-options::configure"
	}
	if {[$self is-ronly $opt]} return
	if {[$self get-value $opt] eq $val} return
	$self set-value $opt $val
	if {[catch {set options($opt) $val} result]} {
	    puts "keyer::options configure $opt $val: {set options($opt) $val} threw $result"
	}
	foreach {comp opt2 busyness} [$self component-opts $opt] {
	    # puts "keyer-options::configure $comp $opt2"
	    dict set data(busy) $comp $opt2 $val
	    # puts "keyer-options::configure try: $comp is-busy"
	    if { ! $busyness || ! [$comp is-busy]} {
		set opts [dict get $data(busy) $comp]
		if {[catch {
		    # puts "keyer-options::configure try: $comp configure $opts"
		    $comp configure {*}$opts
		    dict unset data(busy) $comp
		} error]} {
		    puts "configure {$comp configure $opts} threw {$error}"
		}
	    } elseif {$data(handler) eq {}} {
		# puts "$comp is-busy"
		set data(handler) [after 100 [mymethod configure-timeout]]
	    }
	}
    }
	
    method configure-timeout {} {
	dict for {comp opts} $data(busy) {
	    if { ! [$comp is-busy]} {
		if {[catch {
		    $comp configure {*}$opts
		    dict unset data(busy) $comp
		} error]} {
		    puts "keyer-options::configure-timeout {$comp configure $opts} threw {$error}"
		}
	    } else {
		# puts "$comp is-busy"
	    }
	}
	if {[dict size $data(busy)] > 0} {
	    set data(handler) [after 100 [mymethod configure-timeout]]
	} else {
	    set data(handler) {}
	}
    }
    
    method cget {opt} {
	if {[$self is-option $opt]} {
	    if {[$self is-volatile $opt]} {
		foreach {name opt2} [$self component-opts $opt] break
		set val [$name cget $opt2]
		if {$val ne $options($opt)} { set options($opt) $val } 
	    }
	    return $options($opt)
	}
	error "keyer-options::cget $opt is not defined"
    }
    
    method cvar {opt} {
	if {[$self is-option $opt]} { return [myvar options($opt)] }
	error "keyer-options::cvar $opt is not defined"
    }

    method populate-option {name opt option} {
	# look for further guidance
	# puts "populate-option [dict get $option factory] $opt"

	switch -glob -- [list [dict get $option factory] $opt] {
	    {* -seed} { $self describe $option value -format %.0f -min -64000 -max 64000 -step 1 }
	    {* -start} { $self describe $option bool }
	    {* -server} - 
	    {* -client} { $self describe $option text ronly 1 hide 1 conly 1 -graticule 1 }
	    {* -verbose} { $self describe $option ivalue ronly 1 hide 1 conly 1 -min 0 -max 10 -graticule 12 -steps-per-div 1 }
	    {* -chan} { $self describe $option ivalue -min 1 -max 16 -graticule 16 -steps-per-div 1 }
	    {* -note} { $self describe $option ivalue -min 0 -max 127 -graticule 16 -steps-per-div 8 }
	    {* -wpm} { $self describe $option value -format %.1f -units wpm -min 5.0 -max 120.0 -step 0.5 -graticule 20 -steps-per-div 10 }
	    {* -swap} - 
	    {* -mdit} - 
	    {* -mdah} - 
	    {* -mide} - 
	    {* -alsp} - 
	    {* -awsp} { $self describe $option bool }
	    {* -mode} { $self describe $option enum -values {A B}}
	    {* -word} { $self describe $option enum -values {50 60} -units dits}
	    {*keyer* -dit} - 
	    {*keyer* -dah} - 
	    {*keyer* -ies} - 
	    {*keyer* -ils} - 
	    {*keyer* -iws} { 
		set cdefault [dict get $option cdefault]
		set min [expr {$cdefault-0.5}]
		set max [expr {$cdefault+0.5}]
		$self describe $option value -format %.1f -min $min -max $max -step 0.1 -units dits
		#puts "$self describe $name $opt -value $cvalue -min $min -max $max -step 0.1 -units dits"
	    }
	    {*keyer* -weight} - 
	    {*keyer* -ratio} { $self describe $option value -format %.1f -min 25.0 -max 75.0 -step 0.1 -units % -graticule 20 -steps-per-div 50}
	    {*keyer* -comp} { $self describe $option value -format %.1f -min -15.0 -max 15.0 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	    {* -freq} { $self describe $option ivalue -min -24000 -max 24000 -units Hz -graticule 20 -steps-per-div 100}
	    {*keyer* -rise} - 
	    {*keyer* -fall} - 
	    {*keyer* -ramp} { $self describe $option value -format %.1f -min 0.0 -max 15.0 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	    {*keyer* -window} { $self describe $option enum -values [lrange [get-window-types] 1 end] }
	    {*keyer* -window2} { $self describe $option enum -values [get-window-types] }
	    {* -gain} { $self describe $option value -format %.1f -min -50 -max 50 -step 0.1 -units dB -graticule 20 -steps-per-div 50}
	    {*latency-timing -delay} -
	    {*sample-delay -delay} { $self describe $option value -format %.0f -min 0 -max 15000 -step 1 -units samples -graticule 20 -steps-per-div 50}
	    {* -delay} { $self describe $option value -format %.1f -min 0.0 -max 1000 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
	    {* -hang} { $self describe $option value -format %.1f -min 0.0 -max 1000 -step 0.1 -units ms -graticule 20 -steps-per-div 50 }
	    {*spectrum* -period} {  $self describe $option ivalue -min 1 -max 500 -units ms -graticule 20 -steps-per-div 25 }
	    {*debounce* -period} { $self describe $option value -format %.3f -min 0.1 -max 50 -step 0.1 -units ms -graticule 20 -steps-per-div 25 }
	    {*debounce* -steps} { $self describe $option ivalue -min 1 -max 32 -units steps -graticule 20 -steps-per-div 1}
	    {*insert* -dit} - 
	    {*insert* -dah} - 
	    {* -key} - 
	    {*insert* -ptt} - 
	    {* -key-4} - 
	    {* -key-5} { $self describe $option enum -values {none Shift_L Control_L Alt_L Shift_R Control_R Alt_R} }
	    {*insert* -window} { $self describe $option enum -values {none . .dial}}
	    {* -dict} { $self describe $option enum -values [get-morse-dicts] }
	    {* -bandwidth} { $self describe $option value -format %.1f -min 10 -max 24000 -step 0.5 -units Hz -graticule 20 -steps-per-div 50}
	    {* -on} - 
	    {* -off} { $self describe $option value -format %.3f -min 0.001 -max 16.0 -step 0.001 -graticule 20 -steps-per-div 5}
	    {* -timeout} { $self describe $option ivalue -min 0 -max 1000 -units frames -graticule 20 -steps-per-div 50}
	    {* -estimate} { $self describe $option ivalue -min 10 -max 1000 -units frames }
	    {* -discover} { $self describe $option text hide 1 }
	    {*hl* -n-rx} -
	    {*hl* -speed} -
	    {*hl* -peer} -
	    {*hl* -gateware-version} -
	    {*hl* -board-id} -
	    {*hl* -mac-addr} -
	    {*hl* -mcp4662} -
	    {*hl* -fixed-ip} - 
	    {*hl* -fixed-mac} -
	    {*hl* -n-hw-rx} -
	    {*hl* -wb-fmt} -
	    {*hl* -build-id} -
	    {*hl* -gateware-minor} -
	    {*hl* -serial} { $self describe $option text }
	    {*hl* -bandscope} { $self describe $option bool }
	    {*hl* -hw-dash} -
	    {*hl* -raw-hw-dash} -
	    {*hl* -hw-dot} -
	    {*hl* -raw-hw-dot} -
	    {*hl* -hw-ptt} - 
	    {*hl* -raw-hw-ptt} -
	    {*hl* -overload} - 
	    {*hl* -raw-overload} -
	    {*hl* -recovery} - 
	    {*hl* -raw-recovery} -
	    {*hl* -tx-iq-fifo} - 
	    {*hl* -raw-tx-iq-fifo} -
	    {*hl* -temperature} - 
	    {*hl* -raw-temperature} - 
	    {*hl* -avg-temperature} - 
	    {*hl* -fwd-power} - 
	    {*hl* -raw-fwd-power} -
	    {*hl* -avg-fwd-power} -
	    {*hl* -rev-power} - 
	    {*hl* -raw-rev-power} -
	    {*hl* -avg-rev-power} -
	    {*hl* -pa-current} -
	    {*hl* -raw-pa-current} -
	    {*hl* -avg-pa-current} -
	    {*hl* -swr} -
	    {*hl* -power} { 
		$self describe $option text ronly 1 volatile 1
	    }
	    {*hl* -rx-calls} -
	    {*hl* -tx-calls} -
	    {*hl* -bs-calls} -
	    {*hl* -rx-dropped} -
	    {*hl* -rx-outofseq} {
		$self describe $option text ronly 1 volatile 1
	    }
	    {*hl* -mox} { $self describe $option bool }
	    {*hl* -filters} { $self describe $option ivalue -min 0 -max 255 }
	    {*hl* -lna-db} { $self describe $option ivalue -min -12 -max 48 -units dB }
	    {*hl* -f-tx} - 
	    {*hl* -f-rx*} { 
		# Transmitter NCO frequency
		# Receiver NCO frequency.
		set hide 0
		if {[regexp {^-f-rx(\d+)$} $opt all irx]} { if {$irx > 6} { set hide 1 } }
		$self describe $option freq hide $hide -units Hz -format %.0f -min 1 -max 29999999 -step 1 -graticule 20 -steps-per-div 500
		
	    }
	    {*hl* -level} { $self describe $option value -format %.0f -min 0 -max 255 -step 1 }
	    {*hl* -not-sync} -
	    {*hl* -duplex} -
	    {*hl* -pa} -
	    {*hl* -low-pwr} -
	    {*hl* -pure-signal} -
	    {*hl* -bias-adjust} -
	    {*hl* -vna} -
	    {*hl* -vna-started} -
	    {*hl* -vna-fixed-rx-gain} -
	    {*hl* -alex-manual-mode} - 
	    {*hl* -tune-request} -
	    {*hl* -hermes-lite-lna} -
	    {*hl* -cwx} -
	    {*hl* -reset-hl2-on-disconnect} { $self describe $option bool }
	    {*hl* -vna-count} {
	    }
	    {*hl* -i2c-rx-filter} -
	    {*hl* -i2c-tx-filter} { $self describe $option ivalue -min 0 -max 255 }
	    {*hl* -cw-hang-time} { $self describe $option ivalue dvalue 10 -min 0 -max 1023 -units ms }
	    {*hl* -tx-buffer-latency} { $self describe $option ivalue dvalue 10 -min 0 -max 31 -units ms }
	    {*hl* -ptt-hang-time} { $self describe $option ivalue dvalue 4 -min 0 -max 31 -units ms }
	    {*hl* -predistortion-subindex} { $self describe $option ivalue -min 0 -max 255 }
	    {*hl* -predistortion} { $self describe $option ivalue -min 0 -max 15 }
	    {* -sentcolor} -
	    {* -unsentcolor} -
	    {* -skippedcolor} -
	    {* -background} -
	    {* -foreground} {
		#puts "describe $option $opt"
		$self describe $option color -values {white lightgrey grey darkgrey black red yellow green blue violet magenta}
	    }
	    {* -font} {
		$self describe $option font -values {TkFixedFont Courier {helvetica 10} {helvetica 12} {helvetica 14}}
	    }
	    {* -size} { $self describe $option enum -values {8 16 32 64 128 256 512 1024 2048 4096 8192 16384}}
	    {* -planbits} { $self describe $option ivalue -min 0 -max 127}
	    {* -direction} {$self describe $option enum -values {-1 1}}
	    {* -polyphase} { $self describe $option ivalue -min 1 -max 32 }
	    {* -result} { $self describe $option enum -values {coeff mag2 mag dB short char}}
	    {* -min-f} {}
	    {* -max-f} {}
	    {* -center-freq} {}
	    {* -tuned-freq} {}
	    {* -sample-rate} { $self describe $option enum -values {48000} }
	    {*spectrum* -min} -
	    {*spectrum* -max} { $self describe $option ivalue -min -200 -max 30 -step 10 -units dB }
	    {* -zoom} { $self describe $option enum -values {0.5 1 2 4 8 16 32 64} }
	    {* -pan} { $self describe $option ivalue -min 200000 -max 200000 } 
	    {* -command} {}
	    {* -pal} { $self describe $option enum -values {0 1 2 3 4 5} }
	    {* -atten} {}
	    {* -automatic} {}
	    {* -smooth} { $self describe $option bool }
	    {* -multi} { $self describe $option ivalue -min 1 -max 64 }
	    {* -band-low} -
	    {* -band-high} { $self describe $option value -min 100 -max 37999999 -units Hz }
	    {* -rx-frames-per-call} { $self describe $option text ronly 1 volatile 1 }
	    {* -tx-frames-per-call} - 
	    {* -bs-frames-per-call} { $self describe $option text ronly 1 }
	    {* -length} { $self describe $option enum -values {64 128 256 512 1024} }
	    {* -filter-low} -
	    {* -filter-high} -
	    {* -low} - 
	    {* -high} { $self describe $option value -format %.0f -min -10000 -max 10000 -step 50 -units Hz}
	    {*radio* -mode} { $self describe $option enum -values {USB LSB DSB CWU CWL AM SAM FMN DIGU DIGL} }
	    {*radio* -mute} { $self describe $option bool }
	    {*radio* -spot} { $self describe $option bool }
	    {*agc* -mode} { $self describe $option enum -values {off long slow medium fast} }
	    {*agc* -target} { $self describe $option value info {target level, linear gain} -min 0.1 -max 10 }
	    {*agc* -attack} { $self describe $option ivalue info {attack time} -min 1 -max 4 -units ms }
	    {*agc* -decay} { $self describe $option ivalue info {decay time} -min 100 -max 2000 -units ms }
	    {*agc* -slope} { $self describe $option value info {slope, as in y = slope * x + intercept} -min 0.5 -max 2 }
	    {*agc* -hang} { $self describe $option ivalue info {hang time} -min 50 -max 1000 -units ms }
	    {*agc* -fasthang} { $self describe $option ivalue info {fast hang time} -min 50 -max 200 -units ms }
	    {*agc* -max} { $self describe $option value info {max level} -min 1 -max 1e5 }
	    {*agc* -min} { $self describe $option value info {min level} -min 1e-5 -max 1 }
	    {*agc* -threshold} { $self describe $option value info {threshold level} -min 0.25 -max 4 }
	    {*iq* -swap} { $self describe $option bool }
	    {*iq* -delay} { $self describe $option enum info {delay I by one sample, no delay, or delay Q by one sample} -values {-1 0 1} }
	    {*iq-correct* -rate} { $self describe $option value info {the learning rate for the adaptive filter} -min -1e6 -max 1e6 }
	    {*audio-tap* -log2n} { $self describe $option enum -values {1 2 3 4 5 6 7 8} }
	    {*audio-tap* -log2size} { $self describe $option enum -values {8 9 10 11 12 13 14 15 16} }
	    {*audio-tap* -complex} { $self describe $option bool }
	    {*leveler* -mode} { $self describe $option enum -values {off leveler} }
	    {*iambic* -keyer} { $self describe $option enum -values [get-iambic-keyers] }
	    {*latency-timing* -reduce} -
	    {*meter* -reduce} { $self describe $option enum -values {abs-real abs-imag max-abs mag2} }
	    {*latency-timing* -period} -
	    {*meter* -period} { $self describe $option value -min 1 -max 4000 -step 1 -units samples }
	    {*latency-timing* -decay} -
	    {*meter* -decay} { $self describe $option value -min 0.001 -max 0.999 -step 0.001 }
	    {*meter* -style} { $self describe $option enum -values {s-meter} }
	    {*noise* -level} { $self describe $option value -format %.0f -min -160 -max 0 -step 1 -units dB }
	    {*midi-tap-view* -tap*} -
	    {*cw-latency-timing* -mtap*} -
	    {*cw-latency-timing* -atap*} -
	    {*cw-decode-view* -detime} -
	    {*cw-encode-input* -ascii} -
	    {*goertzel-char* -ins} -
	    {*goertzel-char* -osc} -
	    {*goertzel-char* -noise} -
	    {*goertzel-char* -insert} -
	    {*goertzel* -filter?} -
	    {*goertzel* -tap} {
		#puts "$self describe text $option"
		$self describe $option text
	    }
	    {*goertzel-char* -replications} {
		$self describe $option value -min 1 -max 32 -step 1 -units samples
	    }
	    * { puts "populate $name $opt: no clues" }
	}
    }

    #
    # the part dealing with components
    #
    method is-component {name} { return [dict exists $data(comps) $name] }

    method find-packages {} {
	# get the directory name of the script
	set dirname [file dirname [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]]

	# find the list of sdrtcl::*, sdrtk::*, and sdrtcltk::* packages
	foreach lib {sdrtcl sdrtk sdrtcltk} {
	    set pkgIndex [file join $dirname .. lib $lib pkgIndex.tcl]
	    set pfp [open $pkgIndex r]
	    foreach line [split [string trim [read-file $pkgIndex]] \n] {
		if {[regexp "${lib}::" $line]} {
		    dict set data(pkgs) [lindex $line 2] {}
		}
	    }
	}
    }

    method packages {} { return [dict keys $data(pkgs)] }
    
    method parse {composite} {
	# first part identifies the sdrtcl component
	# second part is the jack client name
	if {[llength [split $composite @]] == 2} {
	    return [concat $composite [split $composite @]]
	} else {
	    return [list $composite $composite $composite]
	}
    }
    
    method find-factory {composite factory} {
	# search through the sdrtcl/sdrtk/sdrtcltk component list
	# for components which match $factory
	# exact match to tail of name first, then with glob on tail
	set candidates [lsearch -all -inline [$self packages] *$factory]
	if {[llength $candidates] == 0} {
	    set candidates [lsearch -all -inline [$self packages] *$factory*]
	}
	if {[llength $candidates] == 0} { error "no match for component '$composite'" }
	if {[llength $candidates] > 1} { 
	    error "too many matches for component '$composite', '[join $candidates {, }]'"
	}
	# we found one candidate
	set factory [lindex $candidates 0]
	return $factory
    }
    
    method load {composite} {
	# parse the composite into parts
	foreach {composite factory name} [$self parse $composite] break
	set factory [$self find-factory $composite $factory]
	# require the implementation, only loads once
	package require $factory
	# instantiate component
	# and activate if necessary
	set args {}
	# puts "load $composite with $factory $name"
	switch -glob $factory {
	    sdrtcl::* { 
		if {[has-server] && [get-server] ne {}} { lappend args -server [get-server] }
		set window {}
		$factory ::$name {*}$args
		$name activate
	    }
	    sdrtk::* { 
		toplevel .$name -class "keyer/$name"
		wm title .$name "keyer/$name"
		set window .$name.$name
		#wm iconphoto .$name -default icon1 icon2
		# no  {*}$args because it's only sdrtcl -server
		pack [$factory $window] -side top -expand true -fill both
		# puts "packed $window"
		wm withdraw .$name
		wm deiconify .$name
	    }
	    sdrtcltk::* {
		if {[has-server] && [get-server] ne {}} { lappend args -server [get-server] }
		toplevel .$name -class "keyer/$name"
		wm title .$name "keyer/$name"
		#wm iconphoto .$name -default icon1 icon2
		set window .$name.$name
		pack [$factory $window {*}$args] -side top -expand true -fill both
		$window activate
		wm withdraw .$name
		wm deiconify .$name
	    }
	    default { error "$factory did not match switch" }
	}
	return [list $name $factory $window $composite]
    }
    
    method define {name factory window composite} {
	dict set kcomps $name [dict create name $name factory $factory window $window composite $composite]
	#dict lappend kpkgs $factory $name
    }
    
    method process {composite} {
	# puts "keyer::options::process-start $composite: argvopts [get-argvopts]"
	foreach {name factory window composite} [$self load $composite] break
	# puts "keyer::options::process-after-load $composite: argvopts [get-argvopts]"
	$self define $name $factory $window $composite
	# puts "keyer::options::process-after-define $composite: argvopts [get-argvopts]"
	$self populate $name $factory $window $composite
	# puts "keyer::options::process-finish $composite: argvopts [get-argvopts]"
    }
    
    method populate {name factory window composite} {
	if {$window ne {}} {
	    set call $window
	    set opts [$window exposed-options]
	    # puts "populate $name $factory $window $composite -> opts $opts"
	} else {
	    set call $name
	    set opts [$name info options]
	}
	dict set components $name call $call
	foreach opt $opts {
	    # $opt is the option name used in direct configure and cget commands to $comp
	    if {[$self is-option -$name$opt]} { error "keyer-components::populate: $name $opt ... is a duplicate" }
	    set result [$call configure $opt]
	    foreach {copt cname cclass cdefault cvalue} $result break
	    # $copt should be $opt
	    if {$opt ne $copt} { error "keyer-components::populate: $call configure $opt returned a different option name $copt" }
	    # $cname is the option name in the option database (not used here)
	    # $cclass is the option class name in the option database (not used here)
	    # $cdefault is the default value
	    # $cvalue is the current value
	    if {[catch {$call info option $opt} info]} { set info [$call info-option $opt] }
	    # $info is the tool tip for the option
	    set merge [the-merge $opt]; # the merge pattern that matched this opt
	    set hide [expr {[is-hide $opt] || [is-hide -$name$opt]}];    # the opt matched a hide pattern
	    set favor [is-favor $opt];  # the opt is in the favorite list
	    set argvopts [is-argvopts $opt]; # the opt was in the argv
	    set option [dict create \
			    text -$name$opt factory $factory name $name opt $opt window $window call $call \
			    cname $cname cclass $cclass cdefault $cdefault cvalue $cvalue info $info type none \
			    merge $merge hide $hide favor $favor ronly 0 conly 0 volatile 0 isargv $argvopts \
			    composite $composite]
	    # $option is the option dict for -$name$opt
	    $self populate-option $name $opt $option
	}
    }
}

proc dial-cset {opt val} { ::options configure $opt $val }
proc dial-cget {opt} { return [::options cget $opt] }
proc dial-cvar {opt} { return [::options cvar $opt] }

#
# manage option preferences
# match patterns in lists
#
proc the-match {opt list} {
    foreach pat $list { if {[string match $pat $opt]} { return $pat } }
    return {}
}
proc is-matched {opt list} { return [expr {[the-match $opt $list] ne {}}] }

proc get-favor {} { return [::options get-favor] }
proc has-favor {} { return [::options has-favor] }
proc lappend-favor {args} { ::options add-favor {*}$args }
proc the-favor {o} { return [the-match $o [::options get-favor]] }
proc is-favor {o} { return [is-matched $o [::options get-favor]] }

proc has-merge {} { return [::options has-merge] }
proc lappend-merge {args} { ::options add-merge {*}$args }
proc the-merge {o} { return [the-match $o [::options get-merge]] }

proc get-hide {} { return [::options get-hide] }
proc has-hide {} { return [::options has-hide] }
proc lappend-hide {args} { ::options add-hide {*}$args }
proc is-hide {o} { return [is-matched $o [::options get-hide]] }

#
# setups are macros defining component instances with additional information
# setups bind an implementation to a instance and supply some option values
# saving all setups in one file makes it hard to change the prebuilt setups
# should only save those which are different from the prebuilt defaults
# and should save setup name to ~/.config/keyer/setups/name.tcl
#

package require getstring
namespace import getstring::*

snit::type keyer::setups {

    variable setups [dict create]
    
    constructor {args} {
	$self load-setups
    }

    method add-setup {name val} { dict set setups $name $val }
    method is-setup {name} { return [dict exists $setups $name] }

    method get-names {} { return [dict keys $setups] }
    method get-start {name} { return [dict get $setups $name start] }
    method get-info {name} { return [dict get $setups $name info] }
    method get-ports {name} { if {[dict exists $setups $name ports]} { return [dict get $setups $name ports] } else { return {} } }
    method get-connect {name} { if {[dict exists $setups $name connect]} { return [dict get $setups $name connect] } else { return {} } }

    method build-command-line {} {
	set argv [file tail $::script]
	if {[get-server] ne {}} { lappend argv -server [get-server] }
	lappend argv -start [get-start]
	# prefer specifically named options
	# to the ones that are only inferred from component inspection
	foreach opt [::options get-opts] {
	    if { ! [::options is-default $opt]} {
		lappend argv $opt $::value($opt)
	    }
	}
	# now find the pertinent -merge -hide etc lists
	if {[has-merge]} { lappend argv -merge [lsort -unique [get-merge]] }
	if {[has-hide]} { lappend argv -hide [lsort -unique [get-hide]] }
	return $argv
    }

    method save-current-setup {} {
	# prompt for name
	if {[tk_getString .gs text "Name for setup:"] && [tk_getString .gs info "Description:"]} {
	    $self add-setup $text [dict create start [$self build-command-line] info $info]
	    $self save-setups
	}
    }

    method save-setups {} {
	# only save setups that do not match default setups
	set defs [$self default-setups]
	set fp [open ~/.config/keyer/setups.tcl w]
	puts $fp "dict create {*}{"
	dict for {key value} $setups {
	    if {[dict exists $defs $key] && $value eq [dict get $defs $key]} continue
	    puts $fp "  $key { [string trim $value] }"
	}
	puts $fp "}"
	close $fp
    }
    
    method merge-default-setups {} {
	set up 0
	dict for {key value} [$self default-setups] {
	    if { ! [dict exists $setups $key] } {
		dict set setups $key $value
		incr up
	    }
	}
	return $up
    }
    
    method init-setups {} {
	# config file does not exist or error reading it
	if { ! [file exists ~/.config]} { file mkdir ~/.config }
	if { ! [file exists ~/.config/keyer]} { file mkdir ~/.config/keyer }
	set setups [$self default-setups]
	$self save-setups
	if {[catch {source ~/.config/keyer/setups.tcl} result]} {
	    error "failed to create default configs: $result"
	}
    }
    
    method load-setups {} {
	if { ! [file exists ~/.config/keyer/setups.tcl] || 
	     [catch {source ~/.config/keyer/setups.tcl} result]} {
	    $self init-setups
	} else {
	    set setups $result
	    if {[$self merge-default-setups]} {
		$self save-setups
	    }
	}
    }
    
    variable defaults [dict create {*}{ 
	keyo {
	    start { keyer -start keyer-tone@keyo }
	    info { a keyed oscillator }
	}
	key {
	    start { keyer -start keyer-iambic@key -run keyo -key-wpm 17 -keyo-ramp 4.0 -key-mode B }
	    info { iambic keyer and a keyed oscillator }
	    connect { {?system:midi_capture_1 ?system:midi_capture_2 ?system:midi_capture_3 ?cas:midi_out} key:midi_in key:midi_out keyo:midi_in }
	}
	key2 { 
	    start {keyer -start {keyer-iambic@key2 keyer-tone@key2o} -key2-wpm 16 -key2-note 2 -key2-mode B -key2-alsp 1 -key2o-ramp 4.0 -key2o-note 2 }
	    info { second iambic keyer and keyed oscillator }
	    connect { key2:midi_out key2o:midi_in }
	}
	kbd {
	    start { keyer -start {sdrtcl::keyer-ascii@kbd sdrtk::cw-encode-input@enc keyer-tone@kbdo} -kbd-wpm 80 -kbdo-ramp 6.6 -enc-ascii kbd }
	    info {keyboard keyer and a keyed oscillator}
	    connect { kbd:midi_out kbdo:midi_in }
	}
	kbd2 {
	    start { keyer -start {sdrtcl::keyer-ascii@kbd2 sdrtk::cw-encode-input@enc2 keyer-tone@kbd2o} -kbd2-wpm 80 -kbd2o-ramp 6.6 -enc2-ascii kbd2 }
	    info {second keyboard keyer and a keyed oscillator}
	    connect { kbd2:midi_out kbd2o:midi_in }
	}
	ptt {
	    start { keyer -start {keyer-ptt@ptt} }
	    info {push-to-talk switch with tx delay}
	}
	deb {
	    start { keyer -start {keyer-debounce@deb} }
	    info {key contact debouncer}
	}
	cas {
	    start { keyer -start {midi-insert-key@cas} -cas-dit Alt_R -cas-dah Control_R }
	    info {midi events from keyboard keys}
	    note { should this be cas:midi_capture_1? }
	}
	mtap {
	    start { keyer -start {sdrtcl::midi-tap@mtap} }
	    info {raw midi tap}
	}
	mtap2 {
	    start { keyer -start {sdrtcl::midi-tap@mtap2} }
	    info {second raw midi tap}
	}
	atap {
	    start { keyer -start {sdrtcl::audio-tap@atap} }
	    info {raw audio sample tap}
	}
	atap2 {
	    start { keyer -start {sdrtcl::audio-tap@atap2} }
	    info {second raw audio sample tap}
	}
	ins {
	    start { keyer -start midi-insert@ins }
	    info {start midi insert node}
	}
	tap {
	    start { keyer mtap -start {midi-tap-view@tap} -tap-tap mtap }
	    info {midi monitor for timing events}
	}
	tap2 {
	    start { keyer -start {midi-tap-view@tap2} }
	    info {second midi monitor for timing events}
	}
	detone {
	    start { keyer -start {sdrtcl::filter-goertzel@detone} }
	    info {goertzel audio filter to detect cw tone}
	}
	detone2 {
	    start { keyer -start {sdrtcl::filter-goertzel@detone2} }
	    info {second goertzel audio filter to detect cw tone}
	}
	fg {
	    start { keyer -start {filter-goertzel@fg} }
	    info {real valued Goertzel filter to detect cw tone}
	}
	fcg {
	    start { keyer -start {filter-complex-goertzel@fcg} }
	    info {complex valued Goertzel filter to detect cw tone}
	}
	detime {
	    start { keyer -start {keyer-detime@detime} }
	    info {key event to dits, dahs, and spaces translator}
	}
	detime2 {
	    start { keyer -start {keyer-detime@detime2} }
	    info {second key event to dits, dahs, and spaces translator}
	}
	out {
	    start { keyer detone detime -start {sdrtk::cw-decode-view@out} -out-detime detime -detime-wpm 17}
	    info {audio to ascii morse decoder}
	    connect { detone:midi_out detime:midi_in }
	}
	hl {
	    start { keyer -start {hl-connect@hl} -hl-client hl -hide {-hl-raw-* -hl-avg-* -hl-hw-*} }
	    info { hermes lite udp jack connection }
	}
	noise {
	    start { keyer -start {iq-noise@noise} }
	    info { iq correlated noise generator }
	}
	spec {
	    start { keyer -start {spectrum-waterfall-view@spec}}
	    info { spectrum and waterfall display }
	}
	spec2 {
	    start { keyer -start {spectrum-waterfall-view@spec2}}
	    info { spectrum and waterfall display }
	}
	filt {
	    start { keyer -start {filter-overlap-save@filt} -filt-low 0 -filt-high 1400 }
	    info { overlap save bandpass filter }
	}
	nod {
	    start { keyer -hide {*-dit *-dah *-ies *-ils *-iws *-awsp *-word *-weight *-ratio *-comp *-mdit *-mdah *-mide} }
	    info {hide esoteric keyer options}
	}
	noc {
	    start { keyer -hide {*-client *-server *-verbose *-chan} }
	    info {hide common useless options}
	}
	1ch {
	    start { keyer -merge {*-chan *-note} }
	    info {merge midi channel and note options}
	}
	key+out {
	    start { keyer key out}
	    info {iambic keyer and decoder}
	    connect {
		keyo:out_i detone:in_i
		keyo:out_i {system:playback_1 system:playback_2}
	    }
	}
	xsco {
	    start { keyer -exec {x42-scope -j xsc >& ~/.config/keyer/xsco.log} }
	    info { x42-scope, 4 channel scope jack plugin }
	}
	xspe {
	    start { keyer -exec {x42-spectr -j xspe >& ~/.config/keyer/xspe.log} }
	    info { x42-spectr, audio spectrum analyser jack plugin }
	}
	xmet {
	    start { keyer -exec {x42-meter -j xmet >& ~/.config/keyer/xmet.log} }
	    info { x42-meter, audio level meter jack plugin }
	}

	hlt {
	    start { keyer -start {hl-test@hlt} -keyo-gain -6 -hl-low-pwr 1 -hl-lna-db 14 -hl-pa 0 }
	    info { hermes lite test dashboard }
	}
	test {
	    start { keyer key kbd out hl spec filt hlt -tree 1 } 
	    info { hermes lite test app }
	    connect { {key kbd} {out hl} hl {spec filt} }
	}
	delay {
	    start { keyer -start {sample-delay@delay} -eval { delay start }}
	    info { iq delay }
	}
	gain {
	    start { keyer -start {gain@gain} }
	    info { iq gain/attenuation }
	}
	gain2 {
	    start { keyer -start {gain@gain2} }
	    info { second iq gain/attenuation }
	}
	cwt {
	    start { 
		keyer gain detone mtap atap delay gain2 detone2 mtap2 atap2 nod noc
		-start cw-latency-timing@cwt -cwt-mtap1 mtap -cwt-mtap2 mtap2 -cwt-atap1 atap -cwt-atap2 atap2
		-gain-gain 0 -gain2-gain 0
		-detone-bandwidth 187.5 -detone2-bandwidth 187.5
	    }
	    info { cw latency detection widget }
	    connect {
		gain:out_i {detone:in_i atap:in_i delay:in_i} 
		gain:out_q {atap:in_q delay:in_q}
		detone:midi_out mtap:midi_in
		delay:out_i gain2:in_i 
		delay:out_q gain2:in_q
		gain2:out_i {detone2:in_i atap2:in_i system:playback_1 system:playback_2}
		gain2:out_q atap2:in_q
		detone2:midi_out mtap2:midi_in
	    }
	    ports {
		cwt1:in_i
		cwtm1:in_i cwtm1:in_q
		cwtd:in_i cwtd:in_q
	    }
	}
	cwtest {
	    start { keyer key cwt }
	    info { cw latency detection debugging }
	    connect { 
		{?system:midi_capture_1 ?cas:midi_out} key:midi_in 
		keyo:out_i {system:playback_1 gain:in_i}
		keyo:out_q {system:playback_2 gain:in_q}
	    }
	}
	filter-test {
	    start { keyer noise spec filt spec2 -noise-level -50 -filt-length 512 -filt-low 0 -filt-high 1400 -spec-filter-low 0 -spec-filter-high 1400}
	    info { test operation of overlap save filter on noise source }
	    connect { 
		noise:out_i filt:in_i noise:out_q filt:in_q 
		noise:out_i spec:in_i noise:out_q spec:in_q 
		filt:out_i spec2:in_i filt:out_q spec2:in_q 
	    }
	}
	goertzel-test {
	    start { keyer cas key noise fg fcg mtap nod noc -start {sdrtk::goertzel-graph@win} 
		-fg-note 8 -fcg-note 16 -win-filter1 fg -win-filter2 fcg -win-tap mtap}
	    info { test operation of goertzel filter on keyed tone }
	    connect { 
		{?system:midi_capture_1 cas:midi_out} key:midi_in
		{keyo:out_i noise:out_i} {system:playback_1 system:playback_2 fg:in_i fcg:in_i}
		{keyo:out_q noise:out_q} fcg:in_q
		{key:midi_out fg:midi_out fcg:midi_out} mtap:midi_in
		keyo:out_i ?xsc:in1 
		?fg:out_i ?xsc:in2
		?fcg:out_i ?xsc:in3
		?fcg:out_q ?xsc:in4
	    }
	}
	goertzel-characterize {
	    start { keyer ins keyo noise fg fcg -start sdrtk::goertzel-characterize@top
		-top-ins ins -top-osc keyo -top-noise noise -top-filter1 fg -top-filter2 fcg}
	    info { characterize goertzel filters performance with different parameters }
	    connect { 
		{keyo:out_i noise:out_i} {fg:in_i fcg:in_i}
		{keyo:out_q noise:out_q} fcg:in_q
		ins:midi_out keyo:midi_in
	    }
	}
    }]
    method default-setups {} { return $defaults }
}
proc is-setup {name} { return [::setups is-setup $name] }
proc get-setup-names {} { return [::setups get-names] }
proc get-setup-info {name} { return [::setups get-info $name] }
proc get-setup-start {name} { return [::setups get-start $name] }
proc get-setup-connect {name} { return [::setups get-connect $name] }

#
# miscellaneous argv options
#
snit::type keyer::argv {
    variable data -array { opts {} }
    constructor {args} { set data(opts) [dict create] }
    method exists {name} { return [dict exists $data(opts) $name] }
    method lappend {name args} { dict lappend data(opts) $name {*}$args }
    method set {name val} { dict set data(opts) $name $val }
    method get {name} { return [dict get $data(opts) $name] }
    method names {} { return [dict keys $data(opts)] }
}

# these are options and groups of options collected from argv

proc get-server {} { return [::argv get -server] }
proc has-server {} { return [::argv exists -server] }

proc get-title {} { return [::argv get -title] }
proc has-title {} { return [::argv exists -title] }

proc get-grid {} { return [::argv get -grid] }
proc has-grid {} { return [::argv exists -grid] }

proc get-tree {} { return [::argv get -tree] }
proc has-tree {} { return [::argv exists -tree] }

proc get-start {} { return [::argv get -start] }
proc has-start {} { return [::argv exists -start] }

proc get-eval {} { return [::argv get -eval] }
proc has-eval {} { return [::argv exists -eval] }

proc get-exec {} { return [::argv get -exec] }
proc has-exec {} { return [::argv exists -exec] }

proc get-connect {} { return [::argv get -connect] }
proc has-connect {} { return [::argv exists -connect] }

proc get-argvopts {} { return [::argv get -argvopts] }
proc has-argvopts {} { return [::argv exists -argvopts] }
proc is-argvopts {o} { return [expr {[has-argvopts] && [is-matched $o [get-argvopts]]}] }

# user interface components
# primary user interface component is the dialbook
# which isn't finished.

#
# update the window
# this doesn't work when -wpm, -window, and -window2 aren't obvious
# extracted from keyer-options::configure-timeout when merged into koptions
# hmm, none of this is going to work any more, and it should be lower 
# after idle [list update-window-title]
#
proc update-window-title {} {
    if {0} {
	if {[info exists ::value(-wpm)] && [info exists ::value(-window2)]} {
	    if {$::value(-window2) ne {none}} {
		set title "recri keyer $::value(-wpm) wpm $::value(-window)*$::value(-window2)"
	    } else {
		set title "recri keyer $::value(-wpm) wpm $::value(-window)"
	    }
	} elseif {[info exists ::value(-freq)] && [info exists ::value(-window2)]} {
	    if {$::value(-window2) ne {none}} {
		set title "recri keyer $::value(-freq) Hz $::value(-window)*$::value(-window2)"
	    } else {
		set title "recri keyer $::value(-freq) Hz $::value(-window)"
	    }
	} else {
	    set title "recri keyer"
	}
    }
    set title {recri keyer}
    if {[has-title]} { set title [get-title] }
    wm title . $title
}

#
# load the main ui for the program
#
proc load-ui {} {
    set args {}
    if {[has-grid]} { lappend args -grid [get-grid] }
    if {[has-tree]} { lappend args -tree [get-tree] }
    #.p add [::sdrtk::dialbook .p.dial {*}$args]
    #toplevel .dial
    wm title . keyer/dial
    pack [::sdrtk::dialbook .dial {*}$args]
    array set compid {}
    foreach text [::options get-opts] {
	set cvalue [::options cget $text]
	set type [::options get $text type]
	set name [::options get $text name]
	set opt [::options get $text opt]
	set info [::options get $text info]
	set readout [::options get $text readout]
	set var [::options cvar $text]
	
	# if already processed, error
	if {[::options is-processed $text]} { error "$text already processed" }
	::options set $text processed 1
	
	if {[is-hide $text]} continue
	
	set w .dial.x$text
	package require sdrtk::readout-$type
	sdrtk::readout-$type $w -dialbook .dial \
	    -text $text -info $info {*}$readout \
	    -value $cvalue -variable $var -command [list ::options configure $text]
	#if {$text in {-key-wpm -key-weight}} { $w test }
	.dial add $w $name $type -text $text
    }
    if {[.dial select] eq {}} { .dial select 0 }
}

#
#
#
proc usage-message {} {
    puts "usage: keyer setup ..."
    puts "setups: [get-setup-names]"
    foreach s [get-setup-names] {
	puts "  $s: [get-setup-info $s]"
    }
    exit 1
}

#
# process a list of arguments, always formatted as -option value pairs
#
proc main-argv {argv} {
    # peel off any number of setup names
    while {[llength $argv] > 0 && [is-setup [lindex $argv 0]]} {
	set v [lindex $argv 0]
	set argv [lrange $argv 1 end]
	main-argv [lrange [get-setup-start $v] 1 end]
	# puts "start $v -connect [get-setup-connect $v]"
	::argv lappend -connect {*}[get-setup-connect $v]
    }
    foreach {opt val} $argv {
	# -server - jack server
	# -title - window title
	# -run - saved setups to run by name
	# -start components - list of component@name to start
	# -exec args - command to run in background
	# -favor patterns - option patterns to favor
	# -hide patterns - option patterns to hide
	# -merge patterns - option patterns to merge
	# -grid 1 - use dialbook grid setup
	# -tree 1 - use dialbook tree setup
	# -eval 'script' - evaluate the script
	# -connect list of pairs to connect
	# otherwise - -option value pair to apply to parts
	switch -- $opt { 
	    -run { foreach v $val { main-argv [lrange [get-setup-start $v] 1 end] } }
	    -favor -
	    -hide -
	    -merge { ::options lappend $opt {*}$val }
	    -server -
	    -title -
	    -grid -
	    -tree { ::argv set $opt $val }
	    -eval { ::argv lappend $opt $val }
	    -exec { ::argv lappend $opt $val }
	    -start { ::argv lappend $opt {*}$val }
	    -connect { ::argv lappend $opt {*}$val }
	    default { 
		# puts "lappend -argvopts $opt $val"
		::argv lappend -argvopts $opt $val
	    }
	}
	# if {[has-argvopts]} { puts "argvopts [get-argvopts]" }
    }
}

package require sdrtcl::jack

# make-connections $args
# $args is a list of {from1 to1 from2 to2 ...}, 
# 1) connect $from to $to if both exist, $from is an output, and $to is an input
# 2) if $from or $to starts with a ?, connect it if it exists, otherwise skip it
# 3) allow from and to to be lists, connect each element of from to each element of to
# todo) allow from and to to be patterns which succeed if they match one port or an iq pair 
proc make-connections {} {
    if { ! [has-connect]} return
    set args [get-connect]
    # a dictionary of ports and descriptions
    set ports [sdrtcl::jack list-ports]
    foreach {flist tlist} $args {
	foreach from $flist {
	    if {[string match {\?*} $from]} {
		if { ! [dict exists $ports [string range $from 1 end]]} continue
		set from [string range $from 1 end]
	    }
	    if { ! [dict exists $ports $from] } { 
		puts "$from is not a port"
		continue 
	    }
	    if { ! ([dict get $ports $from direction] eq {output}) } { puts "$from is not an output port"; continue }
	    foreach to $tlist {
		if {[string match {\?*} $to]} {
		    if { ! [dict exists $ports [string range $to 1 end]] } continue
		    set to [string range $to 1 end]
		}
		# puts "connect $from $to"
		if { ! [dict exists $ports $to] } { 
		    puts "$to is not a port"
		    continue
		}
		if { ! ([dict get $ports $to direction] eq {input}) } { puts "$to is not an input port"; continue }
		if {$to ni [dict get $ports $from connections]} {
		    sdrtcl::jack connect $from $to
		}
	    }
	}
    }
}

proc main {argv} {
    
    # install application icon
    set dir [file join $::dirname .. icons]
    image create photo icon1 -file [file join $dir qrv96.png]
    image create photo icon2 -file [file join $dir qrv48.png]
    wm iconphoto . -default icon1 icon2

    # style, abolish invisible indicators
    # these apply to the -grid displayed widgets
    ttk::style configure "." -indicatordiameter 12
    ttk::style configure TCheckbutton -relief raised
    ttk::style configure TRadiobutton -relief raised
    
    # make label frame labels larger
    ttk::style configure TLabelframe.Label -font {Helvetica 14}

    # load or create ~/.config/keyer/setups.tcl
    ::keyer::setups ::setups
    
    # initialize options/components database
    keyer::options ::options

    # initialize argv option handling
    keyer::argv ::argv
    
    # make a usage message
    if {$argv eq {} || $argv eq {help}} { usage-message }
    
    # process arguments, first pass just to collect everything
    main-argv $argv
        
    # if nothing asked for, nothing gained
    if { ! [has-start] && ! [has-exec] && ! [has-eval] } { usage-message }

    # start components and collect their options
    if {[has-start]} { foreach composite [get-start] { ::options process $composite } }

    if {[has-eval]} { foreach x [get-eval] { eval $x } }

    if {[has-exec]} { foreach x [get-exec] { exec {*}$x & } }
    
    # connecting ports
    make-connections

    # process command line options for additional option definitions
    if {[has-argvopts]} {
	foreach {opt val} [get-argvopts] {
	    # puts "first process $opt $val"
	    if {[::options is-option $opt]} continue; # already defined
	    error "undefined option: $opt $val"
	    # something missing here? - FIX.ME?
	}
    }
    
    # build the ui with the extracted options
    load-ui
    
    # load the options collected from the command line
    if {[has-argvopts]} {
	# puts "second pass argvopts [get-argvopts]"
	foreach {opt val} [get-argvopts] { 
	    # puts "second process $opt $val"
	    if {$opt eq {-hl-discover}} {
		if {$val eq {discover}} {
		    package require sdrtcl::hl-discover
		    sdrtcl::hl-discover ::discover
		    set val [lindex [::discover discover] 0]
		}
		if {[dict exists $val -status]} {
		    if {[dict get $val -status] != 2} {
			error "-hl-discover specifies an unavailable hermes lite"
		    }
		    dict unset val -status
		}
		foreach {sopt sval} $val {
		    if {$sopt eq {-status}} continue
		    if {[catch {::options configure -hl$sopt $sval} error]} {
			puts "::options configure threw $error"
		    }
		}
		continue
	    }
	    # puts "configuring $opt $val"
	    if {[catch {::options configure $opt $val} error]} {
		puts "::options configure $opt $val threw $error"
		# if the $opt is -$comp for one of the setup components,
		# then apply it to each opt value pair in $val to get
		# -$comp$opt $value
		if {[llength $val] > 1 && ([llength $val]&1) == 0} {
		    foreach {option value} $val {
			if {[catch {::options configure $opt$option $value} error2]} {
			    puts "bad option: $opt $val"
			}
		    }
		} else {
		    puts "bad option: $opt $val"
		}
	    }
	}
    }
    
    # update window title
    update-window-title
    
}

main $argv

# todos from google keep
# [x] Fix ascii buffering error
# [ ] find average buffer use per character in keyer-ascii and act prudently
# [ ] move dialbook tab menu to menu button labelling the readout?
# [ ] rethink readout to normalize the hierarchical menu readout
# [ ] implement missing window functions
# [ ] work out how to fudge the dit clock to integral sample counts
# [ ] work out how to fudge the frequency to integral sample counts
# [ ] fix broken windows, check the others
# [ ] continue goertzel tuning.
# [ ] eliminate sdrtcltk, do not wrap sdrtcl::stuff inside widgets, keep
#	keep the options associated to their stuff, let sdrtk widgets take
#	the handle as an option
# current todo
# [ ] work out how to get enumerated widget names, so no explicit key key2 key3 ...
# [ ] catch window closures and cleanup
# [ ] hlt window using ::options for values
# [ ] cleanup printout from hl-connect
# [ ] make treeview sync with <Left><Right> dialbook
#	it's worse than unsync'ed, it fights
# [ ] implement option -merge
# [ ] implement option -chain
# [ ] dial-faves subtree with dial favorites
# [ ] get as reliable a startup as quisk
# [x] fix the volatile polling
# [x] wrap the setups in a snit::type
# [x] wrap the loose options in a snit::type
# [x] create treeview to organize options, etc.
# [x] all-options subtree with all options present
# [x] merge all options and details into one dict.
# [ ] types subtree specifying options on values for shared types
# [ ] out-connections subtree listing components and their sinks
# [ ] in-connections subtree listing components and their sources
# [ ] auto connection hints
# [ ] jackd start hints
# [ ] start jackd if necessary, retain connection to server messages
# [ ] perform connections if necessary
# [x] readout-values should limit dial movement to range of choices
# [x] readout-* should have consistent locations
# [x] make the window'ed components into sdrtk::packages
# [x] make mixed windowed dsp components into sdrtcltk::packages
# [ ] implement the snit info vs sdrtcl info fix
# [ ] make a readout-vfo which tunes nicely
# [x] bring up the overlap-save passband filter
# [x] bring up the polyphase spectrum/waterfall (which should run as a separate process?)
# [ ] run the polyphase spectrum/waterfall as a separate process/thread
# [ ] aggressive UI debouncing on all tunable components
# [ ] rewire the spectrum waterfall to the tuner.
# [ ] rewrite the tuner/radio component that switches bandpass filter and spectrum display
#	of bandpass envelope, and the modem bank
# [ ] can start qjackctl from the command line with a specified patch
#     qjackctl --start -active-patchbay=[path] --server-name=[label] --preset=[label]
#     but it may not be activated?
#
# old todo list
# [-] make the -rise-fall option sort after the -rise and -fall that it joins
# [-] make the -rise-fall option update the displayed -rise and -fall option values too
# [x] replace -rise-fall with -ramp option in the keyer-tone itself
# [x] wrap more of this into snit
# [x] generate the command line for a configured setup, save it, restore it
# [x] start using tklib
# [x] prompt for name for saved setup
# [ ] balloon help for options
# [ ] balloon help for setups
# [ ] balloon help for components
# [x] add empty units box to readout-enum
# [ ] implement dialbook dial labels
# [ ] implement recursive dialbook, where groups of related, boring options are pushed down into boxes
# [ ] implement dialbook detents and dial limits so it doesn't just spin.
# [x] allow keyer setup1 setup2 ... as syntactic sugar
# [x] end timer loop when cwtext queue empties
# [ ] end timer loop when dialbook-set queue empties
# [ ] implement midi -> OSC bridge (easy)
# [ ] implement OSC -> MIDI bridge (not so easy, alsa sequencer?)
# 
