#!/usr/bin/wish8.6
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# Copyright (C) 2018 by Roger E Critchlow Jr, Charlestown, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
set dirname [file dirname $script]
#
# append the ../lib directory to the Tcl search path
#
lappend auto_path [file join $dirname .. lib]

#
# find the list of sdrtcl::*
#
set packages [exec grep sdrtcl:: [file join $dirname .. lib sdrtcl pkgIndex.tcl] | awk {{print $3}} | sed -e s/sdrtcl:://g]


#
# utilities
#
proc read-file {file} {
    set fp [open $file r]
    set data [read $fp]
    close $fp
    return $data
}
proc write-file {file data} {
    set fp [open $file w]
    puts -nonewline $fp $data
    close $fp
}

#
# miscellaneous accessors

proc get-var {var} { return [dict get $::data(main) $var] }
proc set-var {var val} { return [dict set ::data(main) $var $val] }
proc has-var {var} { return [dict exists $::data(main) $var] }
proc lappend-var {var args} { dict lappend ::data(main) $var {*}$args }

proc has-setups {} { return [has-var -setups] }
proc get-setups {} { return [get-var -setups] }
proc set-setups {val} { set-var -setups $val }

proc has-server {} { return [has-var -server] }
proc get-server {} { return [get-var -server] }
proc set-server {server} { set-var -server $server }

proc has-dial {} { return 1 }
proc has-details {} { return 1 }

proc get-ascii {} { return [get-var -ascii] }
proc set-ascii {name} { set-var -ascii $name }
proc has-ascii {} { return [has-var -ascii] }

proc has-memories {} { return 0 }

proc get-detime {} { return [get-var -detime] }
proc set-detime {name} { set-var -detime $name }
proc has-detime {} { return [has-var -detime] }

proc get-insert {} { return [get-var -insert] }
proc set-insert {name} { set-var -insert $name }
proc has-insert {} { return [has-var -insert] }

proc get-tap {} { return [get-var -tap ] }
proc set-tap {name} { set-var -tap $name }
proc has-tap {} { return [has-var -tap ] }

proc lappend-start {args} { lappend-var -start {*}$args }
proc get-start {} { return [get-var -start] }
proc has-start {} { return [has-var -start ] }

proc lappend-argvopts {args} { lappend-var -argvopts {*}$args }
proc has-argvopts {} { return [has-var -argvopts] }
proc get-argvopts {} { return [get-var -argvopts] }

proc get-title {} { return [get-var -title] }
proc set-title {title} { set-var -title $title }
proc has-title {} { return [has-var -title] }

proc get-prefer {} { return [get-var -prefer] }
proc lappend-prefer {args} { lappend-var -prefer {*}$args }
proc has-prefer {} { return [has-var -prefer] }

proc get-merge {} { return [get-var -merge] }
proc lappend-merge {args} { lappend-var -merge {*}$args }
proc has-merge {} { return [has-var -merge] }

proc get-show {} { return [get-var -show] }
proc lappend-show {args} { lappend-var -show {*}$args }
proc has-show {} { return [has-var -show] }

proc get-hide {} { return [get-var -hide] }
proc lappend-hide {args} { lappend-var -hide {*}$args }
proc has-hide {} { return [has-var -hide] }

proc get-join {} { return [get-var -join] }
proc lappend-join {args} { lappend-var -join {*}$args }
proc has-join {} { return [has-var -join] }

# all components in the app share values for identically spelled options
# except where overridden
set ::data(defines) [dict create]
array set ::value {}
array set ::defval {}
proc opt-is-defined {opt} { return [dict exists $::data(defines) $opt] }
proc opt-define {opt comp {opt2 {}}} { dict lappend ::data(defines) $opt $comp [expr {$opt2 ne {} ? $opt2 : $opt}] }
proc opt-add-dependent {opt comp {opt2 {}}} { dict lappend ::data(defines) $opt $comp [expr {$opt2 ne {} ? $opt2 : $opt}]}
proc opt-component-opts {opt} { return [dict get $::data(defines) $opt] }
proc opt-primary {opt} { return [lindex [opt-components-opts $opt] 0] }
proc opt-get-opts {} { return [dict keys $::data(defines)] }

proc component-is-defined {comp} { return [dict exists $::data(components) $comp] }
proc component-define {comp} { dict set ::data(components) $comp {}}
proc components {} { return [dict keys $::data(components)] }
proc find-components {opt1 opt2} {
    array set found {}
    foreach {comp opt} [opt-component-opts $opt1] {
	set found($comp) 1
    }
    foreach {comp opt}  [opt-component-opts $opt2] {
	incr found($comp)
    }
    set result {}
    foreach comp [array names found] {
	if {$found($comp) == 2} {
	    lappend result $comp
	}
    }
    return $result
}
    
# load an sdrtcl component
# name is name1 or a name1@name2
# name1 specifies the sdrtcl component
# and name2 specifies the jack client name to use for it
# name2 defaults to name1
# name1 can be any string which uniquely identifies an sdrtcl component
# ambiguous ones throw an error with the list that matched
# 
proc sdrtcl-instance {component name2} {
    if {[has-server] && [get-server] ne {}} {
	$component $name2 -server [get-server]
    } else {
	$component $name2
    }
}

proc parse-component {name} {
    # name1 identifies the sdrtcl component
    # name2 is the jack client name
    if {[llength [split $name @]] == 2} {
	return [split $name @]
    } else {
	return [list $name $name]
    }
}
proc load-component {name} {
    foreach {name1 name2} [parse-component $name] break
    # search through the sdrtcl component list
    # for components which match name1
    set candidates {}
    foreach c $::packages {
	if {[string equal $name1 $c]} {
	    set candidates [list $c]
	    break
	} elseif {[string match *$name1* $c]} {
	    lappend candidates $c
	}
    }
    if {[llength $candidates] == 0} { error "no match for component '$name'" }
    if {[llength $candidates] > 1} { error "too many matches for component '$name', '[join $candidates {, }]'" }
    # we found one candidate
    set component [lindex $candidates 0]
    # load the implementation
    package require sdrtcl::$component
    # instantiate component
    sdrtcl-instance sdrtcl::$component $name2
    # activate component
    $name2 activate
    # remember this
    return [list $component $name2]
}

# user interface components
package require snit
namespace eval ::sdrtk {}
package require sdrtk::dialbook
package require sdrtk::readout-enum
package require sdrtk::readout-freq
package require sdrtk::readout-value


set data(options) {}

proc get-window-types {} {
    package require sdrtcl::window
    catch { sdrtcl::window foo 512 } error
    regexp {^unknown window type, should be one of (.*)$} $error all error
    regsub -all {, (or )?} $error { } error
    set error [lsort $error]
    set i [lsearch $error {none}]
    if {$i >= 0} {
	set error [concat none [lreplace $error $i $i]]
    }
    return $error
}

proc populate-option {name opt2 opt oname oclass odefault ovalue} {
    # name is the component
    # opt2 is a possibly composite name which references opt
    # opt is the option name in configure and cget commands
    # oname is the option name in the option database (not used here)
    # oclass is the option class name in the option database (not used here)
    # odefault is the default value
    # ovalue is the current value
    # info is the tool tip for the option, not presently used
    set info [$name info option $opt]

    # we are going to either define an option for -$name$opt2
    # or a merged option for plain $opt2 which covers all versions of $opt2

    # only keep the first of a series of definitions for the same $opt2
    # these are the merged versions
    if {[is-merge $opt2]} {
	if { ! [opt-is-defined $opt2]} {
	    # this is the first appearance of this $opt
	    opt-define $opt2 $name $opt
	    set text $opt2
	    set name {}
	} else {
	    # this is not the first appearance, daisy chain from the first
	    opt-add-dependent $opt2 $name $opt
	    return
	}
    } else {
	if { ! [opt-is-defined -$name$opt2]} {
	    opt-define -$name$opt2 $name $opt
	    set text -$name$opt2
	} else {
	    opt-add-dependent -$name$opt2 $name $opt
	    return
	}
    }
    # look for further guidance
    switch -glob -- $opt2 {
	-server - -client - -verbose {
	    # these are fixed, as in not modifiable
	    # well, verbose could be, but no one wants
	    # to see this running -verbose
	}
	-chan {
	    # remember each option component name, option name, and current value
	    # the {value} is the class of readout component that handles this option
	    # the list is additional options for the readout
	    # midi channel could as well be an {enum} with 16 values.
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -format %.0f -min 1 -max 16 -step 1]
	}
	-note {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -format %.0f -min 0 -max 127 -step 1]
	}
	-wpm {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -format %.1f -units wpm -min 5.0 -max 200.0 -step 0.5]
	}
	-swap - -mdit - -mdah - -mide - -alsp - -awsp {
	    lappend ::data(options) $name $opt2 $opt enum $ovalue [list -text $text -info $info -values {0 1}]
	}
	-mode {
	    lappend ::data(options) $name $opt2 $opt enum $ovalue [list -text $text -info $info -values {A B}]
	}
	-word {
	    lappend ::data(options) $name $opt2 $opt enum $ovalue [list -text $text -info $info -units dits -values {50 60}]
	}
	-dit - -dah - -ies - -ils - -iws { 
	    set min [expr {0.5*$ovalue}]
	    set max [expr {1.5*$ovalue}]
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -format %.1f -units dits -min $min -max $max -step 0.1]
	}
	-weight - -ratio {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -format %.1f -units % -min 0.0 -max 100.0 -step 0.1]
	}
	-comp {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -format %.1f -units ms -min -15.0 -max 15.0 -step 0.1]
	}
	-freq {
	    lappend ::data(options) $name $opt2 $opt freq $ovalue \
		[list -text $text -info $info -units Hz -format %.0f -min 500 -max 1500 -step 1]
	}
	-rise - -fall - -rise-fall {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -units ms -format %.1f -min 0.0 -max 15.0 -step 0.1]
	}
	-window {
	    lappend ::data(options) $name $opt2 $opt enum $ovalue \
		[list -text $text -info $info -values [lrange [get-window-types] 1 end]]
	}
	-window2 {
	    lappend ::data(options) $name $opt2 $opt enum $ovalue \
		[list -text $text -info $info -values [get-window-types]]
	}
	-gain {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -units dB -format %.1f -min -50 -max 0 -step 0.1]
	}
	-delay {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -units ms -format %.2f -min 0.0 -max 1000 -step 0.01]
	}
	-hang {
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -units ms -format %.1f -min 0.0 -max 1000 -step 0.1]
	}
	-period {
	    # for the debouncer
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -units ms -format %.3f -min 0.0 -max 1.000 -step 0.001]
	}
	-steps {
	    # for the debouncer
	    lappend ::data(options) $name $opt2 $opt value $ovalue \
		[list -text $text -info $info -format %.0f -min 1 -max 32 -step 1]
	}
	-dict {
	    # for the ascii keyer
	}
	-bandwidth {
	    # for the unkeyer detone module
	    # bandwidth BWHertz 100.0 100.0 bandwidth of output signal in Hz
	    lappend ::data(options) $name $opt2 $opt freq $ovalue \
		[list -text $text -info $info -units Hz -format %.0f -min 10 -max 1000 -step 1]
	}
	default {
	    puts "$name $opt2 {$opt $oname $oclass $odefault $ovalue} $info"
	}
    }
}

proc populate-component-options {component name} {
    # most of this could be greatly simplified by defining a 'type' for each
    # option which specified the kind of values, ranges, step size, etc.
    # for the options.  also of interest is whether we are dealing with a live
    # jack component or something that throw busy errors,
    # everything so far has been an sdrtcl:: jack component, but they could be 
    # wrapped, I'd almost prefer them to handle the busy defer on their own, but
    # then I'd need a timer associated to the wrappers, a type component as it
    # were.
    foreach opt [$name info options] {
	populate-option $name $opt {*}[$name configure $opt]
    }
}

# sort the options so the most used are first
# remove options 
#  pref {-wpm -swap -mode -freq -gain -rise -fall -window -window2}
#  hide {-alsp -awsp}
proc prefer-component-options {prefs} {
    set options $::data(options)
    set ::data(options) {}
    foreach {comp opt2 opt type value opts} $options {
	if {[is-prefer $opt]} {
	    lappend ::data(options) $comp $opt2 $opt $type $value $opts
	}
    }
    foreach {comp opt2 opt type value opts} $options {
	if { ! [is-prefer $opt]} {
	    lappend ::data(options) $comp $opt2 $opt $type $value $opts
	}
    }
}
proc hide-component-options {hide} {
    set options $::data(options)
    set ::data(options) {}
    foreach {comp opt2 opt type value opts} $options {
	if {[lsearch $hide $opt] < 0} {
	    lappend ::data(options) $comp $opt2 $opt $type $value $opts
	}
    }
}
#
# control window.
# this one line frame controls which other windows are displayed
# and acts as a focus target for controlling the keyer while 
# minimized.
#
proc keyer-widget {w} {
    ttk::frame $w
    foreach {tag text} {
	dial Settings
	insert Keys
	memories Memories
	ascii Input
	detime Output
	tap Events
	details Details
    } {
	if {[has-$tag]} {
	    ttk::checkbutton $w.$tag -text $text -variable ::data(show-$tag) -command [list keyer-widget-show $w $tag]
	    pack $w.$tag -side left
	}
    }
    return $w
}
proc keyer-widget-show {w tag} {
    if {$::data(show-$tag)} {
	.p add .p.$tag
    } else {
	.p forget .p.$tag
    }
}
#
# dial setting, most options are delegated to the dial book
# one dial for setting everything.
#
proc dial-set {opt val} {
    if {[opt-is-defined $opt]} {
	set ::value($opt) $val
	foreach {comp opt2} [opt-component-opts $opt] {
	    dict set ::data(busy) $comp $opt2 $val
	    if { ! [$comp is-busy]} {
		set opts [dict get $::data(busy) $comp]
		if {[catch {
		    $comp configure {*}$opts
		    dict unset ::data(busy) $comp
		} error]} {
		    puts "dial-set configure $opts threw $error"
		}
	    } else {
		# puts "$comp is-busy"
	    }
	}
    } else {
	error "$opt is not defined in dial-set"
    }
}

proc dial-set-timeout {} {
    dict for {comp opts} $::data(busy) {
	if { ! [$comp is-busy]} {
	    if {[catch {
		$comp configure {*}$opts
		set ::data(busy) [dict unset $::data(busy) $comp]
	    } error]} {
		puts "dial-set configure $opts threw $error"
	    }
	} else {
	    # puts "$comp is-busy"
	}
    }
    # hmm, none of this is going to work any more
    if {[info exists ::value(-wpm)] && [info exists ::value(-window2)]} {
	if {$::value(-window2) ne {none}} {
	    set title "recri keyer $::value(-wpm) wpm $::value(-window)*$::value(-window2)"
	} else {
	    set title "recri keyer $::value(-wpm) wpm $::value(-window)"
	}
    } elseif {[info exists ::value(-freq)] && [info exists ::value(-window2)]} {
	if {$::value(-window2) ne {none}} {
	    set title "recri keyer $::value(-freq) Hz $::value(-window)*$::value(-window2)"
	} else {
	    set title "recri keyer $::value(-freq) Hz $::value(-window)"
	}
    } else {
	set title "recri keyer"
    }
    if { ! [has-title] || [get-title] ne $title} {
	wm title . $title
	set-title $title
    }
    after 100 dial-set-timeout
}

proc dial-set-init {} {
    set ::data(busy) [dict create]
    dial-set-timeout
}

#
# insert window management
# a simple frame which, when focused, generates key events
# for control, alt, and shift keys
#
snit::widgetadaptor midi-insert {
    option -ditkey -default Alt_R -configuremethod Configure 
    option -dahkey -default Control_R -configuremethod Configure 
    option -key -default none -configuremethod Configure
    option -insert -default {} -configuremethod Configure

    method delete {args} {}
    method insert {args} {}
    delegate method ins to hull as insert
    delegate method del to hull as delete
    
    delegate method * to hull
    delegate option * to hull

    variable chan
    variable base
    
    method exposed-options {} { return {-ditkey -dahkey -key} }
    method is-busy {} { return 0 }
    
    constructor {args} {
	installhull using text
	$self configure -width 30 -height 1 {*}$args
	$self bind-key $options(-ditkey) dit
	$self bind-key $options(-dahkey) dah
	set chan [$options(-insert) cget -chan]
	set base [$options(-insert) cget -note]
	$self label
    }

    method label {} {
	$self del 1.0 end
	if {$options(-ditkey) ne {none} && $options(-dahkey) ne {none}} {
	    $self ins end "click this window then press $options(-ditkey) for dit, $options(-dahkey) for dah"
	} elseif {$options(-key) ne {none}} {
	    $self ins end "click this window then press $options(-key) for straight key"
	} else {
	    $self ins end "configure a key with -ditkey, -dahkey, or -key"
	}
	$self tag add center 1.0 end
	$self tag configure center -justify center
    }

    method bind-key {tag element} {
	if {$tag ne {none}} {
	    bind $win <KeyPress-$tag> [mymethod insert-key $element down]
	    bind $win <KeyRelease-$tag> [mymethod insert-key $element up]
	}
    }
    
    method unbind-key {tag element} {
	if {$tag ne {none}} {
	    
	}
    }

    variable map -array {dit 0 dah 1 key 0 up 0x80 down 0x90}

    method insert-key {element updown} {
	$options(-insert) puts [binary format ccc [expr {$map($updown)|($chan-1)}] [expr {$base+$map($element)}] 0]
    }

    method rebind-key {opt val element} {
	$self unbind-key $options($opt) $element
	set options($opt) $val
	$self bind-key $options($opt) $element
	$self label
    }
    method {Configure -ditkey} {val} { $self rebind-key -ditkey $val dit }
    method {Configure -dahkey} {val} { $self rebind-key -dahkey $val dah }
    method {Configure -key} {val} { $self rebind-key -key $val key }
    method {Configure -insert} {val} { set options(-insert) $val }
}

#
# cwtext window management
# cwtext window is a live text entry for sending to the ascii-keyer
#
proc cwtext-window-timeout {w} {
    # I'm seeing available taking 50-60 units per character sent
    if { (! [[get-ascii] is-busy]) && [[get-ascii] pending] < 40} {
	set text [$w nextchar]
	if {$text ne {}} {
	    [get-ascii] puts [string toupper $text]
	}
    }
    after 20 [list cwtext-window-timeout $w]
}

proc cwtext-stop-sending {w} { $w abort; [get-ascii] abort }

proc cwtext-insert-command-line {w} {
    $w insert current [build-command-line]
}
proc cwtext-set {w op opt} {
}
proc cwtext-option-menu {w x y} {
    if { ! [winfo exists $w.m] } {
	menu $w.m -tearoff no
	$w.m add command -label {Stop sending} -command [list cwtext-stop-sending $w]
	$w.m add command -label {Clear window} -command [list $w clear]
	$w.m add separator
	$w.m add command -label {Send file} -command [list $w choose file]
	$w.m add separator
	$w.m add command -label {Font} -command [list $w choose font]
	$w.m add command -label {Background} -command [list cwtext-set $w choose background]
	$w.m add command -label {Sent Color} -command [list cwtext-set $w choose sentcolor]
	$w.m add command -label {Unsent Color} -command [list cwtext-set $w choose unsentcolor]
	$w.m add command -label {Skipped Color} -command [list cwtext-set $w choose skippedcolor]
    }
    if {0} {
	menu $w.m -tearoff no
	menu $w.m.s -tearoff no
	menu $w.m.r -tearoff no
	foreach m {0 1 2 3 4} {
	    $w.m.s add command -label "Mem $m" -command [list cwtext-store-memory-selection $m]
	    $w.m.r add command -label "Mem $m" -command [list cwtext-send-memory $m]
	}
	$w.m add command -label {Send Selection} -command [list cwtext-send-selection $w]
	$w.m add separator
	$w.m add cascade -label {Send Saved} -menu $w.m.r
	$w.m add cascade -label {Save Selection} -menu $w.m.s
	$w.m add separator
	$w.m add command -label {Send From File} -command [list cwtext-send-file $w]
	$w.m add command -label {Insert From File} -command [list cwtext-load-file $w]
	$w.m add command -label {Save To File} -command [list cwtext-save-file $w]
	$w.m add separator
	$w.m add command -label {Stop Sending} -command [list cwtext-stop-sending $w]
	$w.m add separator
	$w.m add command -label {Insert Command Line} -command [list cwtext-insert-command-line $w]
	$w.m add command -label {Help} -command [list cwtext-help $w]
    }
    tk_popup $w.m $x $y
}
proc cwtext-widget {w} {
    package require sdrtk::cwtext
    sdrtk::cwtext $w -width 30 -height 15 -exportselection true
    bind $w <ButtonPress-3> [list cwtext-option-menu $w %X %Y]
    bind $w <Escape> [list cwtext-stop-sending $w]
    set ::data(ascii-puts) {}
    cwtext-window-timeout $w
    return $w
}

#
# read only text widget, receiving decoded morse
#
package require morse::morse
package require morse::itu

proc read-text-window-timeout {w} {
    #$w insert end [morse-to-text [morse-itu-dict] [[get-detime] get]]
    $w insert end [[get-detime] get]\n
    after 100 [list read-text-window-timeout $w]
}
proc read-text-save-file {w} {
    set filename [tk_getSaveFile -title {Log to file}]
    if {$filename ne {}} {
	write-file $filename [$w get 1.0 end]
    }
}
proc read-text-option-menu {w x y} {
    if { ! [winfo exists $w.m] } {
	menu $w.m -tearoff no
	$w.m add command -label {Save To File} -command [list read-text-save-file $w]
	
    }
    tk_popup $w.m $x $y
}
proc read-text-widget {w} {
    text $w -width 30 -height 15 -exportselection true
    bind $w <ButtonPress-3> [list read-text-option-menu $w %X %Y]
    after 100 [list read-text-window-timeout $w]
    return $w
}

#
# midi tap text widget, receiving midi events for timing check
#
snit::widgetadaptor midi-tap {
    option -tap -default {} -configuremethod Configure 

    delegate method * to hull
    delegate option * to hull
    
    variable tapframe 0

    method {Configure -tap} {val} { set options(-tap) $val }

    method timeout {} {
	#$w insert end [morse-to-text [morse-itu-dict] [[get-detime] get]]
	if {[$options(-tap) state]} {
	    foreach event [$options(-tap) get] {
		foreach {frame midi} $event break
		binary scan $midi c* bytes
		set out [format {%ld %ld} $frame [expr {$frame-$tapframe}]]
		set tapframe $frame
		foreach b $bytes {
		    append out [format { %02x} [expr {$b&0xff}]]
		}
		$self insert end $out\n
	    }	
	}
	after 100 [mymethod timeout]
    }

    method save-file {} {
	set filename [tk_getSaveFile -title {Midi log to file}]
	if {$filename ne {}} {
	    write-file $filename [$self get 1.0 end]
	}
    }

    method option-menu {x y} {
	if { ! [winfo exists $win.m] } {
	    menu $win.m -tearoff no
	    $win.m add command -label {Save To File} -command [mymethod save-file]
	    $win.m add command -label {Clear} -command [mymethod delete 1.0 end]
	    $win.m add command -label {Start} -command [list $options(-tap) start]
	    $win.m add command -label {Stop} -command [list $options(-tap) stop]
	}
	tk_popup $win.m $x $y
    }
    
    constructor {args} {
	installhull using text
	$self configure -width 30 -height 15 {*}$args
	bind $win <ButtonPress-3> [mymethod option-menu $win %X %Y]
	$options(-tap) start
	after 100 [mymethod timeout]
    }
}

#
# manage option preferences
# some of these should match patterns in the lists
#
proc is-matched {opt list} {
    foreach pat $list { if {[string match $pat $opt]} { return 1 } }
    return 0
}
proc is-prefer {opt} { return [is-matched $opt [get-prefer]] }
proc is-show {opt} { return [is-matched $opt [get-show]] }
proc is-hide {opt} { return [is-matched $opt [get-hide]] }
proc is-merge {opt} { return [is-matched $opt [get-merge]] }
proc is-join {opt} { return [expr {[lsearch [get-join] $opt]+1}] }
proc is-argvopts {opt} { return [expr {[lsearch [get-argvopts] $opt] >= 0}] }

#
# load the entire ui for the program
#
proc widget-opts {w c opts} {
    # widget $w associated with component $c has options $opts
    foreach opt $opts {
	opt-define -$c$opt $w $opt
	set ::value(-$c$opt) [$w cget $opt]
	set ::defval(-$c$opt) ::value(-$c$opt)
    }
}

proc load-ui {} {
    pack [keyer-widget .k] -side top -fill x -expand true
    pack [ttk::panedwindow .p] -side top -fill both -expand true
    .p add [::sdrtk::dialbook .p.dial]
    # .p add [text .p.details] 
    text .p.details -tabs 8
    foreach {comp opt2 opt type value opts} $::data(options) {
	if {$comp eq {}} {
	    set text $opt2
	} else {
	    set text -$comp$opt2
	}
	# if already processed, skip
	if {[info exists ::value($text)]} continue

	# set up the details display
	set ::prefer($text) [is-prefer $text]
	set ::show($text) [is-show $text]
	set ::hide($text) [is-hide $text]
	set ::merge($text) [is-merge $text]
	set ::join($text) [is-join $text]
	set ::argvopts($text) [is-argvopts $text]
	set ::defval($text) $value
	set ::value($text) $value
	.p.details insert end [expr {$::prefer($text)?{P}:{-}}]
	.p.details insert end [expr {$::show($text)?{S}:{-}}]
	.p.details insert end [expr {$::hide($text)?{H}:{-}}]
	.p.details insert end [expr {$::merge($text)?{M}:{-}}]
	.p.details insert end [expr {$::join($text)?{J}:{-}}]
	.p.details insert end [expr {$::argvopts($text)?{A}:{-}}]\t
	.p.details insert end [format %16s $text]\t
	.p.details insert end [format {default: %8s} $::defval($text)]\t
	.p.details insert end [format {value: %8s} $::value($text)]\t
	#.p.details window create end -create [list button .p.details.edit -text Edit -command [list option-edit $text ]]
	.p.details insert end \n

	if {$::hide($text) && ! $::show($text)} continue
					      
	lappend opts -value $value -variable ::value($text) -command [list dial-set $text]
	set w x$text
	switch $type {
	    enum { sdrtk::readout-enum .p.dial.$w {*}$opts }
	    freq { sdrtk::readout-freq .p.dial.$w {*}$opts }
	    value { sdrtk::readout-value .p.dial.$w {*}$opts }
	    default { error "unanticipated type \"$type\"" }
	}
	.p.dial add .p.dial.$w -text [.p.dial.$w cget -text]
    }
    if {[.p.dial select] eq {}} { .p.dial select 0 }
    set ::data(show-dial) 1

    # puts "current dialbook selection {[.p.dial select]} of {[.p.dial tabs]}"
    if {[has-insert]} { 
	.p add [midi-insert .p.insert -insert [get-insert]]
	set ::data(show-insert) 1
	widget-opts .p.insert [get-insert] [.p.insert exposed-options]
    }
    # memories-widget
    if {[has-ascii]} {
	.p add [cwtext-widget .p.ascii]
	set ::data(show-ascii) 1
	# add options for cwtext widget
	widget-opts .p.ascii [get-ascii] {-sentcolor -unsentcolor -skippedcolor -background -font}
    }
    if {[has-detime]} {
	.p add [read-text-widget .p.detime]
	set ::data(show-detime) 1
	# add options for read-text widget
	widget-opts .p.detime [get-detime] {-color1 -color2 -background}
    }
    if {[has-tap]} {
	.p add [midi-tap .p.tap -tap [get-tap]]
	set ::data(show-tap) 1
	widget-opts .p.tap [get-tap] {}
    }
}

proc build-command-line {} {
    set argv [file normalize $::script]
    if {[get-server] ne {}} { lappend argv -server [get-server] }
    lappend argv -start [get-start]
    # prefer specifically named options
    # to the ones that are only inferred from component inspection
    foreach opt [opt-get-opts] {
	if {$::value($opt) ne $::defval($opt)} {
	    lappend argv $opt $::value($opt)
	}
    }
    return [join $argv { }]
}

# process a list of arguments, always formatted as -option value pairs
proc main-argv {argv} {
    foreach {opt val} $argv {
	switch -- $opt { 
	    -run { # run one or more saved setups
		foreach v $val {
		    main-argv [lrange [dict get [get-setups] $v] 1 end]
		}
	    }
	    -server { # specify the jack server to run in
		set-var $opt $val
	    }
	    -title { # specify the window title
		set-title $val
	    }
	    -prefer { # list of preferred options which appear in this order
		lappend-prefer {*}$val
	    }
	    -hide { # list of hidden options which should not be exposed
		lappend-hide {*}$val
	    }
	    -show { # list of shown options which should be exposed
		lappend-show {*}$val
	    }
	    -merge { # list of options which should be merged into one option
		lappend-merge {*}$val
	    }
	    -join { # list of option pairs which should be ganged together
		lappend-join {*}$val
	    }
	    -start { # list of sdrtcl::* modules that should be started in this setup
		lappend-start {*}$val
	    }
	    default { # save plain command line options until everything loads
		lappend-argvopts $opt $val; # save option
	    }
	}
    }
}

proc main {argv} {
    # initialize
    set ::data(main) [dict create -server {} options {} -prefer {} -hide {} -show {} -merge {} -join {}]
    # see what jack thinks we're doing
    package require sdrtcl::jack
    set bs [sdrtcl::jack buffer-size]; # samples per buffer
    set sr [sdrtcl::jack sample-rate]; # samples per second
    
    # ms-per-buffer = ($bs samples-per-buffer) * ((1000 ms-per-second) / ($sr samples-per-second))
    set mspbs [expr {$bs * 1000.0 / $sr}]
    
    dict set ::data(main) jack buffer-size $bs
    dict set ::data(main) jack sample-rate $sr
    dict set ::data(main) jack ms-per-buffer $mspbs
    # puts "$mspbs ms per buffer"
    
    # style, abolish invisible indicators
    ttk::style configure "." -indicatordiameter 12
    ttk::style configure TCheckbutton -relief raised
    ttk::style configure TRadiobutton -relief raised
    
    # load or create ~/.config/keyer/keyer.tcl
    if { ! [file exists ~/.config/keyer/keyer.tcl] || 
	 [catch {source ~/.config/keyer/keyer.tcl} result]} {
	# config file does not exist or error reading it
	if { ! [file exists ~/.config]} { file mkdir ~/.config }
	if { ! [file exists ~/.config/keyer]} { file mkdir ~/.config/keyer }
	write-file ~/.config/keyer/keyer.tcl {
	    dict create {*}{
		key { keyer -start {ad5dz@key keyer-tone@kyo} -key-wpm 18 -kyo-rise-fall 4.0 }
		kbd { keyer -start {ascii@kbd keyer-tone@kbo} -kbd-wpm 80 -kbo-rise-fall 6.6 }
		key+kbd { keyer -run {key kbd}}
		ptt { keyer -start {keyer-ptt@ptt} }
		deb { keyer -start {keyer-debounce@deb} }
		cas { keyer -start {midi-insert@cas} }
		tap { keyer -start {midi-tap@tap} }
		out { keyer -start {keyer-detone@detone keyer-detime@out} }
	    }
	}
	if {[catch {source ~/.config/keyer/keyer.tcl} result]} {
	    error "failed to create default configs: $result"
	}
    }
    set-setups $result

    # make a usage message
    if {$argv eq {} || $argv eq {help}} {
	puts "usage: keyer ?-run [join [dict keys [get-setups]] {|}] ...?"
	exit 1
    }
    
    # process arguments, first pass just to collect everything
    main-argv $argv

    # start components and collect their options
    foreach v [get-start] {
	# start a component
	foreach {component name2} [load-component $v] break
	component-define $name2
	# remember if this is special
	switch -glob $component {
	    keyer-ascii { set-ascii $name2 }
	    keyer-detime { set-detime $name2 }
	    midi-insert { set-insert $name2 }
	    midi-tap { set-tap $name2 }
	}
	# load its options
	populate-component-options $component $name2
    }
    
    # process command line options for additional option definitions
    foreach {opt val} [get-argvopts] {
	if {[opt-is-defined $opt]} continue; # already defined
	set parts [split [string trim $opt -] -]
	if {[llength $parts] < 2} continue; # not enough to work out
	# find a prefixed component name, if any
	foreach {name option1 option2} $parts break
	if {[component-is-defined $name] } {
	    if {[llength $parts] == 3 && [opt-is-defined -$name-$option1] && [opt-is-defined -$name-$option2]} {
		# -component-option1-option2: explicit component joined option
		populate-option $name -$option1-$option2 {*}[$name configure -$option1]
		populate-option $name -$option1-$option2 {*}[$name configure -$option2]
	    }
	} else {
	    foreach {option1 option2} $parts break
	    if {[llength $parts] == 2 && [opt-is-defined -$option1] && [opt-is-defined -$option2]} {
		# -option1-option2: joined option
		# iterate over components with both options
		foreach name [find-components -$option1 -$option2] {
		    populate-option $name $opt {*}[$name configure -$option1]
		    populate-option $name $opt {*}[$name configure -$option2]
		}
	    }
	}
    }

    # merge options into single controls
    #if {[has-merge]} { merge-component-options [get-merge] }
    # join options into ganged controls
    #if {[has-join]} { join-component-optiosn [get-join] }
    # sort the preferred options to the top
    if {[has-prefer]} { prefer-component-options [get-prefer] }
    # disappear options of no interest
    #if {[has-hide]} { hide-component-options [get-hide] }
    # reappear options with declared interest
    #if {[has-show]} { show-component-options [get-show] }
    
    # initialize the dial-set timer
    dial-set-init
	
    # build the ui with the extracted options
    load-ui
	
    # load the options collected from the command line
    if {[has-argvopts]} {
	foreach {opt val} [get-argvopts] { 
	    if {[catch {dial-set $opt $val} error]} {
		puts "bad option: $opt $val"
	    }
	}
    }
	
    # install application icon
    set dir [file join $::dirname .. icons]
    image create photo icon1 -file [file join $dir qrv96.png]
    image create photo icon2 -file [file join $dir qrv48.png]
    wm iconphoto . -default icon1 icon2
}

main $argv
