#!/usr/bin/wish8.6
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [info script]
set dirname [file dirname $script]

#
# append the ../lib directory to the Tcl search path
#
lappend auto_path [file join $dirname .. lib]

#
# find the list of sdrtcl::*
#
set packages [exec grep sdrtcl:: [file join $dirname .. lib sdrtcl pkgIndex.tcl] | awk {{print $3}} | sed -e s/sdrtcl:://g]

#
# will need this to implement -uuid
#
package require sdrtcl::jack-client

# load an sdrtcl component
# name is name1 or a name1@name2
# name1 specifies the sdrtcl component
# and name2 specifies the jack client name to use for it
# name2 defaults to name1
# name1 can be any string which uniquely identifies an sdrtcl component
# ambiguous ones throw an error with the list that matched
# 
proc load-component {name} {
    # name1 identifies the sdrtcl component
    # name2 is the jack client name
    set name1 $name
    set name2 $name
    if {[llength [split $name @]] == 2} {
	foreach {name1 name2} [split $name @] break
    }
    # search through the sdrtcl component list
    # for components which match name1
    set candidates {}
    foreach c $::packages {
	if {[string equal $name1 $c]} {
	    set candidates [list $c]
	    break
	} elseif {[string match *$name1* $c]} {
	    lappend candidates $c
	}
    }
    if {[llength $candidates] == 0} { error "no match for component '$name'" }
    if {[llength $candidates] > 1} { error "too many matches for component '$name', '[join $candidates {, }]'" }
    # we found one candidate
    set component [lindex $candidates 0]
    # load the implementation
    package require sdrtcl::$component
    # instantiate component
    sdrtcl::$component $name2
    # activate component
    $name2 activate
    # remember this
    lappend ::data(components) $component $name2
}

# user interface components
package require sdrtk::dialbook
package require sdrtk::readout-enum
package require sdrtk::readout-freq
package require sdrtk::readout-value

set data(options) {}

proc populate-options {} {
    # populate the list in ::data(options) for load-ui to implement
    foreach {component name} $::data(components) {
	foreach config [$name configure] {
	    foreach {opt oname oclass odefault ovalue} $config break
	    # note: opt is the option name in configure and cget commands
	    # oname is the option name in the option database (not used here)
	    # oclass is the option class name in the option database
	    # odefault is the default value
	    # ovalue is the current value
	    switch -- $opt {
		-server - -client - -uuid - -verbose { continue }
		-chan {
		    # these apply to the whole keyer chain,
		    # midi-chan value 1 {-text midi-channel -format %.0f -min 1 -max 16}
		}
		-note {
		    # these apply to the whole keyer chain,
		    # midi-note value 0 {-text midi-base-note -format %.0f -min 0 -max 127}
		}
		-wpm {
		    lappend ::data(options) $name -wpm value $ovalue {-text speed -format %.0f -units wpm -min 5.0 -max 200.0 -step 0.5}
		}
		-swap {
		    lappend ::data(options) $name -swap enum $ovalue {-text swap -values {0 1}}
		}
		-mode {
		    lappend ::data(options) $name -mode enum $ovalue {-text mode -values {A B}}
		}
		-word - -dah - -ies - -ils - -iws - -alsp - -awsp { 
		    # ignore these for the minute
		    continue
		}
		-mdit - -mdah - -mide - -weight {
		    # more to ignore
		    # dttsp -mdit mdit Memo 0 0 keep a dit memory
		    # dttsp -mdah mdah Memo 0 0 keep a dah memory
		    # dttsp -mide mide Memo 0 0 remember key state at mid-element
		    # dttsp -weight weight Weight 50 50 adjust relative weight of dit and dah
		}
		-freq {
		    lappend ::data(options) $name -freq freq $ovalue {-text freq -units Hz -format %.0f -min 500 -max 1500 -step 1}
		}
		-rise {
		    lappend ::data(options) $name -rise value $ovalue {-text rise-time -units ms -format %.1f -min 1.0 -max 10.0 -step 0.1}
		}
		-fall {
		    lappend ::data(options) $name -fall value $ovalue {-text fall-time -units ms -format %.1f -min 1.0 -max 10.0 -step 0.1}
		}
		-gain {
		    lappend ::data(options) $name -gain value $ovalue {-text volume -units dB -format %.1f -min -50 -max 0 -step 0.1}
		}
		-delay {
		    lappend ::data(options) $name -delay value $ovalue {-text ptt-delay -units ms -format %.2f -min 0.0 -max 1000 -step 0.01}
		}
		-hang {
		    lappend ::data(options) $name -hang value $ovalue {-text ptt-hang -units ms -format %.1f -min 0.0 -max 1000 -step 0.1}
		}
		-period {
		    # for the debouncer
		}
		-steps {
		    # for the debouncer
		}
		default {
		    puts "$name $config [$name info option $opt]"
		}
	    }
	}
    }
}

proc dial-set {comp opt val} {
    if {[catch {
	$comp configure $opt $val
    } error]} {
	# puts "dial-set $comp $opt $val threw $error"
	# could search for potential matches and configure them all?
	# assuming it's a component option without the component prefixed?
	foreach {ocomp copt type value opts} $::data(options) {
	    if {$copt eq $opt} {
		# puts "dial-set tryng $ocomp configure $opt $val"
		$ocomp configure $opt $val
		# puts "dial-set: cget [$ocomp cget $opt]"
		set ::data(-$ocomp:$opt) $val
		# puts "dial-set: set the ::data(-$ocomp:$opt) $val"
	    }
	}
    }
}

proc load-ui {} {
    pack [::sdrtk::dialbook .dial] -side top -fill both -expand true
    foreach {comp opt type value opts} $::data(options) {
	lappend opts -value $value -variable ::data(-$comp:$opt) -command [list dial-set $comp $opt]
	switch $type {
	    enum { sdrtk::readout-enum .dial.$comp:$opt {*}$opts }
	    freq { sdrtk::readout-freq .dial.$comp:$opt {*}$opts }
	    value { sdrtk::readout-value .dial.$comp:$opt {*}$opts }
	    default { error "unanticipated type \"$type\"" }
	}
	.dial add .dial.$comp:$opt -text [.dial.$comp:$opt cget -text]
    }
}

proc main {argv} {
    set server default
    set uuid {}
    set opts {}
    set comps {}
    foreach {opt val} $argv {
	if {$opt eq {-server}} {
	    set server $val;	# select jack server
	} elseif {$opt eq {-uuid}} {
	    set uuid $val;	# identify saved jack client
	} elseif {$opt eq {-start}} {
	    lappend comps $val
	} else {
	    lappend opts $opt $val; # save options
	}
    }
    # initiate jack session
    if {$uuid ne {}} {
	sdrtcl::jack-client jack -server default -uuid $uuid
    } else {
	sdrtcl::jack-client jack -server default
    }
    # load the modules
    foreach comp $comps {
	load-component $comp
    }
    # extract and filter the options from the modules
    populate-options
    # build the ui with the extracted options
    load-ui
    # load the options collected from the command line
    foreach {opt val} $opts {
	dial-set * $opt $val
    }

    # install application icon
    set dir [file join [file dirname [info script]] .. icons]
    image create photo icon1 -file [file join $dir qrv96.png]
    image create photo icon2 -file [file join $dir qrv48.png]
    wm iconphoto . -default icon1 icon2
}

main $argv

