#!/usr/bin/tclsh8.6
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

#
# start an sdrtcl dbus master and a hamlib rigctld
# the controller polls the sdrtcl components and
# builds an interface
# 
set script [info script]

#
# append the ../lib directory to the Tcl search path
#
lappend auto_path [file join [file dirname $script] .. lib]

#
# find the name of the script, without reading links
#
set name [file tail $script]

#
# initialize data
#
array set data {
    present {}
    monitor {}
    dict {}
}

#
# prepare to communicate
#
package require dbus

proc sdrkit-ping {name} {
    return [dbus call $name org.freedesktop.DBus.Peer Ping]
}
proc sdrkit-introspect {name} {
    return [dbus call -dest org.sdrkit.$name / org.freedesktop.DBus.Introspectable Introspect]
}
proc sdrkit-get-all {name} {
    return [dbus call -dest org.sdrkit.$name / org.freedesktop.DBus.Properties GetAll org.sdrkit.Bus]
}
proc sdrkit-get-value {name key} {
    return [dbus call -dest org.sdrkit.$name / org.freedesktop.DBus.Properties Get org.sdrkit.Bus $key]
}
proc sdrkit-set-value {name key value} {
    return [dbus call -dest org.sdrkit.$name / org.freedesktop.DBus.Properties Set org.sdrkit.Bus $key $value]
}

## connect to the bus
dbus connect
dbus name -replace -yield org.sdrkit.bus

## listen for replacement
dbus listen /org/freedesktop/DBus NameLost {
    exit
}

## listen for the responses
dbus listen / Present [list signal-present]
proc signal-present {dict name} {
    puts "received Present $name"
    lappend ::data(present) $name
}

#
# we want to poll for components
# after any changes have settled
#
proc start-rollcall {} {
    # puts "[clock milliseconds]: start-rollcall"
    # puts "sdrkit component roll call"
    # initialize the list of responders
    set ::data(present) {}
    # initialize monitor log
    set ::data(monitor) {}
    # announce roll call
    dbus signal / org.sdrkit.Bus RollCall
    # start monitor
    after 250 [list monitor-rollcall]
}

#
# listen for responses to roll call
# until the list stabilizes, then
# find out what the components can do
#
proc monitor-rollcall {} {
    # see how many components have reported
    set n [llength $::data(present)]
    # remember this outcome
    lappend ::data(monitor) $n
    # see if it's stable
    if {[llength [lsearch -all -exact $::data(monitor) $n]] < 5} {
	puts "[clock milliseconds] monitor-rollcall go around again: $::data(monitor)"
	# still stabilizing
	after 100 [list monitor-rollcall]
    } else {
	# one quarter second at this level of response
	set ::data(present) [lsort $::data(present)]
	puts "[clock milliseconds] monitor-rollcall install $::data(present)"
	# puts "updating components to $::data(present)"
	set d [dict create]
	foreach name $::data(present) {
	    set p [dict create]
	    foreach {key value} [sdrkit-get-all $name] {
		dict set p $key $value
		# puts "$key @ $name -> [sdrkit-get-value $name $key]"
	    }
	    dict set d $name $p
	}
	set ::data(dict) $d
	puts $d
    }
}

if {0} {
    # for reasons I don't understand, we appear to be sandboxed in our own dbus
    # without access to the signals being sent by ladish and jack.
    # in any case, this doesn't work so we're going to get the signals by other means
    proc signal-received {name dict args} {
	puts "[clock milliseconds signal-received $name $args"
	catch {after cancel $::data(after)}
	set ::data(after) [after 250 start-rollcall]
    }
    
    dbus listen {} org.ladish.AppSupervisor.AppAdded [list signal-received AppAdded]
    dbus listen {} org.ladish.AppSupervisor.AppRemoved [list signal-received AppRemoved]
    dbus listen {} org.ladish.AppSupervisor.AppStateChanged [list signal-received AppStateChanged]
    #puts "Listening to:\n\t[join [dbus listen] \n\t]"
} else {

    proc read-sigs {chan} {
	set data [read $chan]
	puts "[clock milliseconds]: read-sigs [string length $data] bytes"
	if {[eof $chan]} {
	    close $chan
	}
	catch {after cancel $::data(after)}
	set ::data(after) [after 250 start-rollcall]
    }
    set ::data(chan) [open {| dbus-monitor "type='signal',interface='org.ladish.AppSupervisor'"} r]
    fconfigure $::data(chan) -blocking 0 -encoding binary
    fileevent $::data(chan) readable [list read-sigs $::data(chan)]
}

## schedule the first roll call
## will be postponed while other components startup
set ::data(after) [after 250 [list start-rollcall]]

vwait ::finished
