#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

package require Tk
package require sdrkit
package require sdrtcl::jack
package require sdrtcl::iq-correct
package require sdrtcl::iq-rotation

#
# and an iq-correct to rebalance the oscillator
#
array set data {
    server default
    length 320
    corrector-on 0
    corrector-log2-mu -2
    corrector-wi 0.00
    corrector-wq 0.00
    algorithm 0
}

namespace eval ::meters {}

##
## meter the effect of iq rebalancing
## this is plotting the transform applied
## to incoming iq signals
##
proc ::meters::update {w} {
    upvar #0 ::meters::$w data
    foreach {wi wq} [iq-correct get] break
    set xy {}
    # float complex z1 = z0 + (p->wi+I*p->wq) * conjf(z0);
    set maxr2 0
    set minr2 100
    foreach {t ct st} $data(theta-cos-sin) {
	set x [expr {$ct + $wi*$ct + $wq*$st}]
	set y [expr {$st - $wi*$st + $wq*$ct}]
	set r2 [expr {$x*$x+$y*$y}]
	set maxr2 [expr {max($r2,$maxr2)}]
	set minr2 [expr {min($r2,$minr2)}]
	lappend xy $x $y
    }
    $w coords xyplot $xy
    $w scale xyplot 0 0 75 -75
    $w move xyplot 125 125
    
    set ::data(corrector-dB) [format %.4f [expr {10*log10($maxr2/$minr2)}]]
    foreach {t ct st} $data(theta-cos-sin) break    
    set x [expr {$ct + $wi*$ct + $wq*$st}]
    set y [expr {$st - $wi*$st + $wq*$ct}]
    set ::data(corrector-deg) [format %.4f [expr {180.0*atan2($y,$x)/atan2(0,-1)}]]

    after 10 [list ::meters::update $w]
}
proc ::meters::autotune-setup {w} {
    upvar #0 ::meters::$w data
    array set data {autotune 0 last-wi 0 last-wq 0 last-dwi 0 last-dwq 0}
    ::meters::autotune $w
}

proc ::meters::autotune {w} {
    upvar #0 ::meters::$w data
    if {$data(autotune)} {
	# keep the average direction and distance made good
	# that the filter has achieved over the past few steps
	# if this direction and distance looks like the average
	# then increase mu, otherwise 
	foreach {wi wq} [iq-correct get] break
	set dwi [expr {$wi-$data(last-wi)}]; # distance in wi
	set dwq [expr {$wq-$data(last-wq)}]; # distance in wq
	set d2 [expr {$dwi*$dwi+$dwq*$dwq}]; # net distance squared
	set 
	array set data [list last-wi $wi last-wq $wq last-wv $wv]
	puts $wv
    }
    after 2 [list ::meters::autotune $w]
}
proc ::meters::setup {w n} {
    upvar #0 ::meters::$w data
    set data(n-theta) $n
    set data(theta-cos-sin) {}
    set pi [expr {atan2(0,-1)}]
    for {set i 0} {$i <= $n} {incr i} {
	set theta [expr {2*$pi*$i/$n}]
	lappend data(theta-cos-sin) $theta [expr {cos($theta)}] [expr {sin($theta)}]
    }
    catch {$w delete all}
    $w create line {0 0 0 0} -fill white -tags xyplot
}
proc ::meters {w args} {
    upvar #0 ::meters::$w data
    canvas $w -bg black -width 250 -height 250
    ::meters::setup $w 32
    return $w
}

##
## controllers for the input signal, unbalancing, and rebalancing components
##
proc more-mu {} {
    incr ::data(corrector-log2-mu) 1
    if {$::data(corrector-on)} {
	iq-correct configure -mu [expr {pow(2,$::data(corrector-log2-mu))}]
    }
}

proc less-mu {} {
    incr ::data(corrector-log2-mu) -1
    if {$::data(corrector-on)} {
	iq-correct configure -mu [expr {pow(2,$::data(corrector-log2-mu))}]
    }
}

proc reset-ws {} {
    iq-correct set 0 0
}

proc update-ws {} {
    foreach {wi wq} [iq-correct get] break
    if {[catch {
	set ::data(corrector-wi) [format %.10f $wi]
	set ::data(corrector-wq) [format %.10f $wq]
    } error]} {
	puts "$error"
    }
    after 20 [list update-ws]
}

proc corrector-onoff {} {
    if {$::data(corrector-on)} {
	#puts "iq-correct reset to -mu $::data(corrector-mu)"
	iq-correct set 0 0
	iq-correct configure -mu [expr {pow(2,$::data(corrector-log2-mu))}]
    } else {
	#puts "iq-correct muted to 0"
	iq-correct configure -mu 0
	iq-correct set 0 0
    }
}

proc update-rotation {} {
    set ::data(rotation) [expr {0.99*$::data(rotation)+0.01*[iq-rotation get]}]
    after 20 [list update-rotation]
}

proc shutdown {w} {
    if {$w eq {.}} {
	foreach client $::data(clients-to-cleanup) {
	    rename $client {}
	}
    }
}

proc start-client {module name args} {
    $module $name -server $::data(server) {*}$args
    lappend ::data(clients-to-cleanup) $name
}

proc main {argv} {
    foreach {option value} $argv {
	switch -- $option {
	    -n - -name - --name { set ::data(name) $value }
	    -s - -server - --server { set ::data(server) $value }
	    -l - -length - --length { set ::data(length) $value }
	    default { error "unknown option \"$option\"" }
	}
    }

    sdrtcl::iq-correct iq-correct
    sdrtcl::iq-rotation iq-rotation

    wm title . sdrkit:rebal

    set row 0
    grid [ttk::label .blk$row -text {Corrector}] -row $row -column 0 -columnspan 3
    incr row
    grid [ttk::frame .blk$row] -row $row -column 0 -columnspan 3
    pack [ttk::label .blk$row.l -text {rotation: }] -side left
    pack [ttk::label .blk$row.v -textvariable ::data(rotation) -width 15] -side left
    set ::data(rotation) 0
    incr row
    grid [ttk::frame .blk$row] -row $row -column 0 -columnspan 3
    pack [ttk::label .blk$row.l-mu -text {log2(mu): }] -side left
    pack [ttk::label .blk$row.v-mu -textvariable ::data(corrector-log2-mu) -width 15] -side left
    pack [ttk::label .blk$row.l-wi -text {wi: }] -side left
    pack [ttk::label .blk$row.v-wi -textvariable ::data(corrector-wi) -width 15] -side left
    pack [ttk::label .blk$row.l-wq -text {wq: }] -side left
    pack [ttk::label .blk$row.v-wq -textvariable ::data(corrector-wq) -width 15] -side left
    incr row
    grid [ttk::frame .blk$row] -row $row -column 0 -columnspan 3
    pack [ttk::checkbutton .blk$row.onoff -text {Enable} -variable ::data(corrector-on) -onvalue 1 -offvalue 0 -command corrector-onoff] -side left
    pack [ttk::button .blk$row.more-mu -text {Less mu} -command [list less-mu]] -side left
    pack [ttk::button .blk$row.less-mu -text {More mu} -command [list more-mu]] -side left
    pack [ttk::button .blk$row.reset-ws -text {Reset wi/wq} -command [list reset-ws]] -side left
    incr row
    grid [ttk::frame .blk$row] -row $row -column 0 -columnspan 3
    pack [ttk::label .blk$row.db1 -text dB] -side left
    pack [ttk::label .blk$row.db2 -textvar ::data(corrector-dB) -width 15] -side left
    pack [ttk::label .blk$row.deg1 -text deg] -side left
    pack [ttk::label .blk$row.deg2 -textvar ::data(corrector-deg) -width 15] -side left
    incr row
    set meters .blk$row 
    grid [meters .blk$row] -row $row -column 0 -columnspan 3
    incr row
    grid [ttk::checkbutton .blk$row -text {Autotune} -variable ::meters::${meters}(autotune) -onvalue 1 -offvalue 0] -row $row -column 0 -columnspan 3
    ::meters::update $meters
    ::meters::autotune-setup $meters
    grid columnconfigure . 2 -weight 100

    corrector-onoff
    update-rotation
    update-ws
    bind . <Destroy> [list shutdown %W]
}

main $argv
