#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

#package provide waterfall 1.0.0

package require Tk
package require sdrkit

namespace eval ::waterfall {
    set n 0
    array set default_data  {  
	type magnitude
	level_min -125.0
	level_max -60.0
	level_pal 0
    }
}

#
# only pal==0 is hotiron, don't know what the others do, yet
#
proc ::hotiron {lev min max pal} {
    set hue [expr {min(1,max(0,($lev-$min)/($max-$min)))}]
    switch $pal {
	0 { lassign [list [expr {3*($hue+0.03)}] [expr {3*($hue-.333333)}] [expr {3*($hue-.666667)}]] red green blue }
	1 { lassign [list [expr {3*($hue+0.03)}] [expr {3*($hue-.666667)}] [expr {3*($hue-.333333)}]] red green blue }
	2 { lassign [list [expr {3*($hue-.666667)}] [expr {3*($hue+0.03)}] [expr {3*($hue-.333333)}]] red green blue }
	3 { lassign [list [expr {3*($hue-.333333)}] [expr {3*($hue+0.03)}] [expr {3*($hue-.666667)}]] red green blue }
	4 { lassign [list [expr {3*($hue-.333333)}] [expr {3*($hue-.666667)}] [expr {3*($hue+0.03)}]] red green blue }
	5 { lassign [list [expr {3*($hue-.666667)}] [expr {3*($hue-.333333)}] [expr {3*($hue+0.03)}]] red green blue }
    }
    return [format {#%02x%02x%02x} [expr {int(255*min(1,max($red,0)))}] [expr {int(255*min(1,max($green,0)))}] [expr {int(255*min(1,max($blue,0)))}]]
}

proc ::hotiron-test {} {
    for {set p 0} {$p < 6} {incr p} {
	image create photo p$p -palette 256/256/256
	for {set i 0} {$i < 1024} {incr i} {
	    p$p put [hotiron $i 0.0 1024.0 $p] -to $i 0 [expr {$i+1}] 16
	}
	pack [ttk::label .p$p -image p$p] -side top
    }
}

proc waterfall::pixel {w level} {
    upvar #0 $w data
    set i color-$data(level_pal)-[expr {int(10*$level)}]
    if { ! [info exists data($i)]} {
	set data($i) [::hotiron $level $data(level_min) $data(level_max) $data(level_pal)]
	# puts "assigned $data($i) to level $level"
    }
    return $data($i)
}

proc waterfall::capture {w} {
    upvar #0 $w data
    foreach {f b} [::$data(tap) $data(n)] break
    set l [::$data(fft) $b]
    binary scan $l f* levels
    
    ## they're ordered from 0 .. most positive, most negative .. just < 0
    ## k/T, T = total sample time, n * 1/sample_rate
    set scanline {}
    foreach {re im} [concat [lrange $levels [expr {1+$data(n)}] end] [lrange $levels 0 $data(n)]] {
	# squared magnitude means 10*log10 dB
	lappend scanline [pixel $w [expr {10*log10($re*$re+$im*$im+1e-16)}]]
    }
    $data(image2) copy $data(image1) -from 0 0 -to 0 1
    $data(image2) put [list $scanline] -to 0 0 $data(n) 1
    $data(image1) copy $data(image2)
    $w.l configure -image $data(image1)
    # update idletasks
    after $data(p) [list waterfall::capture $w]
}

proc waterfall::waterfall {w n p} {
    upvar #0 $w data
    ttk::frame $w
    array set data [array get ::waterfall::default_data]
    set data(n) $n
    set data(p) $p
    set data(tap) waterfall_tap_$::waterfall::n
    set data(fft) waterfall_fft_$::waterfall::n
    incr ::waterfall::n
    ::sdrkit::atap $data(tap)
    ::sdrkit::fftw $data(fft) $data(n)
    pack [ttk::frame $w.m] -side top -fill x
    pack [ttk::menubutton $w.m.palette -textvariable ${w}(label-palette) -menu $w.m.palette.m] -side left
    menu $w.m.palette.m -tearoff no
    foreach t {0 1 2 3 4 5} {
	$w.m.palette.m add radiobutton -label "palette $t" -value "palette $t" -variable ${w}(label-palette) -command [list set ${w}(level_pal) $t]
    }
    set data(image1) [image create photo -palette 256/256/256 -width $n -height $n]
    set data(image2) [image create photo -palette 256/256/256 -width $n -height $n]
    pack [ttk::label $w.l -image $data(image1)] -side top
    after 100 [list waterfall::capture $w]
    return $w
}

proc waterfall {w n p} { return [waterfall::waterfall $w $n $p] }

proc main {argv} {
    pack [waterfall .scope 640 10] -fill both -expand true
}

main $argv
