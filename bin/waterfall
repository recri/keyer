#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

#package provide waterfall 1.0.0

package require Tk
package require sdrkit

#
# this needs to be three or four layers of implementation.
# 1) at the core we have the atap and fftw extensions
# 2) these get wrapped to make spectrum generator
namespace eval ::waterfall {
    set n 0;			# waterfall counter
    array set default_data  {  
	size 512
	n-periods 400
	connect {iambic_tone ascii_tone}
	type magnitude
	level_min -125.0
	label-min {min -125.0}
	value-min {-160.0 -130.0 -125.0 -120.0 -115.0 -110.0 -105.0 -100.0}
	level_max -60.0
	label-max {max -60.0}
	value-max {-80.0 -75.0 -70.0 -65.0 -60.0 -55.0 -50.0 -45.0 -40.0 0.0}
	level_pal 0
	label-palette {palette 0}
	value-palette {0 1 2 3 4 5}
	atten 0.0
	label-atten {atten 0.0}
	value-atten {0 -20.0 -40.0 -60.0 -80.0 -100.0 -120.0 -140.0 -160.0}
	period 50
	label-period {period 50}
	value-period {10 25 50 75 100}
	canvas-width -1
	canvas-height -1
    }
}

#
# pal 0 is hotiron, approximate spectrum of a black body as it is heated
#
proc ::hotiron {hue pal} {
    switch $pal {
	0 { lassign [list [expr {3*($hue+0.03)}] [expr {3*($hue-.333333)}] [expr {3*($hue-.666667)}]] r g b }
	1 { lassign [list [expr {3*($hue+0.03)}] [expr {3*($hue-.666667)}] [expr {3*($hue-.333333)}]] r g b }
	2 { lassign [list [expr {3*($hue-.666667)}] [expr {3*($hue+0.03)}] [expr {3*($hue-.333333)}]] r g b }
	3 { lassign [list [expr {3*($hue-.333333)}] [expr {3*($hue+0.03)}] [expr {3*($hue-.666667)}]] r g b }
	4 { lassign [list [expr {3*($hue-.333333)}] [expr {3*($hue-.666667)}] [expr {3*($hue+0.03)}]] r g b }
	5 { lassign [list [expr {3*($hue-.666667)}] [expr {3*($hue-.333333)}] [expr {3*($hue+0.03)}]] r g b }
    }
    return [format {#%02x%02x%02x} [expr {int(255*min(1,max($r,0)))}] [expr {int(255*min(1,max($g,0)))}] [expr {int(255*min(1,max($b,0)))}]]
}

proc ::hotiron-test {p n} {
    set max [expr {double($n)}]
    image create photo p$p -palette 256/256/256
    for {set i 0} {$i < $n} {incr i} {
	p$p put [hotiron [expr {$i/$max}] $p] -to $i 0 [expr {$i+1}] 32
    }
    pack [ttk::label .p$p -image p$p] -side top
}

proc waterfall::pixel {w level} {
    upvar #0 $w data
    # clamp to percentage of range
    set level [expr {min(1,max(0,($level-$data(level_min))/($data(level_max)-$data(level_min))))}]
    # use 100 levels
    set i color-$data(level_pal)-[expr {int(100*$level)}]
    if { ! [info exists data($i)]} {
	set data($i) [::hotiron $level $data(level_pal)]
	# puts "assigned $data($i) to level $level"
    }
    return $data($i)
}

proc waterfall::capture {w} {
    upvar #0 $w data

    # cache some useful variables
    set wd $data(canvas-width)
    set ht $data(canvas-height)

    if {$wd > 0 && $ht > 0} {
	# capture a buffer
	foreach {f b} [::$data(tap) $wd] break
	
	# compute the fft
	set l [::$data(fft) $b]
	
	# convert the coefficients to a list
	binary scan $l f* levels
	
	# reorder the results from most negative frequency to most positive
	# compute the power, and convert to pixels
	## they're ordered from 0 .. most positive, most negative .. just < 0
	## k/T, T = total sample time, n * 1/sample_rate
	set spectrum {}
	set scanline {}
	foreach {re im} [concat [lrange $levels [expr {1+$wd}] end] [lrange $levels 0 $wd]] {
	    # squared magnitude means 10*log10 dB
	    set p [expr {10*log10($re*$re+$im*$im+1e-16)}]
	    lappend spectrum $p
	    lappend scanline [pixel $w [expr {$p+$data(atten)}]]
	}
	
	# scroll all the canvas images down by 1
	$w.c move all 0 1

	# find the image that scrolled off the bottom
	set i [expr {($ht-$data(i)-1)%$ht}]

	# rewrite its image contents with the scanline
	$data(img-$i) put [list $scanline]

	# reset the image of the canvas item
	$w.c itemconfig $data(item-$i) -image $data(img-$i)

	# move the item to the top
	$w.c move $data(item-$i) 0 [expr {-$ht}]
	
	# increment our scanline index
	incr data(i)
	
    }
    # schedule next capture
    after $data(period) [list waterfall::capture $w]
}

proc waterfall::configure {w cw width height} {
    if {$w eq $cw} {
	set w [winfo parent $w]
	upvar #0 $w data
	if {$width != $data(canvas-width)} {
	    set data(canvas-width) $width
	    catch {rename $data(fft) {}}
	    ::sdrkit::fftw $data(fft) $data(canvas-width)
	}
	if {$height != $data(canvas-height)} {
	    catch {$w.c delete all}
	    set data(canvas-height) $height
	    for {set i 0} {$i < $data(canvas-height)} {incr i} {
		if {[info exists data(img-$i)]} {
		    $data(img-$i) blank
		    $data(img-$i) configure -width $data(canvas-width)
		} else {
		    set data(img-$i) [image create photo -width $data(canvas-width) -height 1 -palette 256/256/256]
		}
		set data(item-$i) [$w.c create image 0 $i -image $data(img-$i) -anchor nw -state normal]
	    }
	    set data(i) 0
	}
    }
}

proc waterfall::destroy {w cw} {
    if {$w eq $cw} {
	upvar #0 $w data
	rename $data(tap) {}
	rename $data(fft) {}
	foreach img [array names data img-*] {
	    rename $data($img) {}
	}
    }
}
proc waterfall::value-menu {w n v} {
    upvar #0 $w data
    pack [ttk::menubutton $w.m.$n -textvariable ${w}(label-$n) -menu $w.m.$n.m] -side left
    menu $w.m.$n.m -tearoff no
    foreach t $data(value-$n) {
	$w.m.$n.m add radiobutton -label "$n $t" -value "$n $t" -variable ${w}(label-$n) -command [list set ${w}($v) $t]
    }
}

proc waterfall::waterfall {w opts} {
    upvar #0 $w data
    ttk::frame $w
    array set data [array get ::waterfall::default_data]
    array set data $opts
    set data(i) 0
    set data(tap) waterfall_tap_$::waterfall::n
    set data(fft) waterfall_fft_$::waterfall::n
    incr ::waterfall::n
    ::sdrkit::atap $data(tap)
    foreach x $data(connect) {
	catch {sdrkit::jack connect $x:out_i $data(tap):in_i}
	catch {sdrkit::jack connect $x:out_q $data(tap):in_q}
    }
    pack [ttk::frame $w.m] -side top -fill x
    value-menu $w palette level_pal
    value-menu $w min level_min
    value-menu $w max level_max
    value-menu $w atten atten
    value-menu $w period period
    pack [canvas $w.c -width $data(size) -height $data(n-periods)] -side top -expand true -fill both
    # configure canvas image set 
    bind . <Configure> [list ::waterfall::configure $w.c %W %w %h]
    bind . <Destroy> [list ::waterfall::destroy $w %W]
    after 100 [list waterfall::capture $w]
    return $w
}

proc waterfall {w opts} { return [waterfall::waterfall $w $opts] }

proc main {argv} {
    array set data {}
    foreach {option value} $argv {
	switch -- $option {
	    -n - --size { set data(size) $value }
	    -p - --period { set data(period) $value }
	    -c - --connect { set data(connect) $value }
	    -h - --height -
	    --n-periods { set data(n-periods) $value }
	    default { error "unknown option: \"$option\"" }
	}
    }
    pack [waterfall .fall [array get data]] -fill both -expand true
}

main $argv
# foreach p {0 1 2 3 4 5} { hotiron-test $p 1024 }


