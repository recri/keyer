#!/usr/bin/tclsh8.6
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

#
# a generic script for starting sdrkit components by linking their
# name to this script.
# 
set script [info script]

#
# append the ../lib directory to the Tcl search path
#
lappend auto_path [file join [file dirname $script] .. lib]

#
# find the name of the script, without reading links
#
set name [file tail $script]

#
# load up the dbus
#
package require dbif

#
# define a set of properties
#
array set data {
    -name {} 
    -class client 
    -value 31415
}

proc regularize {name} {
    return [join [split $name {-}] {}]
}

#
# location testing, / works for everything
# rewrote code to reflect
#
set loc {/org/sdrkit/service}
set loc {/}

proc subloc {name} {
    return {/}
    if {${::loc} eq {/} || ${::loc} eq {}} {
	return "/$name"
    } else {
	return "${::loc}/$name"
    }
}

proc sdrkit-introspect {name} {
    return [dbus call -dest org.sdrkit.$name / org.freedesktop.DBus.Introspectable Introspect]
}
proc sdrkit-get-all {name} {
    return [dbus call -dest org.sdrkit.$name / org.freedesktop.DBus.Properties GetAll org.sdrkit.Bus]
}
proc sdrkit-get-value {name key} {
    return [dbus call -dest org.sdrkit.$name / org.freedesktop.DBus.Properties Get org.sdrkit.Bus $key]
}
proc sdrkit-set-value {name key value} {
    return [dbus call -dest org.sdrkit.$name / org.freedesktop.DBus.Properties Set org.sdrkit.Bus $key $value]
}

#
# create a server
#
proc server {name} {
    set name [regularize $name]
    set ::data(-name) $name
    set ::data(-class) client

    ## connect to the bus
    dbif connect -replace -yield org.sdrkit.$name

    ## listen for replacement
    dbif listen -interface org.freedesktop.DBus \
	/org/freedesktop/DBus NameLost name {
	    set ::finished true
	}

    ## default bus and interface
    dbif default -bus session -interface org.sdrkit.Bus

    ## roll call signal
    set ::rollcall [dbif signal / RollCall]

    ## listen for the responses
    dbif listen / Present {name} {
	puts "$::data(-name): $name reports Present"
	puts "$::data(-name): $name introspection [sdrkit-introspect $name]"
	## make list of names to poll for properties
	foreach {key value} [sdrkit-get-all $name] {
	    puts "$key @ $name -> [sdrkit-get-value $name $key]"
	}
    }

    ## call the first roll
    ## should be done periodically until the respondants settle to a fixed list
    after 500 [list dbif generate $::rollcall]

}

#
# create a client
#
proc client {name} {
    set name [regularize $name]
    set ::data(-name) $name
    set ::data(-class) client

    ## connect to the bus
    dbif connect -replace -yield org.sdrkit.$name

    ## default bus and interface
    dbif default -bus session -interface org.sdrkit.Bus

    ## signal reply to rollcall
    set ::sig [dbif signal / Present {name}]

    ## set up properties
    dbif property -access read / Name ::data(-name)
    dbif property -access read / Class ::data(-class)
    dbif property / Value ::data(-value)
    
    ## listen for the roll call signal
    dbif listen / RollCall {} {
	puts "$::data(-name): RollCall received"
	dbif generate $::sig $::data(-name)
    }

}


proc main {argv} {
    # puts "main: llength = [llength $argv], argv = $argv"
    switch -glob [llength $argv] {
	0 {
	    # canned test
	    main {client0 client1 server0}
	}
	1 {
	    # lauch component
	    set arg [lindex $argv 0]
	    switch -glob $arg {
		client* { client $arg }
		server* { server $arg }
	    }
	    vwait ::finished
	}
	* {
	    # fork to launch list of components
	    foreach arg $argv {
		# puts "exec $::script $arg &"
		exec $::script $arg &
	    }
	}
    }
}

main $argv
