#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

package require Tk
package require snit

package require sdrtk::graph
package require sdrtk::checkmenubutton
package require sdrtk::radiomenubutton
package require math::complexnumbers
package require math::optimize
package require geometry

package require sdrtcl
package require sdrtcl::jack
package require sdrtcl::iq-correct-train
package require sdrtcl::audio-tap

#
# the dttsp formula for apply phase and gain correction:
#
# return linear_gain * creal(z0) + I * (cimag(z0) + sine_phase * crealf(z0));
#
# rewritten as a matrix multiplication:
#
# [ i_out ]   [ linear_gain  0 ]   [ i_in ]
#           =                    x 
# [ q_out ]   [ sine_phase   1 ]   [ q_in ]
#
# compared to the dttsp adaptive filter update, which also corrects phase and gain:
#
# z += w * conj(z) = (wr * zr + wi * zi) + i (- wr * zi + wi * zr)
#
# rewritten as a matrix multiplication:
#
# [ i_out ]   [ wreal   wimag ]   [ i_in ]
#           =                   x 
# [ q_out ]   [ wimag  -wreal ]   [ q_in ]
#
# aren't immediately recognizable as the same thing.
#
# So figure out how they do the same thing
# and figure out what phase and gain correction the adaptive filter applies.
# 
# Also, the sdr# formula for correction, rewritten without recursion and simplified:
#
# real = real - imag * gain * sine_phase;
# imag = imag * gain * cos_phase;
#
# rewritten as a matrix multiplication
#
# [ i_out ]   [ 1      -gain * sine_phase ]   [ i_in ]
#           =                   x 
# [ q_out ]   [ 0       gain * cos_phase  ]   [ q_in ]
#
# isn't recognizable as the same thing, either.
#


# data collection plan.
# 1) collect one buffer of data
# 2) for a variety of values of mu, starting from w = 0
# run iq-correct-train over the buffer repeatedly and collect
# the trajectories of w.
# 2a) note the raw signal strength of the buffer as a potential
# parameter.
# 3) initially run for a fixed number of iterations, but be alert
# for patterns in the trajectories which should be obvious:
# 3a) convergence
# 3b) oscillation
# 3c) blow up
# 4) the goal is to find a collection of pattern recognizers that
# allow you to run a fixed sequence of mu to drive the filter to
# convergence.  Start with a large mu and relax down.
#
# data collection results
# the trajectories in w blow up for large enough mu, that is the
# magnitude of w exceeds 1 or even becomes a NaN.
# For smaller mu we get fixed trajectories, the filter takes the same
# trajectory on each pass through the samples.
# For still smaller mu we get noisy orbits that get smaller on each pass.
# For still smaller mu we progressively damp the excursions in the orbit
# until we get fairly smooth, but slow, progress toward convergence.
#
# My sense is that the ultimate w for a buffer should be independent of
# the order of the samples, that only changes the exact trajectory taken.
# In fact, I think that you could look at the samples independently, see
# the correction they apply to w = 0, and immediately see where it's going
#
# The correction to w when w is 0 and mu is 1 is exactly -z^2.
# If z = cos(phi)+i sin(phi), a perfectly balanced IQ signal,
# then z^2 is cos(phi)^2 - sin(phi)^2 + i 2 cos(phi) sin(phi)
# 
# cos(phi)^2 - sin(phi)^2 is a sine wave at twice the frequency of phi
# which is 1 when abs(cos(phi)) is 1 and -1 when abs(sin(phi)) is 1.
#
# 2 cos(phi) sin(phi) is a sine wave at twice the frequency of phi
# which is 0 when abs(cos(phi)) or abs(sin(phi)) is 1
#
# so the initial correction to w sets it to
#  - cos(phi)^2 + sin(phi)^2 - i 2 cos(phi) sin(phi)
#
# now look at the other part of the correction, z += w z'
# when z = cos(phi) + i sin(phi) then z' = cos(phi) - i sin(phi),
# and w z' = (- cos(phi-1)^2 + sin(phi-1)^2 - i 2 cos(phi-1) sin(phi-1)) * (cos(phi) - i sin(phi))
#          = ((- cos(phi-1)^2 + sin(phi-1)^2) cos(phi) - (2 cos(phi-1) sin(phi-1) sin(phi))) +
#	      i (((- cos(phi-1)^2 + sin(phi-1)^2) sin(phi)) + (2 cos(phi-1) sin(phi-1) cos(phi)))
# which is a mess.
#

array set data {
    -loop false
    -server default
    -name iq
    -tap {system:capture_2 system:capture_1}
    -usbsoftrock false
    -iteration-set {1 2 4 8 16 32 64 128}
    -mu-set {}
    -trainer-set {::trainer1 ::trainer2 ::trainer3 ::trainer4 ::trainer5 ::trainer6 ::trainer7 ::trainer8 ::trainer9 ::trainer10}
    -buffer 10
    selected-trainer {::trainer10}
    selected-iterations 32
    selected-mus {}
    samples {}
    
}
for {set i 0} {$i >= 0} {incr i -1} {
    lappend data(-mu-set) [expr {2.0**$i}]
    lappend data(selected-mus) [expr {2.0**$i}]
}

# get the current date and time
proc acquire-date {} {
    set millis [clock milliseconds]
    set seconds [expr {$millis/1000}]
    set millis [format {.%03d} [expr {$millis%1000}]]
    set format "%C%y-%m-%d %H:%M:%S$millis UTC"
    return [clock format [clock seconds] -timezone :UTC -format $format]
}

# get a consistent title
proc acquire-title {type session} {
    set n [expr {[llength [dict get $session buffer]]/2}]
    return [format {%s %s %6.3f MHz %.2f dBFS %4d} $type [dict get $session date] [dict get $session freq] [dict get $session dBFS] $n]
}

# get the current frequency from the softrock
proc usbsoftrock-getfreq {} {
    if {$::data(-usbsoftrock)} {
	set result [exec usbsoftrock getfreq]
	foreach line [split $result \n] {
	    if {[regexp {^Frequency\s*:\s*(\d+.\d+)\s+.*$} $line all frequency]} {
		return $frequency
	    }
	}
	error "no frequency found in {$result}"
    } else {
	return 0.0
    }
}

# get a buffer of samples from the tap and format as a list of floats
# make sure we get a very fresh buffer of samples
proc acquire-buffer {} {
    while {1} {
	# get the oldest buffer available
	lassign [$::data(-name)-tap get] frame buffer
	# if there is no such buffer
	if {$frame == 0} {
	    # use the last buffer we read
	    if {[info exists lbuffer]} {
		binary scan $lbuffer f* lbuffer
		return $lbuffer
	    }
	    # sleep and try again
	    after 1
	} else {
	    # remember the last buffer we read
	    set lbuffer $buffer
	}
    }
}

# format the list of floats back into a binary byte array
proc format-buffer {buffer} {
    return [binary format f* $buffer]
}

# compute the average power dBFS of the samples
proc compute-power {buffer} {
    set sum 0
    set n 0
    foreach {r i} $buffer {
	set sum [expr {$sum+$r*$r+$i*$i}]
	incr n
    }
    set mean2 [expr {$sum/$n}]
    set dBFS [expr {10 * log10($mean2+1e-16)}]
    return $dBFS
}

##
## iq-correct-train in Tcl
## import the tcllib complex package
##
snit::type iq-correct-train {
    # import complex arithmetic
    constructor {args} {
	foreach x {complex real imag conj + - * mod} {
	    namespace import ::math::complexnumbers::$x
	}
    }
    
    # train
    # z += w * 'z
    # w -= mu * z * z
    # z1 = z0 + w * [conj z0]
    #    = z0 + (w.r + i w.i) * (z0.r - i z0.i)
    #    = z0 + (w.r * z0.r + w.i * z0.i) + i (- w.r * z0.i + w.i * z0.r)
    #    = (z0.r + w.r * z0.r + w.i * z0.i) + i (z0.i - w.r * z0.i + w.i * z0.r)
    # w  = w - mu * z1 * z1
    #    = w - mu * ((z1.r * z1.r - z1.i * z1.i) + i (2 * z1.r * z1.i)
    #    = w - (mu * z1.r * z1.r - mu * z1.i * z1.i) + i (mu * 2 * z1.r * z1.i)
    # how was I going to translate w into gain + degrees phase?
    # 
    # I suppose you could multiply some z by w and see what happens?
    #
    proc train {mu wreal wimag samples} {
	set wlist {}
	set w [complex $wreal $wimag]
	set zmu [complex $mu 0]
	foreach {i q} $samples {
	    set z0 [complex $i $q]
	    set z1 [+ $z0 [* $w [conj $z0]]]
	    set w [- $w [* $zmu [* $z1 $z1]]]
	    if {[real $w] != [real $w] || [imag $w] != [imag $w] || [mod $w] > 1} break
	    lappend wlist $w
	}
	return $wlist
    }
    
    variable ws

    method train {mu wreal wimag samples} {
	set ws [train $mu $wreal $wimag $samples]
	set n [llength $ws]
	if {$n == 0} { return [list $wreal $wimag $wreal $wimag 0] }
	lassign [lindex $ws end] re im
	foreach w $ws {
	    lassign $w r i
	    lappend wr $r
	    lappend wi $i
	    set mod [mod $w]
	    lappend m $mod
	    lappend m2 [tcl::mathop::* $mod $mod]
	}
	set avg_real [tcl::mathop::/ [tcl::mathop::+ {*}$wr] $n]
	set avg_imag [tcl::mathop::/ [tcl::mathop::+ {*}$wi] $n]
	set avg_mag [tcl::mathop::/ [tcl::mathop::+ {*}$m] $n]
	set var_mag [tcl::mathop::- [tcl::mathop::/ [tcl::mathop::+ {*}$m2] $n] [tcl::mathop::* $avg_mag $avg_mag]]
	set disp_mag [tcl::mathop::/ $var_mag $avg_mag]
	return [list $re $im $avg_real $avg_imag $avg_mag $var_mag $disp_mag $n]
    }
    
    method trace {} { return $ws }
}

namespace eval puretcl {}
iq-correct-train ::puretcl::iq-correct-trainer

## first training, iterating the sdrtcl trainer over a series of mus
## reporting the cabs(w) vs t and creal(w) vs cimag(w) at the end of
## each scan over the buffer
snit::type train1 {
    variable session

    proc init-plot {session} {
	.t.title configure -text [dict get $session title]
	.c delete all
	.d delete all
	.e delete all
	.f delete all
	foreach mu [dict get $session mus] {
	    .c add line $mu
	    .d add line $mu
	}
    }

    proc update-plot {mu i re im} {
	set r [expr {$re*$re+$im*$im}]
	.c line add point $mu $i $r
	.d line add point $mu $re $im
    }

    proc finish-plot {} {
	puts "finish-plot"
    }
			      
    # train over a buffer of samples
    proc train {type iterations mus buffer} {
	set session [dict create]

	dict set session iterations $iterations
	dict set session mus $mus
	dict set session buffer $buffer
	dict set session n-samples [expr {[llength $buffer]/2}]

	dict set session date [acquire-date]
	dict set session freq [usbsoftrock-getfreq]
	dict set session dBFS [compute-power [dict get $session buffer]]
	dict set session title [acquire-title $type $session]

	dict set session mu [dict create]
	dict set session mu2 [dict create]
	init-plot $session
	foreach mu $mus {
	    dict set session mu $mu 0 [list 0 0]
	    update-plot $mu 0 0 0
	}
	set binary [format-buffer $buffer]
	array set dead {}

	puts [dict get $session title]

	for {set i 1} {$i < $iterations} {incr i} {
	    puts "iteration $i"
	    foreach mu $mus {
		if { ! [info exists dead($mu)]} {
		    set w [dict get $session mu $mu [expr {$i-1}]]
		    lassign [sdrtcl::iq-correct-train [expr $mu] {*}$w $binary] re im avg_re avg_im avg_mag var_mag disp_mag n
		    # puts "sdrtcl::iq-correct-train $mu $w ... -> $re $im $avg_re $avg_im $avg_mag"
		    if {$n == 0} {
			puts "mu $mu blew up immediately"
			set dead($mu) 1
		    } elseif {$n < [dict get $session n-samples]} {
			puts "mu $mu blew up at sample $n"
			set dead($mu) 1
		    } elseif {$re != $re || $im != $im} {
			puts "mu $mu blew up"
			set dead($mu) 1
		    } elseif {abs($re) > 1 || abs($im) > 1} {
			puts "mu $mu overflow"
			set dead($mu) 1
		    } else {
			dict set session mu $mu $i [list $re $im]
			update-plot $mu $i $re $im
		    }
		}
		update
	    }
	}
	puts "session finished"
	# foreach mu $mus { puts "$mu [dict get $session mu $mu]" }
	finish-plot
    }
    method train {iterations mus samples} {
	return [train [$self info type] $iterations $mus $samples]
    }
}
train1 ::trainer1
    
## second training, run the sdrtcl trainer in parallel with the pure tcl implementation
snit::type train2 {
    variable session

    proc init-plot {session} {
	.t.title configure -text [dict get $session title]
	.c delete all
	.d delete all
	.e delete all
	.f delete all
	foreach mu [dict get $session mus] {
	    .c add line $mu
	    .d add line $mu
	    .e add line $mu
	    .f add line $mu
	}
    }

    proc update-plot {mu i re im} {
	set r [expr {$re*$re+$im*$im}]
	.c line add point $mu $i $r
	.d line add point $mu $re $im
    }
    proc update-plot2 {mu i re im} {
	set r [expr {$re*$re+$im*$im}]
	.e line add point $mu $i $r
	.f line add point $mu $re $im
    }

    proc finish-plot {} {
	#puts "finish-plot"
    }
			      
    # train over a buffer of samples
    proc train {type iterations mus buffer} {
	set session [dict create]
	dict set session iterations $iterations
	dict set session mus $mus
	dict set session buffer $buffer
	dict set session n-samples [expr {[llength $buffer]/2}]

	dict set session date [acquire-date]
	dict set session freq [usbsoftrock-getfreq]
	dict set session dBFS [compute-power $buffer]
	dict set session title [acquire-title $type $session]

	dict set session mu [dict create]
	dict set session mu2 [dict create]
	init-plot $session
	foreach mu $mus {
	    dict set session mu $mu 0 [list 0 0]
	    dict set session mu2 $mu 0 [list 0 0]
	    update-plot $mu 0 0 0
	    update-plot2 $mu 0 0 0
	    set dead1($mu) 0
	    set dead2($mu) 0
	}
	set binary [format-buffer $buffer]

	puts [dict get $session title]

	for {set i 1} {$i < $iterations} {incr i} {
	    puts "iteration $i"
	    foreach mu $mus {
		if { ! $dead1($mu)} {
		    lassign [sdrtcl::iq-correct-train $mu {*}[dict get $session mu $mu [expr {$i-1}]] $binary] re im avg_re avg_im avg_mag var_mag disp_mag n
		    puts "$i 1 $mu -> $re $im $avg_re $avg_im $avg_mag $var_mag $disp_mag $n"
		    if {$n < [dict get $session n-samples]} {
			puts "mu1 $mu blew up at sample $n"
			set dead1($mu) 1
		    } else {
			dict set session mu $mu $i [list $re $im]
			update-plot $mu $i $re $im
		    }
		}
		if { ! $dead2($mu)} {
		    lassign [puretcl::iq-correct-trainer train $mu {*}[dict get $session mu2 $mu [expr {$i-1}]] $buffer] re im avg_re avg_im avg_mag var_mag disp_mag n
		    puts "$i 2 $mu -> $re $im $avg_re $avg_im $avg_mag $var_mag $disp_mag $n"
		    if {$n < [dict get $session n-samples]} {
			puts "mu2 $mu blew up at sample $n"
			set dead2($mu) 1
		    } else {
			dict set session mu2 $mu $i [list $re $im]
			update-plot2 $mu $i $re $im
			update
		    }
		}
	    }
	}
	puts "session finished"
	finish-plot
    }
    method train {iterations mus samples} {
	return [train [$self info type] $iterations $mus $samples]
    }
}
train2 ::trainer2

# third training, run the pure tcl implementation and watch the detailed "progress"   
snit::type train3 {
    variable session
    
    proc init-plot3 {session} {
	.t.title configure -text [dict get $session title]
	.c delete all
	.d delete all
	.e delete all
	.f delete all
	foreach mu [dict get $session mus] {
	    .c add line $mu
	    .d add line $mu
	    .e add line $mu
	    .f add line $mu
	}
    }
    proc reinit-plot3 {session} {
	.c delete all
	.d delete all
	foreach mu [dict get $session mus] {
	    .c add line $mu
	    .d add line $mu
	}
    }    
    proc update-plot3a {mu i re im} {
	set r [expr {$re*$re+$im*$im}]
	.c line add point $mu $i $r
	.d line add point $mu $re $im
    }
    proc update-plot3b {mu i re im} {
	set r [expr {$re*$re+$im*$im}]
	.e line add point $mu $i $r
	.f line add point $mu $re $im
    }    
    proc finish-plot3 {} {
	puts "finish-plot"
    }
    # mean and variance of magnitude w over list of w
    proc mean-and-var-of-mag {ws} {
	foreach w $ws {
	    lassign $w r i
	    set mag2 [expr {$r*$r+$i*$i}]
	    lappend mags [tcl::mathfunc::sqrt $mag2]
	    lappend mag2s $mag2
	}
	set n [llength $ws]
	set meanmag [tcl::mathop::/ [tcl::mathop::+ {*}$mags] $n]
	set varmag [tcl::mathop::- [tcl::mathop::/ [tcl::mathop::+ {*}$mag2s] $n] [tcl::mathop::* $meanmag $meanmag]]
	return [list $n $meanmag $varmag]
    }

    # train over a buffer of samples
    proc train {type iterations mus buffer} {
	set session [dict create]

	dict set session iterations $iterations
	dict set session mus $mus
	dict set session buffer $buffer
	dict set session n-samples [expr {[llength $buffer]/2}]

	dict set session date [acquire-date]
	dict set session freq [usbsoftrock-getfreq]
	dict set session dBFS [compute-power [dict get $session buffer]]

	dict set session title [acquire-title $type $session]

	dict set session mu [dict create]
	init-plot3 $session
	foreach mu $mus {
	    dict set session mu $mu 0 [list 0 0]
	    update-plot3a $mu 0 0 0
	    update-plot3b $mu 0 0 0
	    set dead($mu) 0
	}

	puts [dict get $session title]

	for {set i 1} {$i < $iterations} {incr i} {
	    puts "iteration $i"
	    foreach mu $mus {
		if {$dead($mu)} continue
		lassign [puretcl::iq-correct-trainer train $mu {*}[dict get $session mu $mu [expr {$i-1}]] $buffer] re im avg_re avg_im avg_mag var_mag disp_mag n
		if {$n < [dict get $session n-samples]} {
		    puts "mu $mu blew up at sample $n"
		    set dead($mu) 1
		    continue
		}
		set ws [puretcl::iq-correct-trainer trace]
		# puts "ws is [llength $ws] coefficients vs $n reported"
		lassign [mean-and-var-of-mag $ws] nn mean var
		set disp [expr {$var/$mean}]
		puts "mu $mu mean $mean var $var disp $disp"
		if {$disp > 0.01} {
		    puts "mu $mu too disperse"
		    set dead($mu) 1
		    continue
		}
		set j [expr {($i-1)*1024}]
		foreach w $ws {
		    lassign $w re im
		    update-plot3a $mu $j $re $im
		    incr j
		    update
		}
		update-plot3b $mu $i $re $im
		dict set session mu $mu $i [list $re $im]
	    }
	}
	puts "session3 finished"
	# foreach mu $mus { puts "$mu [dict get $session mu $mu]" }
	finish-plot3
    }
    method train {iterations mus samples} {
	return [train [$self info type] $iterations $mus $samples]
    }
}
train3 ::trainer3

# fourth training, run the pure tcl implementation
snit::type train4 {
    variable session
    
    proc init-plot3 {session} {
	.t.title configure -text [dict get $session title]
	.c delete all
	.d delete all
	.e delete all
	.f delete all
	foreach mu [dict get $session mus] {
	    .c add line $mu
	    .d add line $mu
	    .e add line $mu
	    .f add line $mu
	}
    }
    proc reinit-plot3 {session} {
	.c delete all
	.d delete all
	foreach mu [dict get $session mus] {
	    .c add line $mu
	    .d add line $mu
	}
    }    
    proc update-plot3a {mu i re im} {
	set r [expr {$re*$re+$im*$im}]
	.c line add point $mu $i $r
	.d line add point $mu $re $im
    }
    proc update-plot3b {mu i re im} {
	set r [expr {$re*$re+$im*$im}]
	.e line add point $mu $i $r
	.f line add point $mu $re $im
    }    
    proc finish-plot3 {} {
	puts "finish-plot"
    }

    proc converged {session mu} {
	# has this series of evaluations with $mu as adaptation factor converged
	return 0
    }

    # train over a buffer of samples
    proc train {type iterations mus buffer} {
	set session [dict create]

	dict set session iterations $iterations
	dict set session mus $mus
	dict set session buffer $buffer
	dict set session n-samples [expr {[llength $buffer]/2}]

	dict set session date [acquire-date]
	dict set session freq [usbsoftrock-getfreq]
	dict set session dBFS [compute-power [dict get $session buffer]]

	dict set session title [acquire-title $type $session]

	dict set session mu [dict create]
	init-plot3 $session
	foreach mu $mus {
	    dict set session mu $mu 0 [list 0 0]
	    update-plot3a $mu 0 0 0
	    update-plot3b $mu 0 0 0
	    set dead($mu) 0
	}

	puts [dict get $session title]

	set w [list 0 0]
	foreach mu $mus {
	    if {$dead($mu)} continue
	    puts "start mu $mu at $w"
	    for {set i 1} {$i < $iterations} {incr i} {
		lassign [puretcl::iq-correct-trainer train $mu {*}$w $buffer] re im avg_re avg_im avg_mag var_mag disp_mag n
		if {$n < [dict get $session n-samples]} {
		    puts "mu $mu blew up at sample $n"
		    # start the next mu at the same place
		    set dead($mu) 1
		    break
		}
		set ws [puretcl::iq-correct-trainer trace]
		puts "iteration $i over mu $mu w {$re $im} disp $disp_mag"
		if {$disp_mag > 0.01} {
		    puts "mu $mu too disperse"
		    set dead($mu) 1
		    # start the next iteration at the average of this one
		    set w [list $avg_re $avg_im]
		    break
		}
		set j [expr {($i-1)*1024}]
		foreach wsi $ws {
		    lassign $wsi wsi_re wsi_im
		    update-plot3a $mu $j $wsi_re $wsi_im
		    incr j
		    update
		}
		update-plot3b $mu $i $re $im
		dict set session mu $mu $i [list $re $im]
		# start the next iteration where this one ended
		set w [list $re $im]
		if {[converged $session $mu]} break
	    }
	}
	puts "session finished"
	# foreach mu $mus { puts "$mu [dict get $session mu $mu]" }
	finish-plot3
    }
    method train {iterations mus samples} {
	return [train [$self info type] $iterations $mus $samples]
    }
}
train4 ::trainer4

# fifth training, revert to the sdrtcl implementation
snit::type train5 {
    variable session
    
    proc init-plot {session} {
	.t.title configure -text [dict get $session title]
	.c delete all
	.d delete all
	.e delete all
	.f delete all
	foreach mu [dict get $session mus] {
	    .c add line $mu
	    .d add line $mu
	}
    }
    proc update-plot {mu i re im} {
	set r [expr {$re*$re+$im*$im}]
	.c line add point $mu $i $r
	.d line add point $mu $re $im
    }
    proc finish-plot {} {
	#puts "finish-plot"
    }

    proc converged {re0 im0 re1 im1} {
	# if we're down to 1/1000th change, drop to the next lower mu
	if {abs($re0-$re1) < 0.0001 && abs($im0-$im1) < 0.0001} {
	    return 1
	} else {
	    return 0
	}
    }

    # train over a buffer of samples
    proc train {type iterations mus buffer} {
	set session [dict create]

	dict set session iterations $iterations
	dict set session mus $mus
	dict set session buffer $buffer
	dict set session n-samples [expr {[llength $buffer]/2}]

	dict set session date [acquire-date]
	dict set session freq [usbsoftrock-getfreq]
	dict set session dBFS [compute-power [dict get $session buffer]]

	dict set session title [acquire-title $type $session]

	dict set session mu [dict create]
	init-plot $session
	foreach mu $mus {
	    dict set session mu $mu 0 [list 0 0]
	}

	# puts "mus: {$mus}"
	# puts [dict get $session title]

	set binary [format-buffer $buffer]
	set w [list 0 0]
	set ntotal 0
	set nparts {}
	foreach mu $mus {
	    # puts [format "i %2d mu %.6f w %.6f %.6f" 0 $mu {*}$w]
	    update-plot $mu 0 {*}$w
	    for {set i 1} {$i <= $iterations} {incr i} {
		lassign [sdrtcl::iq-correct-train $mu {*}$w $binary] re im avg_re avg_im avg_mag var_mag disp_mag n
		if {$n < [dict get $session n-samples]} {
		    # puts "mu $mu blew up at sample $n"
		    # start the next mu at the same place
		    lappend nparts 0
		    incr ntotal 0
		    break
		}
		if {$disp_mag > 0.01} {
		    # puts "mu $mu too disperse"
		    # puts [format "i %2d mu %.6f w %.6f %.6f disp %.5f delta %.6f %.6f" $i $mu $re $im $disp_mag [expr {abs([lindex $w 0]-$re)}] [expr {abs([lindex $w 1]-$im)}]]
		    # start the next iteration at the average of this one
		    set w [list $avg_re $avg_im]
		    lappend nparts 1
		    incr ntotal 1
		    break
		}
		update-plot $mu $i $re $im
		dict set session mu $mu $i [list $re $im]
		# start the next iteration where this one ended
		set xw $w
		set w [list $re $im]
		if {$i == $iterations || [converged {*}$xw {*}$w]} {
		    #puts [format "i %2d mu %.6f w %.6f %.6f disp %.5f delta %.6f %.6f" $i $mu $re $im $disp_mag [expr {abs([lindex $w 0]-$re)}] [expr {abs([lindex $w 1]-$im)}]]
		    lappend nparts $i
		    incr ntotal $i
		    break
		}
	    }
	}
	puts [format "%s w {%10.7f %10.7f} {%s} %3d" [dict get $session title] {*}$w $nparts $ntotal]
	# foreach mu $mus { puts "$mu [dict get $session mu $mu]" }
	finish-plot
    }
    method train {iterations mus samples} {
	return [train [$self info type] $iterations $mus $samples]
    }
}
train5 ::trainer5

# sixth training, detailed analysis of samples
snit::type train6 {
    variable session
    
    proc init-plot {session} {
	.t.title configure -text [dict get $session title]
	.c delete all
	.d delete all
	.e delete all
	.f delete all
	foreach mu [dict get $session mus] {
	    .c add line $mu
	    .d add line $mu
	}
    }
    proc update-plot {mu i re im} {
	set r [expr {$re*$re+$im*$im}]
	.c line add point $mu $i $r
	.d line add point $mu $re $im
    }
    proc finish-plot {} {
	#puts "finish-plot"
    }

    proc converged {re0 im0 re1 im1} {
	# if we're down to 1/1000th change, drop to the next lower mu
	if {abs($re0-$re1) < 0.0001 && abs($im0-$im1) < 0.0001} {
	    return 1
	} else {
	    return 0
	}
    }

    # train over a buffer of samples
    proc train {type iterations mus buffer} {
	set session [dict create]

	dict set session iterations $iterations
	dict set session mus $mus
	dict set session buffer $buffer
	dict set session n-samples [expr {[llength $buffer]/2}]

	dict set session date [acquire-date]
	dict set session freq [usbsoftrock-getfreq]
	dict set session dBFS [compute-power [dict get $session buffer]]

	dict set session title [acquire-title $type $session]

	dict set session mu [dict create]
	init-plot $session
	foreach mu $mus {
	    dict set session mu $mu 0 [list 0 0]
	}

	# puts "mus: {$mus}"
	# puts [dict get $session title]

	set binary [format-buffer $buffer]
	set w [list 0 0]
	set ntotal 0
	set nparts {}
	foreach mu $mus {
	    # puts [format "i %2d mu %.6f w %.6f %.6f" 0 $mu {*}$w]
	    update-plot $mu 0 {*}$w
	    for {set i 1} {$i <= $iterations} {incr i} {
		lassign [sdrtcl::iq-correct-train $mu {*}$w $binary] re im avg_re avg_im avg_mag var_mag disp_mag n
		if {$n < [dict get $session n-samples]} {
		    # puts "mu $mu blew up at sample $n"
		    # start the next mu at the same place
		    lappend nparts 0
		    incr ntotal 0
		    break
		}
		if {$disp_mag > 0.01} {
		    # puts "mu $mu too disperse"
		    # puts [format "i %2d mu %.6f w %.6f %.6f disp %.5f delta %.6f %.6f" $i $mu $re $im $disp_mag [expr {abs([lindex $w 0]-$re)}] [expr {abs([lindex $w 1]-$im)}]]
		    # start the next iteration at the average of this one
		    set w [list $avg_re $avg_im]
		    lappend nparts 1
		    incr ntotal 1
		    break
		}
		update-plot $mu $i $re $im
		dict set session mu $mu $i [list $re $im]
		# start the next iteration where this one ended
		set xw $w
		set w [list $re $im]
		if {$i == $iterations || [converged {*}$xw {*}$w]} {
		    #puts [format "i %2d mu %.6f w %.6f %.6f disp %.5f delta %.6f %.6f" $i $mu $re $im $disp_mag [expr {abs([lindex $w 0]-$re)}] [expr {abs([lindex $w 1]-$im)}]]
		    lappend nparts $i
		    incr ntotal $i
		    break
		}
	    }
	}
	puts [format "%s w {%10.7f %10.7f} {%s} %3d" [dict get $session title] {*}$w $nparts $ntotal]
	# foreach mu $mus { puts "$mu [dict get $session mu $mu]" }
	finish-plot
    }
    method train {iterations mus samples} {
	return [train [$self info type] $iterations $mus $samples]
    }
}
train6 ::trainer6

proc log2 {x} { return [expr {int(round(log10($x)/log10(2)))}] }

namespace eval tcl {
    namespace eval mathfunc {
	proc sgn x { return [expr {$x<0?-1:1}] }
    }
}


# seventh training, sweep mu over a buffer of samples, pick the best
snit::type train7 {
    variable session

    # import complex arithmetic
    constructor {args} {
	foreach x {complex real imag conj + - * mod} {
	    namespace import ::math::complexnumbers::$x
	}
    }

    proc init-plot {session} {
	.t.title configure -text [dict get $session title]
	catch {.c delete all}
	foreach s [grid slaves .] {
	    if {$s in {.c .d .e .f}} {
		grid forget $s
	    }
	}
	grid .c -row 1 -column 0 -sticky nsew
	grid columnconfigure . 0 -weight 1
	grid rowconfigure . 1 -weight 1
	set pi [expr {atan2(0,-1)}]
	set pts {}
	for {set i 0} {$i <= 64} {incr i} {
	    set phi [expr {$i*2*$pi/64.0}]
	    lappend pts [expr {cos($phi)}] [expr {sin($phi)}]	    
	}
	.c add line circle
	.c line add point circle {*}$pts
    }

    proc add-line-to-plot {tag args} {
	.c add line $tag
	.c line add point $tag {*}$args
    }

    proc update-plot {re0 im0 re1 im1} {
	# extend the segment from pt0 to p1 to the intersection with the unit circle
	set vx [expr {$re1-$re0}]
	set vy [expr {$im1-$im0}]
	# oh, cheat, just draw the ray of radius 1
	set dv [expr {sqrt($vx*$vx+$vy*$vy)}]
	.c add line [list $re0 $im0]
	.c line add point [list $re0 $im0] $re0 $im0 $re1 $im1 [expr {$re0+$vx/$dv}] [expr {$im0+$vy/$dv}]
    }
    proc finish-plot {} {
	#puts "finish-plot"
    }

    proc estimate-error {buffer} {
	set n 0
	set sum [complex 0 0]
	foreach {i q} $buffer {
	    set z [complex $i $q]
	    set sum [expr {[+ $sum [* $z $z]]}]
	    incr n
	}
	return [expr {max(abs([real $z]/$n), abs([imag $z]/$n))}]
    }
    proc choose-alternate-ws {re1 im1 re2 im2} {
	set line [list $re1 $im1 $re2 $im2]
	set orthag [geometry::orthogonal-line $line]
	# puts "orthogonal-line to $re1 $im1 $re2 $im2 is $orthag"
	set pts [geometry::intersection-line-circle $orthag [list 0 0 1 0]]
	add-line-to-plot [list orthogonal $line] {*}[lindex $pts 0] $re1 $im1 {*}[lindex $pts 1]
	# puts "points intersecting circle at $pts"
	foreach p $pts {
	    lassign $p x y
	    lappend ws [list [expr {($x+$re1)/2}] [expr {($y+$im1)/2}]]
	}
	return $ws
    }
    proc intersections-line-set {args} {
	set pts {}
	foreach line $args {
	    foreach line2 $args {
		if {[lsearch $args $line] < [lsearch $args $line2]} {
		    set pt [geometry::intersection-line-line $line $line2]
		    # puts "geometry::intersection-line-line $line $line2 -> $pt"
		    lappend pts $pt
		}
	    }
	}
	return $pts
    }
    proc average-point-set {args} {
	# puts "average-point-set $args"
	set sum_x 0
	set sum_y 0
	set n 0
	foreach p $args {
	    lassign $p x y
	    set sum_x [expr {$sum_x+$x}]
	    set sum_y [expr {$sum_y+$y}]
	    incr n
	}
	return [list [expr {$sum_x/$n}] [expr {$sum_y/$n}]]
    }
    
    # train over a buffer of samples
    # we are looking for a signal that tells us what mu to start at
    # a mu that is too large will cause w to blow up
    #  this is apparent at the end of a round of training from the value of w
    # a mu that is smaller but still too large causes w to oscillate
    #  this is apparent at the end of a round of training from the dispersion
    #  of the magnitude of w, but I'm not collecting that anymore because it's
    #  expensive to compute, I'm hoping that the dispersion in real(w) or imag(w)
    #  will show a similar signal.
    # a mu that is smaller will move toward the region of filter convergence, then
    #  oscillate when it gets within mu*error of the filter.
    # a mu that is too small will not modify w at all
    #
    # the hope is that looking at the series of w's trained by a series of mu's will
    # have the pattern "blow up* oscillate* converging* nothing*"
    # the oscillate* will have large magnitudes of w, but the angles of w will be
    # wobbling around.
    # the converge* will have decreasing magnitudes of w in proportion to the magnitude
    # of mu, but the angles of w will all be aligned.
    # the goal is to ride the largest mu which is converging until it begins to oscillate
    # and then step down to the next smaller mu, and so on.
    proc train {type iterations mus buffer {winit {0 0}}} {
	set session [dict create]

	dict set session iterations $iterations
	dict set session mus $mus
	dict set session buffer $buffer
	dict set session n-samples [expr {[llength $buffer]/2}]

	dict set session date [acquire-date]
	dict set session freq [usbsoftrock-getfreq]
	dict set session dBFS [compute-power [dict get $session buffer]]

	dict set session title [acquire-title $type $session]

	dict set session mu [dict create]
	foreach mu $mus { dict set session mu $mu 0 [list 0 0] }

	puts "mus: {$mus}"
	puts [dict get $session title]
	
	init-plot $session
	set binary [format-buffer $buffer]
	# start from origin
	set winit {0 0}
	# get the error magnitude
	set e [estimate-error $buffer]
	# pick a mu
	set mu [expr {1e-10/$e}]
	foreach try {0 1 2 3 4 5} {
	    puts [format "%s e %10.7f mu %10.7f w {%10.7f %10.7f}" [dict get $session title] $e $mu {*}$winit]
	    # puts [format "i %2d mu %.6f w %.6f %.6f" 0 $mu {*}$w]
	    lassign [sdrtcl::iq-correct-train2 $mu {*}$winit $binary] re im avg_re avg_im var_re var_im disp_re disp_im
	    if {$re != $re || $im != $im} {
		puts [format {%3.0f NaN NaN} [log2 $mu]]
		break
	    }
	    update-plot {*}$winit $re $im
	    set lines [list [list {*}$winit $re $im]]
	    foreach wx [choose-alternate-ws {*}$winit $re $im] {
		lassign [sdrtcl::iq-correct-train2 $mu {*}$wx $binary] wxre wxim avg_re avg_im var_re var_im disp_re disp_im
		update-plot {*}$wx $wxre $wxim
		lappend lines [list {*}$wx $wxre $wxim]
	    }
	    set pts [intersections-line-set {*}$lines]
	    set winit [average-point-set {*}$pts]
	    puts [format {%12.9f %12.9f : %s} {*}$winit $pts]
	}
    }
    method train {iterations mus samples {winit {0 0}}} {
	return [train [$self info type] $iterations $mus $samples $winit]
    }
}
train7 ::trainer7

# eighth training, pick a small mu and minimize the error
namespace eval ::opt8 {
    variable line-params
    proc function-on-line {p} {
	variable line-params
	# get the line parameters
	lassign ${line-params} mu x0 y0 dx dy binary
	# compute the p position on the line
	set x [expr {$x0+$p*$dx}]
	set y [expr {$y0+$p*$dy}]
	# evaluate the adaptive filter
	set rest [lassign [sdrtcl::iq-correct-train2 $mu $x $y $binary] xp yp]
	# find the displacement vector from where the filter started
	set dxp [expr {$xp-$x}]
	set dyp [expr {$yp-$y}]
	# find the projection of the displacement on our line
	set dot [expr {$dx*$dxp+$dy*$dyp}]
	# square it
	return [expr {$dot*$dot}]
    }
    proc minimize-on-line {mu x0 y0 dx dy binary} {
	variable line-params
	set {line-params} [list $mu $x0 $y0 $dx $dy $binary]
	lassign [::math::optimize::min_bound_1d function-on-line 0 [expr {1/sqrt($dx*$dx+$dy*$dy)}] -trace 0] p f_of_p
	set result [list [expr {$x0+$p*$dx}] [expr {$y0+$p*$dy}] ]
	# puts "min at $p is $f_of_p: $result"
	return $result
    }
}

snit::type train8 {
    variable session

    # import complex arithmetic
    constructor {args} {
	foreach x {complex real imag conj + - * mod} {
	    namespace import ::math::complexnumbers::$x
	}
    }

    proc init-plot {session} {
	.t.title configure -text [dict get $session title]
	catch {.c delete all}
	foreach s [grid slaves .] {
	    if {$s in {.c .d .e .f}} {
		grid forget $s
	    }
	}
	grid .c -row 1 -column 0 -rowspan 2 -columnspan 2 -sticky nsew
	grid columnconfigure . 0 -weight 1
	grid rowconfigure . 1 -weight 1
	set pi [expr {atan2(0,-1)}]
	set pts {}
	for {set i 0} {$i <= 64} {incr i} {
	    set phi [expr {$i*2*$pi/64.0}]
	    lappend pts [expr {cos($phi)}] [expr {sin($phi)}]	    
	}
	.c add line circle
	.c line add point circle {*}$pts
	.c add line traj
	.c line add point traj 0 0
    }

    proc add-line-to-plot {tag args} {
	.c add line $tag
	.c line add point $tag {*}$args
    }

    proc update-plot {re im} {
	.c line add point traj $re $im
    }
    proc finish-plot {} {
	#puts "finish-plot"
    }

    proc estimate-error {buffer} {
	set n 0
	set sum [complex 0 0]
	foreach {i q} $buffer {
	    set z [complex $i $q]
	    set sum [expr {[+ $sum [* $z $z]]}]
	    incr n
	}
	return [expr {max(abs([real $z]/$n), abs([imag $z]/$n))}]
    }
    # train over a buffer of samples
    # we are looking for a signal that tells us what mu to start at
    # a mu that is too large will cause w to blow up
    #  this is apparent at the end of a round of training from the value of w
    # a mu that is smaller but still too large causes w to oscillate
    #  this is apparent at the end of a round of training from the dispersion
    #  of the magnitude of w, but I'm not collecting that anymore because it's
    #  expensive to compute, I'm hoping that the dispersion in real(w) or imag(w)
    #  will show a similar signal.
    # a mu that is smaller will move toward the region of filter convergence, then
    #  oscillate when it gets within mu*error of the filter.
    # a mu that is too small will not modify w at all
    #
    # the hope is that looking at the series of w's trained by a series of mu's will
    # have the pattern "blow up* oscillate* converging* nothing*"
    # the oscillate* will have large magnitudes of w, but the angles of w will be
    # wobbling around.
    # the converge* will have decreasing magnitudes of w in proportion to the magnitude
    # of mu, but the angles of w will all be aligned.
    # the goal is to ride the largest mu which is converging until it begins to oscillate
    # and then step down to the next smaller mu, and so on.
    proc train {type iterations mus buffer {winit {0 0}}} {
	set session [dict create]

	dict set session iterations $iterations
	dict set session mus $mus
	dict set session buffer $buffer
	dict set session n-samples [expr {[llength $buffer]/2}]

	dict set session date [acquire-date]
	dict set session freq [usbsoftrock-getfreq]
	dict set session dBFS [compute-power [dict get $session buffer]]

	dict set session title [acquire-title $type $session]

	dict set session mu [dict create]
	foreach mu $mus { dict set session mu $mu 0 [list 0 0] }

	
	init-plot $session
	set binary [format-buffer $buffer]
	# start from origin
	set winit {0 0}
	# get the error magnitude
	set e [estimate-error $buffer]
	# pick a mu
	set mu [expr {1e-10/$e}]
	puts [format {e %f mu %f %s} $e $mu [dict get $session title]]
	foreach size {1 2 4 8 16 32 64} {
	    set subbuffer [lrange $buffer 0 [expr {([llength $buffer]/$size)-1}]]
	    #puts "subbuffer [llength $subbuffer] is [llength $buffer]/$size"
	    set binary [format-buffer $subbuffer]
	    lassign [sdrtcl::iq-correct-train2 $mu {*}$winit $binary] re im avg_re avg_im var_re var_im disp_re disp_im
	    if {$re != $re || $im != $im} {
		puts [format {%3.0f NaN NaN} [log2 $mu]]
		break
	    }
	    set wnew [::opt8::minimize-on-line $mu {*}$winit $re $im $binary]
	    puts [format "size 1/$size w0 {%g %g} -> w1 {%g %g}" {*}$winit {*}$wnew]
	    update-plot {*}$wnew
	    set winit $wnew
	}
    }
    method train {iterations mus samples {winit {0 0}}} {
	return [train [$self info type] $iterations $mus $samples $winit]
    }
}
train8 ::trainer8

snit::type train9 {
    variable session

    # import complex arithmetic
    constructor {args} {
	foreach x {complex real imag conj + - * mod} {
	    namespace import ::math::complexnumbers::$x
	}
    }
    
    proc estimate-error {buffer} {
	set n 0
	set sum [complex 0 0]
	foreach {i q} $buffer {
	    set z [complex $i $q]
	    set sum [expr {[+ $sum [* $z $z]]}]
	    incr n
	}
	return [expr {max(abs([real $z]/$n), abs([imag $z]/$n))}]
    }
    proc report {tag p w f m d} {
	puts "$tag p=$p w={$w} f={$w} m=$m d=$d"
    }

    #
    # train over a buffer of samples
    # starting from w {0 0},
    # compute the error signal magnitude
    # assign mu appropriate to the error signal magnitude
    # train one buffer of sample to find the direction of the converged filter coefficients
    # perform a binary search for the converged filter coefficients along that direction
    # between w {0 0} and the circumference of the unit circle
    #
    proc train {type iterations mus buffer {winit {0 0}}} {
	set session [dict create]

	dict set session iterations $iterations
	dict set session mus $mus
	dict set session buffer $buffer
	dict set session n-samples [expr {[llength $buffer]/2}]

	dict set session date [acquire-date]
	dict set session freq [usbsoftrock-getfreq]
	dict set session dBFS [compute-power [dict get $session buffer]]

	dict set session title [acquire-title $type $session]

	dict set session mu [dict create]
	foreach mu $mus { dict set session mu $mu 0 [list 0 0] }

	
	set binary [format-buffer $buffer]
	# start from origin
	set winit {0 0}
	# get the error magnitude
	set e [estimate-error $buffer]
	# pick a mu
	set mu [expr {1e-10/$e}]
	# report our starting conditions
	puts [format {e %f mu %f %s} $e $mu [dict get $session title]]
	# format the samples as a binary
	set binary [format-buffer $buffer]

	# evaluate the filter at w = {0 0}
	# parameter of point 0
	set p0 0
	# filter coefficients at point 0
	set w0 {0 0} 
	# filter evaluation at point 0
	set f0 [lrange [sdrtcl::iq-correct-train2 $mu {*}$w0 $binary] 0 1]
	# coordinates of filter coefficients at point 0
	lassign $f0 x0 y0
	## the direction of our line search
	lassign $f0 dx dy
	# direction of filter coefficients at point 0
	set d0 [expr {$x0*$dx+$y0*$dy}]
	# magnitude of filter coefficients at point 0
	set m0 [expr {sqrt($x0*$x0+$y0*$y0)}]
	report p0 $p0 $w0 $f0 $m0 $d0

	# evaluate the filter at w {$dx $dy} projected to circumference of unit circle
	set p2 [expr {1.0/$m0}]
	set w2 [list [expr {$p2*$dx}] [expr {$p2*$dy}]]
	set f2 [lrange [sdrtcl::iq-correct-train2 $mu {*}$w2 $binary] 0 1]
	lassign $f2 x2 y2
	set x2 [expr {$x2-[lindex $w2 0]}]
	set y2 [expr {$y2-[lindex $w2 1]}]
	set m2 [expr {sqrt($x2*$x2+$y2*$y2)}]
	set d2 [expr {$x2*$dx+$y2*$dy}]
	report p2 $p2 $w2 $f2 $m2 $d2

	# binary search
	while {1} {
	    set p1 [expr {($p0+$p2)/2}]
	    set w1 [list [expr {$p1*$dx}] [expr {$p1*$dy}]]
	    set f1 [lrange [sdrtcl::iq-correct-train2 $mu {*}$w1 $binary] 0 1]
	    lassign $f1 x1 y1
	    set x1 [expr {$x1-[lindex $w1 0]}]
	    set y1 [expr {$y1-[lindex $w1 1]}]
	    set m1 [expr {sqrt($x1*$x1+$y1*$y1)}]
	    set d1 [expr {$x1*$dx+$y1*$dy}]
	    report p1 $p1 $w1 $f1 $m1 $d1
	    if {$m1 < 1e-10} {
		# call it quits
		break
	    }
	    if {$d0 > 0 && $d1 < 0} {
		# move search to p0 .. p1
		lassign [list $p1 $w1 $f1 $x1 $y1 $m1 $d1] p2 w2 f2 x2 y2 m2 d2
	    } elseif {$d1 > 0 && $d2 < 0} {
		# move search to p1 .. p2
		lassign [list $p1 $w1 $f1 $x1 $y1 $m1 $d1] p0 w0 f0 x0 y0 m0 d0
	    } elseif {$d1 == 0} {
		# unlikely, but possible
		break
	    }
	}
	puts "w = $w1, f = $f1, m = $m1, d = $d1"
    }
    method train {iterations mus samples {winit {0 0}}} {
	return [train [$self info type] $iterations $mus $samples $winit]
    }
}
train9 ::trainer9

snit::type train10 {
    variable session

    # import complex arithmetic
    constructor {args} {
	foreach x {complex real imag conj + - * mod} {
	    namespace import ::math::complexnumbers::$x
	}
    }
    
    proc estimate-error {buffer} {
	set n 0
	set sum [complex 0 0]
	foreach {i q} $buffer {
	    set z [complex $i $q]
	    set sum [expr {[+ $sum [* $z $z]]}]
	    incr n
	}
	return [expr {max(abs([real $z]/$n), abs([imag $z]/$n))}]
    }

    proc report {tag p w f m d} {
	puts "$tag p=$p w={$w} f={$w} m=$m d=$d"
    }

    #
    # train over a buffer of samples
    # starting from w {0 0},
    # compute the error signal magnitude
    # assign mu appropriate to the error signal magnitude
    # train one buffer of sample to find the direction of the converged filter coefficients
    # use Newton's method to search for the minimum filter coefficients along the direction
    #
    proc train {type iterations mus buffer {winit {0 0}}} {
	set session [dict create]

	dict set session iterations $iterations
	dict set session mus $mus
	dict set session buffer $buffer
	dict set session n-samples [expr {[llength $buffer]/2}]

	dict set session date [acquire-date]
	dict set session freq [usbsoftrock-getfreq]
	dict set session dBFS [compute-power [dict get $session buffer]]

	dict set session title [acquire-title $type $session]

	dict set session mu [dict create]
	foreach mu $mus { dict set session mu $mu 0 [list 0 0] }

	
	set binary [format-buffer $buffer]
	# start from origin
	set winit {0 0}
	# get the error magnitude
	set e [estimate-error $buffer]
	# pick a mu
	set mu [expr {1e-10/$e}]
	# report our starting conditions
	puts [format {e %f mu %f %s} $e $mu [dict get $session title]]
	# format the samples as a binary
	set binary [format-buffer $buffer]

	# evaluate the filter at w = {0 0}
	# parameter of point 0
	set p0 0
	# filter coefficients at point 0
	set w0 {0 0} 
	# filter evaluation at point 0
	set f0 [lrange [sdrtcl::iq-correct-train2 $mu {*}$w0 $binary] 0 1]
	# coordinates of filter coefficients at point 0
	lassign $f0 x0 y0
	## the direction of our line search
	lassign $f0 dx dy
	## the magnitude of our line search direction
	set md [expr {sqrt($dx*$dx+$dy*$dy)}]
	# direction of filter coefficients at point 0
	set d0 [expr {($x0*$dx+$y0*$dy)/$md}]
	# magnitude of filter coefficients at point 0
	set m0 [expr {sqrt($x0*$x0+$y0*$y0)}]

	# Newton's method x[i+1] = x[i] - f(x[i])/f'(x[i])
	# x[i] will be the parameter of position on the line
	# f(x[i]) will be the magnitude of the filter coefficient change trained from x[i]
	# f'(x[i]) will be the negative of the direction of the filter coefficient change trained from x[i]
	set n 0
	while {[incr n] < 20} {
	    report p0 $p0 $w0 $f0 $m0 $d0
	    puts "set p0 $p0-$m0/(-$d0) = $p0 - [expr {$m0/(-$d0)}]"
	    set p0 [expr {$p0-$m0/(-$d0)}]
	    set w0 [list [expr {$p0*$dx}] [expr {$p0*$dy}]]
	    set f0 [lrange [sdrtcl::iq-correct-train2 $mu {*}$w0 $binary] 0 1]
	    lassign $f0 x0 y0
	    set x0 [expr {$x0-[lindex $w0 0]}]
	    set y0 [expr {$y0-[lindex $w0 1]}]
	    set m0 [expr {sqrt($x0*$x0+$y0*$y0)}]
	    set d0 [expr {($x0*$dx+$y0*$dy)/$md}]
	    if {$m0 < 1e-10} {
		# call it quits
		break
	    }
	}
	puts "p = $p0, w = $w0, f = $f0, m = $m0, d = $d0"
    }
    method train {iterations mus samples {winit {0 0}}} {
	return [train [$self info type] $iterations $mus $samples $winit]
    }
}
train10 ::trainer10

proc do-train {} { $::data(selected-trainer) train $::data(selected-iterations) $::data(selected-mus) $::data(samples) }
proc start-train {} { after 1 do-train }

# shutdown the jack components
proc shutdown {w} {
    if {$w eq {.}} {
	$::data(-name)-tap stop
	$::data(-name)-tap deactivate
	rename $::data(-name)-tap {}
    }
}
proc new-samples {} {
    set ::data(samples) [acquire-buffer]
}

# set up with a go button
proc main {argv} {
    foreach {option value} $argv {
	puts "$option $value"
	switch -- $option {
	    -b - -buffer - --buffer { set ::data(-buffer) $value }
	    -l - -loop - --loop { set ::data(-loop) $value }
	    -n - -name - --name { set ::data(-name) $value }
	    -s - -server - --server { set ::data(-server) $value }
	    -t - -tap - --tap { set ::data(-tap) $value }
	    -u - -usb - --usb { set ::data(-usbsoftrock) $value }
	    default { error "unknown option \"$option\"" }
	}
    }
    sdrtcl::audio-tap $::data(-name)-tap -server $::data(-server) -log2size $::data(-buffer) -log2n 2 -complex 1
    $::data(-name)-tap activate
    puts "$::data(-name)-tap activate"
    $::data(-name)-tap start
    puts "$::data(-name)-tap start"
    if {$::data(-tap) ne {}} {
	foreach in $::data(-tap) out [$::data(-name)-tap info ports] {
	    sdrtcl::jack connect $in [join [list $::data(-name)-tap $out] :]
	}
    }
    after 50
    set ::data(samples) [acquire-buffer]
    wm title . sdrkit:$::data(-name)
    grid [ttk::frame .t] -row 0 -column 0 -columnspan 2
    grid [ttk::button .t.acquire -text {New Samples} -command new-samples] -row 0 -column 0
    grid [ttk::button .t.train -text Train -command [list start-train]] -row 0 -column 1
    grid [sdrtk::radiomenubutton .t.trainer -defaultvalue $::data(selected-trainer) \
	      -values $::data(-trainer-set) -command [list set ::data(selected-trainer)] \
	     ] -row 0 -column 2
    grid [sdrtk::radiomenubutton .t.iterations -defaultvalue $::data(selected-iterations) \
	      -values $::data(-iteration-set) -command [list set ::data(selected-iterations)] \
	     ] -row 0 -column 3
    grid [sdrtk::checkmenubutton .t.mu -text mu -defaultselected $::data(selected-mus) \
	      -values $::data(-mu-set) -command [list set ::data(selected-mus)] \
	     ] -row 0 -column 4
    grid [ttk::label .t.title -text {}] -row 1 -column 0 -columnspan 5
    grid [sdrtk::graph .c] [sdrtk::graph .e] -row 1 -sticky nsew
    grid [sdrtk::graph .d] [sdrtk::graph .f] -row 2 -sticky nsew
    grid rowconfigure . 1 -weight 1
    grid rowconfigure . 2 -weight 1
    grid columnconfigure . 0 -weight 1
    grid columnconfigure . 1 -weight 1
    bind . <Destroy> [list shutdown %W]
    if {$::data(-loop)} {
	# repeat
	for {set x 0} {$x < 100000} {incr x} {
	    # randomly tune 1.5-30MHz
	    set freq [format %.6f [expr {1.5+(30-1.5)*rand()}]]
	    exec usbsoftrock set freq $freq
	    after 500
	    for {set i 0} {$i < 5} {incr i} {
		after 10
		set ::data(samples) [acquire-buffer]
		$::data(selected-trainer) train $::data(selected-iterations) $::data(selected-mus) $::data(samples)
	    }
	}
	exit 0
    }
}

main $argv
