#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
package require Tk
package require Expect

##
## The game is to learn the morse code patterns by listening
## to morse code characters and groups of characters and
## responding.
##
## For the moment you must type to respond, but that's not
## ideal, what we want is to respond in morse code.  If you
## can remember the dits and dahs long enough to key them
## back, then you're establishing the auditory-muscular loop
## between the sounds and the motions that make the sound.
## It's that auditory-muscular loop that the meaning gets
## attached to in your brain.  Until you establish the loop,
## by practising listening and responding, you will always
## be fumbling around.
##
## In any case, the idea is to make it a game where you're
## given patterns and a chance to respond.  When you respond
## correctly, the pattern is decoded visually in a rewarding
## color.
##
## If you respond incorrectly or fail to respond, the pattern
## is repeated, repeated with increasing visual cues, and
## finally decoded in an unrewarding color.
##
## The game should keep track of your progress and repeat
## things which you have problems until you get them right.
##
## the game should start with the shortest patterns and
## build up.  in fact, probably work at particular lengths
## whether they're single letters or combinations.
##
## as you get better, the characters will become digrams,
## trigrams, and longer.  Not much point in applying the
## expected character frequencies, since that isn't what
## you'll need to copy over the air.
##

##
## todo -
## [ ] - use separate tones for ascii and iambic
##

proc plug-exists {client} {
    global plug
    return [info exists plug($client-fp)]
}

proc plug-open {program client {server default}} {
    global plug
    set bindir [file dirname [info script]]
    set plug($client-binary) [file join $bindir $program]
    # test for file exists
    set plug($client-out-file) "/tmp/keyer-control-[pid]-$client.out"
    set plug($client-fp) [open "|$plug($client-binary) --server $server --client $client >& $plug($client-out-file)" w]
    fconfigure $plug($client-fp) -buffering none
    set plug($client-out-fp) [open "$plug($client-out-file)" r]
    fconfigure $plug($client-out-fp) -blocking 0 -buffering none
    # fileevent $plug($client-out-fp) readable "plug-readable $client"
    lappend plug(clients) $client
}

proc plug-close {client} {
    global plug
    if {[plug-exists $client]} {
	puts stderr "plug-close $client"
	close $plug($client-fp)
	close $plug($client-out-fp)
	file delete $plug($client-out-file)
	foreach name [array names plug $client-*] {
	    unset plug($name)
	}
	set i [lsearch -exact $plug(clients) $client]
	set plug(clients) [lreplace $plug(clients) $i $i]
    } else {
	puts stderr "non-existent client $client in plug-close"
    }
}

proc plug-close-all {} {
    global plug
    foreach client $plug(clients) {
	plug-close $client
    }
}

proc plug-puts {client opt value} {
    global plug
    if {[plug-exists $client]} {
	puts $plug($client-fp) "<$opt$value>"
    } else {
	puts stderr "non-existent client $client in plug-puts"
    }
}

proc plug-puts-text {client text} {
    global plug
    if {[plug-exists $client]} {
	puts $plug($client-fp) $text
    } else {
	puts stderr "non-existent client $client in plug-puts-text"
    }
}

proc plug-readable {client} {
    global plug
    # puts "plug-readable $client"
    if {[gets $plug($client-out-fp) line] < 0} {
	if {[eof $plug($client-out-fp)]} {
	    # don't close, they're files that will grow
	    # plug-close $client
	}
	return;
    }
    lappend plug($client-input) $line
}

proc plug-gets {client} {
    global plug
    if {[llength $plug($client-input)] > 0} {
	set line [lindex $plug($client-input) 0]
	set plug($client-input) [lreplace $plug($client-input) 0 0]
	return $line
    }
    return {}
}

#
# initialize the plugged in helper applications
#
proc plug-init {} {
    global data
    # start jack
    # look for zombie helpers?
    foreach line [split [string trim [exec jack_lsp]] \n] {
	switch -glob $line {
	    ascii:* -
	    iambic:* -
	    ascii_tone:* -
	    iambic_tone:* -
	    ascii_decode:* -
	    iambic_decode:* {
		error "the [lindex [split $line :] 0] client is still running"
	    }
	}
    }
    # find helpers
    plug-open keyer_ascii ascii
    plug-open keyer_tone ascii_tone
    plug-open keyer_decode ascii_decode
    plug-open keyer_iambic iambic
    plug-open keyer_tone iambic_tone
    plug-open keyer_decode iambic_decode
    # these names may need to change around
    after 500
    set retry {}
    foreach cmd {
	{jack_connect ascii:midi_out ascii_tone:midi_in}
	{jack_connect ascii:midi_out ascii_decode:midi_in}
	{jack_connect iambic:midi_out iambic_tone:midi_in}
	{jack_connect iambic:midi_out iambic_decode:midi_in}
	{jack_connect system:midi_capture_1 iambic:midi_in}
	{jack_connect ascii_tone:out_i system:playback_1}
	{jack_connect ascii_tone:out_q system:playback_2}
	{jack_connect iambic_tone:out_i system:playback_1}
	{jack_connect iambic_tone:out_q system:playback_2}
    } {
	if {[catch "exec $cmd" error]} {
	    puts "$cmd: yielded $error"
	    lappend retry $cmd
	}
    }
    foreach cmd $retry {
	if {[catch "exec $cmd" error]} {
	    puts "$cmd: failed again, yielded $error"
	}
    }
}

##
## parameters and operating data
##
array set data {

    ascii_tone-freq 700
    ascii_tone-gain -30
    ascii_tone-rise 5
    ascii_tone-fall 5
    ascii-wpm 15
    ascii-word 60
    ascii-dah 3
    ascii-ies 1
    ascii-ils 3
    ascii-iws 7
    iambic_tone-freq 750
    iambic_tone-gain -30
    iambic_tone-rise 5
    iambic_tone-fall 5
    iambic-wpm 15
    iambic-word 60
    iambic-dah 3
    iambic-ies 1
    iambic-ils 3
    iambic-iws 7
    iambic-mode A
    iambic-alsp 0
    iambic-awsp 0
    iambic-swap 0

    w6rec.com.letter.sets {
	EISH5 TMO0 AWJ1 NDB6 AUV4
    }

    # {country {{prefixes} {continent}}}
    callsigns {
	{Afghanistan}	{{YA, T6}	{AS}}
	{Agalega & St. Brandon Is.}	{{3B6, 3B7}	{AF}}	
	{Aland Island}	{{OH0}	{EU}}	
	{Alaska}	{{KL7, AL7, NL7, WL7}	{NA}}	
	{Albania}	{{ZA}	{EU}}	
	{Algeria}	{{7T-7Y}	{AF}}	
	{American Samoa}	{{KH8, AH8, NH8, WH8}	{OC}}	
	{Amsterdam & St. Paul Is.}	{{FT5Z}	{AF}}	
	{Andaman & Nicobar Island}	{{VU4}	{AS}}	
	{Andorra}	{{C3}	{EU}}	
	{Angola}	{{D2, D3}	{AF}}	
	{Anguilla}	{{VP2E}	{OC}}	
	{Annobon Island}	{{3C0}	{AF}}	
	{Antarctica}	{{CE9, KC4, VK0, 8J1}	{AN}}	
	{Antigua & Barbuda}	{{V2}	{NA}}	
	{Argentina}	{{LO-LW, L2-L9, AY-AZ}	{SA}}	
	{Armenia}	{{EK}	{AS}}	
	{Aruba}	{{P4}	{SA}}	
	{Ascension Island}	{{ZD8}	{AF}}	
	{Asiatic Russia}	{{UA-UI8, RA-RZ. 9 & 0}	{AS}}	
	{Auckland & Campbell Is.}	{{ZL9}	{OC}}	
	{Austral Island}	{{FO}	{OC}}	
	{Australia}	{{VK, VI, AX}	{OC}}	
	{Austria}	{{OE}	{EU}}	
	{Aves Island}	{{YV0, YX0}	{NA}}	
	{Azerbaijan}	{{4J, 4K}	{AS}}	
	{Azores}	{{CU. 1-9}	{EU}}	
	{Bahamas}	{{C6}	{NA}}	
	{Bahrain}	{{A9}	{AS}}	
	{Baker & Howland Island}	{{KH1, K1B, AH1, NH1, WH1}	{OC}}	
	{Balearic Island}	{{EA6-EH6}	{EU}}	
	{Banaba Is. (Ocean Is.)}	{{T33}	{OC}}	
	{Bangladesh}	{{S2}	{AS}}	
	{Barbados}	{{8P}	{NA}}	
	{Belarus}	{{EU, EV, EW}	{EU}}	
	{Belgium}	{{ON-OT}	{EU}}	
	{Belize}	{{V3}	{NA}}	
	{Benin}	{{TY}	{AF}}	
	{Bermuda}	{{VP9}	{NA}}	
	{Bhutan}	{{A5}	{AS}}	
	{Bolivia}	{{CP}	{SA}}	
	{Bonaire, Curacao. Netherlands Antilles}	{{PJ2, 4, 9}	{SA}}	
	{Bosnia-Herzegovina}	{{E7 (T9)}	{EU}}	
	{Botswana}	{{A2, 8O}	{AF}}	
	{Bouvet Island}	{{3Y}	{AF}}	
	{Brazil}	{{PP-PY, ZV-ZZ}	{SA}}	
	{British Virgin Island}	{{VP2V}	{NA}}	
	{Brunei}	{{V8}	{OC}}	
	{Bulgaria}	{{LZ}	{EU}}	
	{Burkina Faso}	{{XT}	{AF}}	
	{Burundi}	{{9U}	{AF}}	
	{Cambodia}	{{XU}	{AS}}	
	{Cameroon}	{{TJ}	{AF}}	
	{Canada}	{{VA-VG, VO, VX-VY, CF-CK, CY-CZ, XJ-XO}	{NA}}	
	{Canary Island}	{{EA8-EH8}	{AF}}	
	{Cape Verde}	{{D4}	{AF}}	
	{Cayman Island}	{{ZF}	{NA}}	
	{Central Africa}	{{TL}	{AF}}	
	{Central Kiribati. (British Phoenix Island)}	{{T31}	{OC}}	
	{Ceuta & Melilla}	{{EA9-EH9}	{AF}}	
	{Chad}	{{TT}	{AF}}	
	{Chagos Island}	{{VQ9}	{AF}}	
	{Chatham Island}	{{ZL7}	{OC}}	
	{Chesterfield Island}	{{TX0, TX9}	{OC}}	
	{Chile}	{{CA-CE, XQ, XR, 3G}	{SA}}	
	{China}	{{BY, BA-BL, BR-BT}	{AS}}	
	{Christmas Island}	{{VK9X}	{OC}}	
	{Clipperton Island}	{{FO}	{NA}}	
	{Cocos Island}	{{TI9}	{NA}}	
	{Cocos-Keeling Island}	{{VK9C}	{OC}}	
	{Colombia}	{{HK, HJ, 5J, 5K}	{SA}}	
	{Comoros}	{{D6}	{AF}}	
	{Congo (Republic of)}	{{TN}	{AF}}	
	{Conway Reef}	{{3D2/C}	{OC}}	
	{Corsica}	{{TK}	{EU}}	
	{Costa Rica}	{{TI, TE}	{NA}}	
	{Cote d'Ivoire}	{{TU}	{AF}}	
	{Crete}	{{SV9}	{EU}}	
	{Croatia}	{{9A}	{EU}}	
	{Crozet Island}	{{FT5W}	{AF}}	
	{Cuba}	{{CO, CL, CM, T4}	{NA}}	
	{Cyprus}	{{5B, C4, H2, P3}	{AS}}	
	{Czech Republic}	{{OK-OL}	{EU}}	
	{Dem. People's Rep. Korea}	{{P5}	{AS}}	
	{Dem. Rep. of Congo}	{{9Q-9T}	{AF}}	
	{Denmark}	{{OZ. OU, OV, OW. XP. 5P, 5Q.}	{EU}}	
	{Desecheo Island}	{{KP5, NP5, WP5}	{NA}}	
	{Djibouti}	{{J2}	{AF}}	
	{Dodecanese}	{{SV5}	{EU}}	
	{Dominica}	{{J7}	{NA}}	
	{Dominican Republic}	{{HI}	{NA}}	
	{Ducie Island}	{{VP6D}	{OC}}	
	{East Kiribati (Line Is.)}	{{T32}	{OC}}	
	{East Malaysia}	{{9M6-9M8}	{OC}}	
	{Easter Island}	{{CE0, 3G0}	{SA}}	
	{Ecuador}	{{HC-HD}	{SA}}	
	{Egypt}	{{SU}	{AF}}	
	{El Salvador}	{{YS, HU}	{NA}}	
	{England}	{{G, M, 2E}	{EU}}	
	{Equatorial Guinea}	{{3C}	{AF}}	
	{Eritrea}	{{E3}	{AF}}	
	{Estonia}	{{ES}	{EU}}	
	{Ethiopia}	{{ET, 9E-9F}	{AF}}	
	{European Russia}	{{UA-UI, RA-RZ. 1, 3, 4, 6}	{EU}}	
	{Falkland Island}	{{VP8}	{SA}}	
	{Faroe Islands}	{{OY}	{EU}}	
	{Fed. Rep. of Germany}	{{DA-DL}	{EU}}	
	{Fernando de Noronha}	{{PP0-PY0F}	{SA}}	
	{Fiji}	{{3D2}	{OC}}	
	{Finland}	{{OF-OI}	{EU}}	
	{France}	{{F, TM}	{EU}}	
	{Franz Josef Land}	{{R1FJ}	{EU}}	
	{French Guiana}	{{FY}	{SA}}	
	{French Polynesia}	{{FO}	{OC}}	
	{Gabon}	{{TR}	{AF}}	
	{Galapagos Island}	{{HC8, HD8}	{SA}}	
	{Georgia}	{{4L}	{AS}}	
	{Ghana}	{{9G}	{AF}}	
	{Gibraltar}	{{ZB2}	{EU}}	
	{Glorioso Island}	{{FR/G}	{AF}}	
	{Greece}	{{SV-SZ}	{EU}}	
	{Greenland}	{{OX}	{NA}}	
	{Grenada}	{{J3}	{NA}}	
	{Guadeloupe}	{{FG, TO}	{NA}}	
	{Guam}	{{KH2, AH2, NH2, WH2}	{OC}}	
	{Guantanamo Bay}	{{KG4, KG4AA-AZ}	{NA}}	
	{Guatemala}	{{TG, TD}	{NA}}	
	{Guernsey}	{{GU, GP, MU, 2U}	{EU}}	
	{Guinea}	{{3X}	{AF}}	
	{Guinea-Bissau}	{{J5}	{AF}}	
	{Guyana}	{{8R}	{SA}}	
	{Haiti}	{{HH}	{NA}}	
	{Hawaii}	{{KH6-7, AH6-7, NH6-7, WH6-7}	{OC}}	
	{Heard Island}	{{VK0}	{AF}}	
	{Honduras}	{{HQ, HR}	{NA}}	
	{Hong Kong}	{{VR}	{AS}}	
	{Hungary}	{{HA, HG}	{EU}}	
	{Iceland}	{{TF}	{EU}}	
	{India}	{{VU, AT}	{AS}}	
	{Indonesia}	{{YB-YH, 8A-8I}	{OC}}	
	{Iran}	{{EP-EZ, 9B-9D}	{AS}}	
	{Iraq}	{{YI}	{AS}}	
	{Ireland}	{{EI, EJ}	{EU}}	
	{Isle of Man}	{{GD, GT, MD, 2D}	{EU}}	
	{Israel}	{{4X, 4Z}	{AS}}	
	{Italy}	{{I}	{EU}}	
	{ITU HQ}	{{4U_ITU}	{EU}}	
	{Jamaica}	{{6Y}	{NA}}	
	{Jan Mayen}	{{JX}	{EU}}	
	{Japan}	{{JA-JS, 7JA-7NZ, 8JA-8NZ}	{AS}}	
	{Jersey}	{{GJ, GH, MJ, 2J}	{EU}}	
	{Johnston Island}	{{KH3, K3J, AH3, NH3, WH3}	{OC}}	
	{Jordan}	{{JY}	{AS}}	
	{Juan de Nova, Europa}	{{FR/J, FR/E, TO4}	{AF}}	
	{Juan Fernandez Island}	{{CE0}	{SA}}	
	{Kaliningrad}	{{UA2-UI2, RA2-RZ2}	{EU}}	
	{Kazakhstan}	{{UN-UQ}	{AS}}	
	{Kenya}	{{5Y, 5Z}	{AF}}	
	{Kerguelen Island}	{{FT5X}	{AF}}	
	{Kermadec Island}	{{ZL8}	{OC}}	
	{Kingman Reef}	{{KH5K, AH2, NH2, WH2}	{OC}}	
	{Kure Island}	{{KH7K,K7C,K7K,AH7K,NH7K,WH7K}	{OC}}	
	{Kuwait}	{{9K}	{AS}}	
	{Kyrgyzstan}	{{EX}	{AS}}	
	{Lakshadweep Island}	{{VU7}	{AS}}	
	{Laos}	{{XW}	{AS}}	
	{Latvia}	{{YL}	{EU}}	
	{Lebanon}	{{OD}	{AS}}	
	{Lesotho}	{{7P}	{AF}}	
	{Liberia}	{{EL, A8, D5, 5L, 5M, 6Z}	{AF}}	
	{Libya}	{{5A}	{AF}}	
	{Liechtenstein}	{{HB0}	{EU}}	
	{Lithuania}	{{LY}	{EU}}	
	{Lord Howe lsland}	{{VK9L}	{OC}}	
	{Luxembourg}	{{LX}	{EU}}	
	{Macao}	{{XX9}	{AS}}	
	{Macedonia}	{{Z3}	{EU}}	
	{Macquarie Island}	{{VK0}	{OC}}	
	{Madagascar}	{{5R, 5S, 6X}	{AF}}	
	{Madeira Island}	{{CT3, XX3. 3, 9}	{AF}}	
	{Malawi}	{{7Q}	{AF}}	
	{Maldives}	{{8Q}	{AS}},AF	
	{Mali}	{{TZ}	{AF}}	
	{Malpelo Island}	{{HK0/M}	{SA}}	
	{Malta}	{{9H}	{EU}}	
	{Malyj Vysotskij Island}	{{R1MV}	{EU}}	
	{Mariana Island}	{{KH0, AH0, NH0, WH0}	{OC}}	
	{Market Reef}	{{OJ0,OH0M}	{EU}}	
	{Marquesas Island}	{{FO}	{OC}}	
	{Marshall Island}	{{V7}	{OC}}	
	{Martinique}	{{FM, TO}	{NA}}	
	{Mauritania}	{{5T}	{AF}}	
	{Mauritius}	{{3B8}	{AF}}	
	{Mayotte}	{{FH}	{AF}}	
	{Mellish Reef}	{{VK9M}	{OC}}	
	{Mexico}	{{XA-XI, 4A-4C, 6D-6J}	{NA}}	
	{Micronesia}	{{V6}	{OC}}	
	{Midway Island}	{{KH4, AH4, NH4, WH4}	{OC}}	
	{Minami Torishima}	{{JD1}	{OC}}	
	{Moldova}	{{ER}	{EU}}	
	{Monaco}	{{3A}	{EU}}	
	{Mongolia}	{{JT, JU, JV}	{AS}}	
	{Montenegro}	{{4O}	{EU}}	
	{Montserrat}	{{VP2M}	{NA}}	
	{Morocco}	{{CN}	{AF}}	
	{Mount Athos}	{{SV/A}	{EU}}	
	{Mozambique}	{{C8-9}	{AF}}	
	{Myanmar}	{{XY-XZ}	{AS}}	
	{Namibia}	{{V5}	{AF}}	
	{Nauru}	{{C2}	{OC}}	
	{Navassa Island}	{{KP1, NP1, WP1}	{NA}}	
	{Nepal}	{{9N}	{AS}}	
	{Netherlands}	{{PA-PI}	{EU}}	
	{New Caledonia}	{{FK}	{OC}}	
	{New Zealand}	{{ZL-ZM}	{OC}}	
	{Nicaragua}	{{YN, HT, H6, H7}	{NA}}	
	{Niger}	{{5U}	{AF}}	
	{Nigeria}	{{5N, 5O}	{AF}}	
	{Niue}	{{ZK2}	{OC}}	
	{Norfolk Island}	{{VK9N}	{OC}}	
	{North Cook Islands}	{{E5 (ZK1)}	{OC}}	
	{Northern Ireland}	{{GI, GN, MI, 2I}	{EU}}	
	{Norway}	{{LA-LN}	{EU}}	
	{Ogasawara}	{{JD1}	{AS}}	
	{Oman}	{{A4}	{AS}}	
	{Pakistan}	{{AP-AS, 6P-6S}	{AS}}	
	{Palau}	{{T8 (KC6)}	{OC}}	
	{Palestine}	{{E4}	{AS}}	
	{Palmyra & Jarvis Island}	{{KH5, K5K, AH2, NH2, WH2}	{OC}}	
	{Panama}	{{HO, HP, H3, 3E, 3F, H8, H9}	{NA}}	
	{Papua New Guinea}	{{P2}	{OC}}	
	{Paraguay}	{{ZP}	{SA}}	
	{Peru}	{{OA-OC, 4T}	{SA}}	
	{Peter I. Island}	{{3Y}	{AN}}	
	{Philippines}	{{DU-DZ, 4D-4I}	{OC}}	
	{Pitcairn Island}	{{VP6}	{OC}}	
	{Poland}	{{SN-SR, HF, 3Z}	{EU}}	
	{Portugal}	{{CT, CQ, CS. 1, 2, 4, 5, 6, 7}	{EU}}	
	{Pratas Island}	{{BV9P}	{AS}}	
	{Prince Edward & Marion Is.}	{{ZS8}	{AF}}	
	{Puerto Rico}	{{KP3, NP3, WP3, KP4, NP4, WP4}	{NA}}	
	{Qatar}	{{A7}	{AS}}	
	{Republic of Korea}	{{HL, DS, DT, D7, 6K}	{AS}}	
	{Reunion Island}	{{FR}	{AF}}	
	{Revillagigedo}	{{XA4-XI4}	{NA}}	
	{Rodrigues Island}	{{3B9}	{AF}}	
	{Romania}	{{YO-YR}	{EU}}	
	{Rotuma Island}	{{3D2/R}	{OC}}	
	{Rwanda}	{{9X}	{AF}}	
	{Sable Island}	{{CY0}	{NA}}	
	{Samoa}	{{5W}	{OC}}	
	{San Andres & Providencia}	{{HK0, HJ0}	{NA}}	
	{San Felix & San Ambrosio}	{{CE0}	{SA}}	
	{San Marino}	{{T7}	{EU}}	
	{Sao Tome & Principe}	{{S9}	{AF}}	
	{Sardinia}	{{IS0, IM0}	{EU}}	
	{Saudi Arabia}	{{HZ, 7Z, 8Z}	{AS}}	
	{Scarborough Reef}	{{BS7}	{AS}}	
	{Scotland}	{{GM,GS, MM, 2M}	{EU}}	
	{Senegal}	{{6V, 6W}	{AF}}	
	{Serbia}	{{YT-YU}	{EU}}	
	{Seychelles}	{{S7}	{AF}}	
	{Sierra Leone}	{{9L}	{AF}}	
	{Singapore}	{{9V, S6}	{AS}}	
	{Slovak Republic}	{{OM}	{EU}}	
	{Slovenia}	{{S5}	{EU}}	
	{Solomon Islands}	{{H4}	{OC}}	
	{Somalia}	{{T5, 6O}	{AF}}	
	{South Africa}	{{ZR-ZU, S8}	{AF}}	
	{South Cook Islands}	{{E5 (ZK1)}	{OC}}	
	{South Georgia Island}	{{VP8, LU}	{SA}}	
	{South Orkney Island}	{{VP8, LU}	{SA}}	
	{South Sandwich Island}	{{VP8, LU}	{SA}}	
	{South Shetland Island}	{{VP8, CE9, CX0, HF0, 4K1, LZ0, D88}	{SA}}	
	{Sov. Mil. Order of Malta}	{{1A0}	{EU}}	
	{Spain}	{{EA-EH, AM}	{EU}}	
	{Spratly Islands}	{{9M, BV, DX}	{AS}}	
	{Sri Lanka}	{{4P-4S}	{AS}}	
	{St. Barthelmy Island.}	{{FJ}	{NA}}	
	{St. Helena}	{{ZD7}	{AF}}	
	{St. Kitts & Nevis}	{{V4}	{NA}}	
	{St. Lucia}	{{J6}	{NA}}	
	{St. Maarten, Saba, St. Eustatius}	{{PJ5-8}	{NA}}	
	{St. Martin}	{{FS}	{NA}}	
	{St. Paul Island}	{{CY9}	{NA}}	
	{St. Peter & St. Paul Rocks}	{{PP0-PY0S}	{SA}}	
	{St. Pierre & Miquelon}	{{FP}	{NA}}	
	{St. Vincent}	{{J8}	{NA}}	
	{Sudan}	{{ST}	{AF}}	
	{Suriname}	{{PZ}	{SA}}	
	{Svalbard}	{{JW}	{EU}}	
	{Swain's Island}	{{KH8SI, AH8SI, NH8SI, WH8SI}	{OC}}	
	{Swaziland}	{{3DA}	{AF}}	
	{Sweden}	{{SA-SM}	{EU}}	
	{Switzerland}	{{HB, HE}	{EU}}	
	{Syria}	{{YK, 6C}	{AS}}	
	{Taiwan}	{{BV, BM-BQ, BU-BX}	{AS}}	
	{Tajikistan}	{{EY}	{AS}}	
	{Tanzania}	{{5H, 5I}	{AF}}	
	{Temotu Province}	{{H40}	{OC}}	
	{Thailand}	{{HS-E2}	{AS}}	
	{The Gambia}	{{C5}	{AF}}	
	{Timor-Leste}	{{4W}	{OC}}	
	{Togo}	{{5V}	{AF}}	
	{Tokelau Island}	{{ZK3}	{OC}}	
	{Tonga}	{{A3}	{OC}}	
	{Trindade & Martim Vaz Is.}	{{PP0-PY0T}	{SA}}	
	{Trinidad & Tobago}	{{9Y, 9Z}	{SA}}	
	{Tristan da Cunha & Gough Is.}	{{ZD9}	{AF}}	
	{Tromelin Island}	{{FR/T}	{AF}}	
	{Tunisia}	{{3V, TS}	{AF}}	
	{Turkey}	{{TA-TC}	{EU}},AS	
	{Turkmenistan}	{{EZ}	{AS}}	
	{Turks & Caicos Island}	{{VP5}	{NA}}	
	{Tuvalu}	{{T2}	{OC}}	
	{Uganda}	{{5X}	{AF}}	
	{UK Sov Base Areas on Cyprus}	{{ZC4}	{AS}}	
	{Ukraine}	{{UR-UT, UU-UZ, EM-EO}	{EU}}	
	{United Arab Emirates}	{{A6}	{AS}}	
	{United Nations HQ}	{{4U_UN}	{NA}}	
	{United States of America}	{{K, N, W, AA-AK}	{NA}}	
	{Uruguay}	{{CV-CX}	{SA}}	
	{Uzbekistan}	{{UJ-UM}	{AS}}	
	{Vanuatu}	{{YJ}	{OC}}	
	{Vatican}	{{HV}	{EU}}	
	{Venezuela}	{{YV-YY, 4M}	{SA}}	
	{Vietnam}	{{3W, XV}	{AS}}	
	{Virgin Island}	{{KP2, NP2, WP2}	{NA}}	
	{Wake Island}	{{KH9, AH9, NH9, WH9}	{OC}}	
	{Wales}	{{GW, GC, MW, 2W,}	{EU}}	
	{Wallis & Futuna Island}	{{FW}	{OC}}	
	{West Kiribati (Gilbert Is.)}	{{T30}	{OC}}	
	{West Malaysia}	{{9M2-9M4}	{AS}}	
	{Western Sahara}	{{S0}	{AF}}	
	{Willis Island}	{{VK9W}	{OC}}	
	{Yemen}	{{7O}	{AS}}	
	{Zambia}	{{9I, 9J}	{AF}}	
	{Zimbabwe}	{{Z2}	{AF}}	
    }

    words {
	QRL QRM QRN QRS QRT QRZ QSB QSL QSO QSY QTH QRX
	/ 73 88 ?
	ABT ADR AGE AGN ANT BEAM BK BN
	C CL CPY CQ CUL DE DSW DX
	EL ES FB GA GB GE GM GN GND GUD
	HI HR HV HW
	K
	LID LOOP
	N NAME NR NW
	OM OP 
	PKT PSE PWR
	R RCVR RIG RPT RST
	SAN SK SRI SSB
	TEMP TEST TKS TMW TNX TU
	UR
	VERT VY
	WATT WX 
	XYL
	YAGI YL YRS
    }

    all-letters {
	 "\"" "\b" {!} {$} {%} {'} {(} {)} {*} {+} {,} {-} {.} {/} 
	{0} {1} {2} {3} {4} {5} {6} {7} {8} {9}
	{:} {;} {=} {?} {@}
	{A} {B} {C} {D} {E} {F} {G} {H} {I} {J} {K} {L} {M} {N} {O} {P} {Q} {R} {S} {T} {U} {V} {W} {X} {Y} {Z}
	{_}
    }

    game-play-letters {
	{+} {,} {-} {.} {/}
	{0} {1} {2} {3} {4} {5} {6} {7} {8} {9}
	{=} {?}
	{A} {B} {C} {D} {E} {F} {G} {H} {I} {J} {K} {L} {M} {N} {O} {P} {Q} {R} {S} {T} {U} {V} {W} {X} {Y} {Z}
    }
    game-play-max-interval 5000
    game-play-level 14
    play 0
}

#
# morse code table
# . indicates key down, space indicates key up
# there is no key transition between adjacent
# dots or spaces.
# A space extends the end of letter off by two.
# The end of letter space is added by code-get
#
array set code {
    \b {. . . . . . . .}
    { } {  }
    {!} {. . . ... .}
    \" {. ... . . ... .}
    {$} {. . . ... . . ...}
    {%} {. ... . . .} 
    {'} {. ... ... ... ... .}
    {(} {... . ... ... .}
    {)} {... . ... ... . ...}
    {*} {. . . ... . ...}
    {+} {. ... . ... .}
    {,} {... ... . . ... ...}
    {-} {... . . . . ...}
    {.} {. ... . ... . ...}
    {/} {... . . ... .}
    {0} {... ... ... ... ...}
    {1} {. ... ... ... ...}
    {2} {. . ... ... ...}
    {3} {. . . ... ...}
    {4} {. . . . ...}
    {5} {. . . . .}
    {6} {... . . . .}
    {7} {... ... . . .}
    {8} {... ... ... . .}
    {9} {... ... ... ... .}
    {:} {... ... ... . . .}
    {;} {... . ... . ... .}
    {=} {... . . . ...}
    {?} {. . ... ... . .}
    {@} {. ... ... . ... .}
    {A} {. ...}
    {B} {... . . .}
    {C} {... . ... .}
    {D} {... . .}
    {E} {.}
    {F} {. . ... .}
    {G} {... ... .}
    {H} {. . . .}
    {I} {. .}
    {J} {. ... ... ...}
    {K} {... . ...}
    {L} {. ... . .}
    {M} {... ...}
    {N} {... .}
    {O} {... ... ...}
    {P} {. ... ... .}
    {Q} {... ... . ...}
    {R} {. ... .}
    {S} {. . .}
    {T} {...}
    {U} {. . ...}
    {V} {. . . ...}
    {W} {. ... ...}
    {X} {... . . ...}
    {Y} {... . ... ...}
    {Z} {... ... . .}
    {_} {. . ... ... . ...}
    {a} {. ...}
    {b} {... . . .}
    {c} {... . ... .}
    {d} {... . .}
    {e} {.}
    {f} {. . ... .}
    {g} {... ... .}
    {h} {. . . .}
    {i} {. .}
    {j} {. ... ... ...}
    {k} {... . ...}
    {l} {. ... . .}
    {m} {... ...}
    {n} {... .}
    {o} {... ... ...}
    {p} {. ... ... .}
    {q} {... ... . ...}
    {r} {. ... .}
    {s} {. . .}
    {t} {...}
    {u} {. . ...}
    {v} {. . . ...}
    {w} {. ... ...}
    {x} {... . . ...}
    {y} {... . ... ...}
    {z} {... ... . .}
    {À} {. ... ... . ...}
    {Á} {. ... ... . ...}
    {Â} {. ... ... . ...}
    {Ä} {. ... . ...}
    {Ç} {... ... ... ...}
    {È} {. . ... . .}
    {É} {. . ... . .}
    {Ñ} {... ... . ... ...}
    {Ö} {... ... ... .}
    {Ü} {. . ... ...}
    {à} {. ... ... . ...}
    {á} {. ... ... . ...}
    {â} {. ... ... . ...}
    {ä} {. ... . ...}
    {ç} {... ... ... ...}
    {è} {. . ... . .}
    {é} {. . ... . .}
    {ñ} {... ... . ... ...}
    {ö} {... ... ... .}
    {ü} {. . ... ...}
}

#
# read an code string out of the code elements
# pass multiple characters as individual arguments
# to concatenate their codes
#
proc code-get {args} {
    global code
    set result {}
    foreach c $args {
	append result $code($c)
    }
    return "$result   "
}
	
#
# initialize the code lengths
#
proc code-init {} {
    global data
    global code
    foreach c [array names code] {
	set length($c) [string length [code-get $c]]
    }
    set data(game-play-letter-lengths) [array get length]
}

#
# play some text
#
proc play-text {text} {
    global data
    plug-puts-text ascii $text
}

#
# clear whatever might be displayed
#
proc clear-screen {} {
    .c delete all
    update idletasks
}

#
# draw the morse code for the text in the specified color
#
proc draw-text {text color} {
    global data
    set x 0
    set s { }
    foreach c [split $text {}] {
	foreach d [split [code-get $c] {}] {
	    if {$d ne $s} {
		set s $d
		lappend ys $x
	    }
	    incr x
	}
    }
    #puts $ys
    set w [winfo width .c]
    set h [winfo height .c]
    foreach {x1 x2} $ys {
	.c create rectangle $x1 1 $x2 0 -fill $color -outline $color
    }
    .c scale all 0 0 10 10
    .c move all 10 [expr {$h/2}]
    update idletasks
}

#
# display the text in the specified color
#
proc show-text {text color} {
    #puts "show-text $text"
    if {$text eq "\b"} { set text "\\b" }
    set text [string tolower $text]
    foreach {x1 y1 x2 y2} [.c bbox all] break
    .c create text [expr {$x2+40}] [expr {($y1+$y2)/2}] -text $text -fill $color -font {Times 20}
    update idletasks
}

#
# pick a text from the supplied list
#
proc pick-one-of {list} {
    return [lindex $list [expr {int([llength $list]*rand())}]]
}

#
# load the cumulative game score from disk
#
proc game-score-load {} {
    global score
    global data
    if { ! [file exists $data(score-file)]} {
	set fp [open $data(score-file) w]
	close $fp
	array set score {}
    } else {
	set fp [open $data(score-file) r]
	array set score [read $fp]
	close $fp
    }
    # game-score-summarize
}

#
# write the cumulative game score to disk
#
proc game-score-save {} {
    global score
    global data
    set fp [open $data(score-file) w]
    puts $fp [array get score]
    close $fp
}

#
# summarize the game score
#
proc game-score-summarize {} {
    global score
    foreach {name value} [array get score] {
	puts " {$name} {$value}"
    }
}

#
# score a play in the game
#
proc game-score {text result} {
    global score
    foreach c [split $text {}] {
	if {$c eq "\b"} {
	    append newtext "\\b"
	} else {
	    append newtext $c
	}
    }
    lappend score($newtext) $result
}

#
# form the game texts which fit into $n dot clocks.
# take all combinations of letters that are shorter
# or equal to $n.
#
proc game-texts {n} {
    global data
    # get the dot lengths of the base letter set
    array set length $data(game-play-letter-lengths)
    # prune to the letter set and to the chosen length
    # form the base set of texts
    foreach c [array names length] {
	if {[lsearch $data(game-play-letters) $c] < 0 || $length($c) > $n} {
	    unset length($c)
	} else {
	    lappend texts $c
	}
    }
    # iteratively accumulate new texts
    set ntexts [llength $texts]
    while {1} {
	foreach c [array names length] {
	    foreach t $texts {
		if {[lsearch $texts $c$t] < 0} {
		    set lct $length($c)
		    incr lct $length($t)
		    if {$lct <= $n} {
			set length($c$t) $lct
			lappend texts $c$t
		    }
		}
	    }
	}
	if {[llength $texts] == $ntexts} break
	set ntexts [llength $texts]
    }
    return $texts
}

array set inputmap {
    Delete "\b"
    space " "
    Tab "  "
    Return " "
    BackSpace "\b"
    Control_L -1
    Shift_L -1
    Alt_L -1
    Control_R -1
    Shift_R -1
    Alt_R -1
    apostrophe "'"
    colon ":"
    comma ","
    dollar {$}
    equal {=}
    minus "-"
    parenleft "("
    parenright ")"
    period "."
    plus "+"
    question "?"
    quotedbl \"
    semicolon ";"
    slash "/"
    underscore "_"
    a a b b c c d d e e f f g g h h i i j j k k l l m m n n o o p p q q r r s s t t u u v v w w x x y y z z
    A a B b C c D d E e F f G g H h I i J j K k L l M m N n O o P p Q q R r S s T t U u V v W w X x Y y Z z
    0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
}

#
#
#
proc game-player-answer {c} {
    global data
    global inputmap
    if {[info exists inputmap($c)]} {
	set d $inputmap($c)
    } else {
	puts "untranslated game-player-answer $c"
	set d $c
    }
    if {$d == -1} return
    if {$data(play) == 0} {
	play-text $d
	return
    }
    append data(game-response-text) $c
    # does not match
    while {[string first $data(game-response-text) $data(game-play-text)] != 0} {
	# score first letter as a confusion
	game-score $data(game-play-text) [list confused [string index $data(game-response-text) 0]]
	# toss the first letter
	set data(game-response-text) [string range $data(game-response-text) 1 end]
	# exit if nothing left
	if {$data(game-response-text) eq {}} { return }
    }
    # too short to match
    if {[string length $data(game-response-text)] < [string length $data(game-play-text)]} {
	return
    }
    # exact match
    if {$data(game-response-text) eq $data(game-play-text)} {
	catch {after cancel $data(game-play-after)}
	game-score $data(game-play-text) answered
	set data(game-next) game-next-text
	clear-screen
	draw-text $data(game-play-text) black
	show-text $data(game-play-text) black
	set data(game-play-after) [after 1000 game-next]
	set data(game-response-text) {}
	return
    }
    game-score $data(game-play-text) [list confused $data(game-response-text)]
    set data(game-response-text) {}
}

#
#
#
proc game-next {} {
    global data
    if {$data(play)} {
	$data(game-next)
	set data(game-play-after) [after 5000 game-next]
    }
}

#
#
#
proc game-next-text {} {
    global data
    set data(game-play-text) [string tolower [pick-one-of $data(game-play-texts)]]
    set data(game-response-text) {}
    game-score $data(game-play-text) try
    # puts "game-next-text picked {$data(game-play-text)}"
    set data(game-play-interval) $data(game-play-max-interval)
    clear-screen
    play-text $data(game-play-text)
    set data(game-next) game-replay-text-1
}

#
#
#
proc game-replay-text-1 {} {
    global data
    # puts "game-replay-text"
    game-score $data(game-play-text) missed-once
    clear-screen
    play-text $data(game-play-text)
    draw-text $data(game-play-text) black
    set data(game-next) game-replay-text-2
}

#
#
#
proc game-replay-text-2 {} {
    global data
    # puts "game-replay-text"
    game-score $data(game-play-text) missed-twice
    clear-screen
    play-text $data(game-play-text)
    draw-text $data(game-play-text) red
    show-text $data(game-play-text) red
    set data(game-next) game-next-text
}

#
#
#
proc game-play-start {} {
    global data
    if {$data(play)} {
	# start-sound
	set data(game-next) game-next-text
	after 500 game-next
    } else {
	# stop-sound
	clear-screen
    }
}

#
#
#
proc game-play-level-change {level} {
    global data
    switch -regexp $level {
	{^\d+$} {
	    set data(game-play-texts) [game-texts $level]
	}
	{^words$} {
	    set data(game-play-texts) $data(words)
	}
	default {
	    set data(game-play-texts) {}
	    foreach i [split $level {}] {
		lappend data(game-play-texts) $i
		foreach j [split $level {}] {
		    lappend data(game-play-texts) $i$j
		}
	    }
	}
    }
}

#
# update a variable and send it's value onward
#
proc ui-plug-puts {client opt scale value} {
    global data
    if {$scale == 1} {
	set value $value
    } elseif {$scale == 10} {
	set value [format %.1f [expr {double($value)/double($scale)}]]
    } elseif {$scale == 100} {
	set value [format %.2f [expr {double($value)/double($scale)}]]
    } elseif {$scale == 1000} {
	set value [format %.3f [expr {double($value)/double($scale)}]]
    }
    set data($client-$opt-display) $value
    plug-puts $client $opt $value
}

#
# generic control panel row
#
proc ui-panel-row {w client row opt label from to units} {
    global data
    grid [ttk::label $w-o -text $opt] -row $row -column 0 -sticky w
    grid [ttk::label $w-l -text $label] -row $row -column 1
    if {[llength $from] > 1} {
	grid [ttk::frame $w-s] -row $row -column 2 -sticky w
	foreach x $from {
	    pack [ttk::radiobutton $w-s.x$x -text $x -variable data($client-$opt) -value $x -command [list plug-puts $client $opt $x]] -side left -anchor w
	}
    } else {
	set scale 1
	switch -regexp $from {
	    {^-?\d+$} { set scale 1 }
	    {^-?\d+.\d$} { set scale 10 }
	    {^-?\d+.\d\d$} { set scale 100 }
	}
	grid [ttk::scale $w-s -orient horizontal -from [expr {$from*$scale}] -to [expr {$to*$scale}] -length 250 \
		  -variable data($client-$opt-scale) -command [list ui-plug-puts $client $opt $scale]] -row $row -column 2 -sticky ew
	set data($client-$opt-scale) [expr {$data($client-$opt)*$scale}]
	ui-plug-puts $client $opt $scale $data($client-$opt-scale)
	grid [ttk::label $w-v -textvar data($client-$opt-display)] -row $row -column 3 -sticky e
	if {$units ne {}} {
	    grid [ttk::label $w-u -text $units] -row $row -column 4 -sticky w
	}
    }
}

#
# game panel user interface
#
proc ui-game-panel {w} {
    ttk::frame $w
    pack [canvas $w.c -width 800 -height 100] -side top -fill both -expand true
    pack [ttk::frame $w.m] -side bottom -fill x
    pack [ttk::menubutton $w.m.playlevel -text Level -menu .m.playlevel.m] -side left
    menu .m.playlevel.m -tearoff no
    foreach i {EISH5 TMO0 AWJ1 NDB6 AUV4 12 14 16 18 20 words} {
	.m.playlevel.m add radiobutton -label $i -variable data(play-level) -value $i -command [list game-play-level-change $i]
    }
    pack [ttk::radiobutton $w.m.start -text Start -variable data(play) -command [list game-play-start]] -side left
    pack [ttk::radiobutton $w.m.stop -text Stop -variable data(play) -command [list game-play-start]] -side left
    return $w
}

#
# ascii configure panel
#
proc ui-ascii-frame {w client row} {
    foreach {opt label from to units} {
	wpm {words / minute} 5.0 60.0 {}
	word {word length} 40 70 dits
	dah {dah length} 2.5 3.5 dits
	ies {inter-element length} 0.5 1.5 dits
	ils {inter-letter length} 2.5 3.5 dits
	iws {inter-word length} 5 20 dits
    } {
	ui-panel-row $w.$client-$opt $client $row $opt $label $from $to $units
	incr row
    }
    return $row
}

#
# iambic configure panel
#
proc ui-iambic-frame {w client row} {
    foreach {opt label from to units} {
	wpm {words / minute} 5.0 60.0 {}
	word {word length} 40 70 dits
	dah {dah length} 2.5 3.5 dits
	ies {inter-element length} 0.5 1.5 dits
	ils {inter-letter length} 2.5 3.5 dits
	iws {inter-word length} 5 50 dits
	swap {swap paddles} {0 1} {} {}
	alsp {auto-letter space} {0 1} {} {}
	awsp {auto-word space} {0 1} {} {}
	mode {iambic mode} {A B} {} {}
    } {
	ui-panel-row $w.$client-$opt $client $row $opt $label $from $to $units
	incr row
    }
    return $row
}

#
# tone panel configure
#
proc ui-tone-frame {w client row} {
    foreach {opt label from to units} {
	freq {tone frequency} 300.0 1000.0 Hz
	gain {tone volume} -40.0 0.0 dB
	rise {key rise time} 0.1 50.0 ms
	fall {key fall time} 0.1 50.0 ms
    } {
	ui-panel-row $w.$client-$opt $client $row $opt $label $from $to $units
	incr row
    }
    return $row
}

#
# mouse paddle configure panel
#
proc ui-mouse-panel {w} {
    ttk::frame $w
    return $w
}

#
# save the score file and close the window
#
proc ui-close {w} {
    global data
    global score
    if {"$w" eq "."} {
	plug-close-all
	game-score-save
	destroy .
    }
}

proc ui-input {k} {
    game-player-answer $k
}
#
# build a user interface
#
proc ui-init {} {
    pack [ttk::notebook .nb] -fill both -expand true
    .nb add [ttk::frame .nb.ctl] -text Controls
    set row 0
    grid [label .nb.ctl.ascii -text {Ascii Keyer}] -row $row -column 0 -columnspan 5 -sticky w
    set row [ui-tone-frame .nb.ctl ascii_tone [incr row]]
    set row [ui-ascii-frame .nb.ctl ascii [incr row]]
    grid [label .nb.ctl.iambic -text {Iambic Keyer}] -row $row -column 0 -columnspan 5 -sticky w
    set row [ui-tone-frame .nb.ctl iambic_tone [incr row]]
    set row [ui-iambic-frame .nb.ctl iambic [incr row]]

    if {0} {
	pack [ttk::menubutton .m.text -text Text -menu .m.text.m] -side left
	menu .m.text.m -tearoff no
	global data
	foreach t [list \
		       "the quick brown fox jumps over the lazy dog" \
		       "abcdefghijklmnopqrstuvwxyz0123456789" \
		       [join $data(all-letters) { }] \
		      ] {
	    .m.text.m add command -label "[string range $t 0 10] ..." -command [list play-text $t]
	}
    }
    bind . <Destroy> [list ui-close %W]
    bind . <KeyPress> [list ui-input %K]
}

#
#
#
proc main {argv} {
    global data
    global env

    plug-init
    ui-init
    code-init

    set data(score-file) $env(HOME)/.play-morse-score-file
    foreach {opt value} $argv {
	switch -- $opt {
	    --ascii-freq { set data(ascii_tone-freq) $value }
	    --ascii-wpm { set data(ascii-wpm) $value }
	    --ascii-gain { set data(ascii_tone-gain) $value }
	    --iambic-freq { set data(iambic_tone-freq) $value }
	    --iambic-wpm { set data(iambic-wpm) $value }
	    --iambic-gain { set data(iambic_tone-gain) $value }
	    --score { set data(score-file) $value }
	    --level { set data(game-play-level) $value }
	    default {
		error "unknown option $opt"
	    }
	}
    }

    plug-puts ascii_tone freq $data(ascii_tone-freq)
    plug-puts ascii_tone gain $data(ascii_tone-gain)
    plug-puts iambic_tone freq $data(iambic_tone-freq)
    plug-puts iambic_tone gain $data(iambic_tone-gain)
    plug-puts ascii wpm $data(ascii-wpm)
    plug-puts iambic wpm $data(iambic-wpm)
    game-score-load
    game-play-level-change $data(game-play-level)
}

main $argv