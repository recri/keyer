#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

package require Tk
package require keyer::ascii
package require keyer::tone
package require sdrkit::jack
package require keyer-control

#
# default option set
#

array set opts {
    ascii 1
    iambic 1

    ascii-verbose 0
    ascii-chan 1
    ascii-note 0
    ascii-wpm 15
    ascii-word 50
    ascii-dah 3
    ascii-ies 1
    ascii-ils 3
    ascii-iws 7

    ascii_tone-verbose 0
    ascii_tone-freq 700
    ascii_tone-gain -30
    ascii_tone-rise 5
    ascii_tone-fall 5

    iambic-verbose 0
    iambic-chan 1
    iambic-note 0
    iambic-wpm 15
    iambic-word 50
    iambic-dah 3
    iambic-ies 1
    iambic-ils 3
    iambic-iws 7
    iambic-mode A
    iambic-alsp 0
    iambic-awsp 0
    iambic-swap 0

    iambic_tone-verbose 0
    iambic_tone-freq 750
    iambic_tone-gain -30
    iambic_tone-rise 5
    iambic_tone-fall 5
}

#
# get the options for the specified client
# and turn them into option names the client
# will understand.
#
proc client-opts {client} {
    global opts
    foreach name [array names opts $client-*] {
	set val $opts($name)
	set name [string range $name [expr {1+[string length $client]}] end]
	lappend args "-$name" $val
    }
    return $args
}

proc message {msg} {
    puts $msg
}

#
# initialize the clients
#
proc client-init {} {
    global opts

    # start jack?

    # look for zombies
    set ports [sdrkit::jack list-ports]
    foreach port [dict keys $ports] {
	foreach conn [dict get $ports $port connections] {
	    switch -glob $conn {
		ascii:* -
		iambic:* -
		ascii_tone:* -
		iambic_tone:* {
		    error "the [lindex [split $line :] 0] client is still running"
		}
	    }
	}
	switch -glob $port {
	    system:midi_capture_* {
		set midi_capture $port
	    }
	}
    }
    # make helpers
    set clients {}
    set connects {}
    # make the ascii keyer
    if {$opts(ascii)} {
        keyer::ascii ascii {*}[client-opts ascii]
	lappend clients ascii
	keyer::tone ascii_tone {*}[client-opts ascii_tone]
	lappend clients ascii_tone
	lappend connects {sdrkit::jack connect ascii:midi_out ascii_tone:midi_in}
	lappend connects {sdrkit::jack connect ascii_tone:out_i system:playback_1}
	lappend connects {sdrkit::jack connect ascii_tone:out_q system:playback_2}
    } else {
	lappend clients {} {}
    }
    # make the iambic keyer
    if {$opts(iambic)} {
	# plug-open keyer::iambic iambic
	keyer::iambic iambic {*}[client-opts iambic]
	lappend clients iambic
	keyer::tone iambic_tone {*}[client-opts iambic_tone]
	lappend clients iambic_tone
	if { ! [info exists midi_capture]} {
	    message "no midi_capture port for keyer connection"
	} else {
	    lappend connects [list sdrkit::jack connect $midi_capture iambic:midi_in]
	}
	lappend connects {sdrkit::jack connect iambic:midi_out iambic_tone:midi_in}
	lappend connects {sdrkit::jack connect iambic_tone:out_i system:playback_1}
	lappend connects {sdrkit::jack connect iambic_tone:out_q system:playback_2}
    } else {
	lappend clients {} {}
    }
    # make the connections
    foreach cmd $connects {
	if {[catch "eval $cmd" error]} {
	    puts "$cmd: yielded $error"
	}
    }
    return $clients
}

#
# process options
#
proc main {argv} {
    global opts

    foreach {opt value} $argv {
	if {[info exists opts([string range $opt 2 end])]} {
	    set opts([string range $opt 2 end]) $value
	} elseif  {[info exists opts([string range $opt 1 end])]} {
	    set opts([string range $opt 1 end]) $value 
	} else {
	    error "unknown option: \"$opt\""
	}
    }
    if {$opts(ascii) || $opts(iambic)} {
	keyer-control .ctl {*}[client-init] [array get opts]
	bind . <Destroy> [list ui-close %W]
	if {$opts(ascii)} {
	    bind . <KeyPress> [list ascii puts %A]
	}
    } else {
	error "no keyers to control"
    }
}

main $argv
