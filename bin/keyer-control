#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-

lappend auto_path [file join [file dirname [info script]] .. lib]

package require Tk

#package require sdrkit
#package require midiscope

##
## parameters and operating data
##
array set data {
    ascii 1
    iambic 1
    

    ascii_tone-freq 700
    ascii_tone-gain -30
    ascii_tone-rise 5
    ascii_tone-fall 5

    ascii-wpm 15
    ascii-word 50
    ascii-dah 3
    ascii-ies 1
    ascii-ils 3
    ascii-iws 7

    ascii-chan 1
    ascii-note 0

    iambic_tone-freq 750
    iambic_tone-gain -30
    iambic_tone-rise 5
    iambic_tone-fall 5

    iambic-wpm 15
    iambic-word 50
    iambic-dah 3
    iambic-ies 1
    iambic-ils 3
    iambic-iws 7
    iambic-mode A
    iambic-alsp 0
    iambic-awsp 0
    iambic-swap 0

    iambic-chan 1
    iambic-note 0
}

##
## plugin management
##
proc plug-exists {client} {
    global plug
    return [info exists plug($client-fp)]
}

proc plug-open {program client {server default}} {
    global plug
    global data
    set bindir [file dirname [info script]]
    set plug($client-binary) [file join $bindir $program]
    # test for file exists
    set plug($client-out-file) "/tmp/keyer-control-[pid]-$client.out"
    set args [list |$plug($client-binary) --server $server --client $client]
    foreach name [array names data $client-*] {
	set val $data($name)
	set name [string range $name [expr {1+[string length $client]}] end]
	lappend args "--$name" $val
    }
    lappend args {>&} $plug($client-out-file)
    set command [join $args]
    set plug($client-fp) [open $command w]
    fconfigure $plug($client-fp) -buffering line
    set plug($client-out-fp) [open "$plug($client-out-file)" r]
    fconfigure $plug($client-out-fp) -blocking 0 -buffering line
    # fileevent $plug($client-out-fp) readable "plug-readable $client"
    lappend plug(clients) $client
}

proc plug-close {client} {
    global plug
    if {[plug-exists $client]} {
	#puts stderr "plug-close $client"
	close $plug($client-fp)
	close $plug($client-out-fp)
	file delete $plug($client-out-file)
	foreach name [array names plug $client-*] {
	    unset plug($name)
	}
	set i [lsearch -exact $plug(clients) $client]
	set plug(clients) [lreplace $plug(clients) $i $i]
    } else {
	puts stderr "non-existent client $client in plug-close"
    }
}

proc plug-close-all {} {
    global plug
    foreach client $plug(clients) {
	plug-close $client
    }
}

proc plug-puts {client opt value} {
    global plug
    if {[plug-exists $client]} {
	puts $plug($client-fp) "<$opt$value>"
    } else {
	puts stderr "non-existent client $client in plug-puts"
    }
}

proc plug-puts-text {client text} {
    global plug
    if {[plug-exists $client]} {
	puts $plug($client-fp) $text
    } else {
	puts stderr "non-existent client $client in plug-puts-text"
    }
}

proc plug-readable {client} {
    global plug
    # puts "plug-readable $client"
    if {[gets $plug($client-out-fp) line] < 0} {
	if {[eof $plug($client-out-fp)]} {
	    # don't close, they're files that will grow
	    # plug-close $client
	}
	return;
    }
    lappend plug($client-input) $line
}

proc plug-read {client} {
    global plug
    return [read $plug($client-out-fp)]
}

#
# initialize the plugged in helper applications
#
proc plug-init {} {
    global data
    # start jack
    # look for zombie helpers?
    foreach line [split [string trim [exec jack_lsp]] \n] {
	switch -glob $line {
	    ascii:* -
	    iambic:* -
	    ascii_tone:* -
	    iambic_tone:* {
		error "the [lindex [split $line :] 0] client is still running"
	    }
	}
    }
    # make helpers
    set connects {}
    if {$data(ascii)} {
	plug-open keyer_ascii ascii
	plug-open keyer_tone ascii_tone
	lappend connects {jack_connect ascii:midi_out ascii_tone:midi_in}
	lappend connects {jack_connect ascii_tone:out_i system:playback_1}
	lappend connects {jack_connect ascii_tone:out_q system:playback_2}
    }
    if {$data(iambic)} {
	plug-open keyer_iambic iambic
	# plug-open keyer_iambic2 iambic
	plug-open keyer_tone iambic_tone
	lappend connects {jack_connect system:midi_capture_1 iambic:midi_in}
	lappend connects {jack_connect iambic:midi_out iambic_tone:midi_in}
	lappend connects {jack_connect iambic_tone:out_i system:playback_1}
	lappend connects {jack_connect iambic_tone:out_q system:playback_2}
    }
    # these names may need to change around
    after 500
    set retry {}
    foreach cmd $connects {
	if {[catch "exec $cmd" error]} {
	    puts "$cmd: yielded $error"
	    lappend retry $cmd
	}
    }
    foreach cmd $retry {
	if {[catch "exec $cmd" error]} {
	    puts "$cmd: failed again, yielded $error"
	}
    }
}

#
# play some text
#
proc play-text {text} {
    plug-puts-text ascii $text
}


#
# update a variable and send it's value onward
#
proc ui-plug-puts {client opt scale value} {
    global data
    if {$scale == 1} {
	set value [format %.0f [expr {double($value)/double($scale)}]]
    } elseif {$scale == 10} {
	set value [format %.1f [expr {double($value)/double($scale)}]]
    } elseif {$scale == 100} {
	set value [format %.2f [expr {double($value)/double($scale)}]]
    } elseif {$scale == 1000} {
	set value [format %.3f [expr {double($value)/double($scale)}]]
    }
    set data($client-$opt-display) $value
    plug-puts $client $opt $value
}

#
# generic control panel row
#
proc ui-panel-row {w client row opt label from to units} {
    global data
    grid [ttk::label $w-o -text $opt] -row $row -column 0 -sticky w
    grid [ttk::label $w-l -text $label] -row $row -column 1
    if {[llength $from] > 1} {
	grid [ttk::frame $w-s] -row $row -column 2 -sticky w
	foreach x $from {
	    pack [ttk::radiobutton $w-s.x$x -text $x -variable data($client-$opt) -value $x -command [list plug-puts $client $opt $x]] -side left -anchor w
	}
    } else {
	set scale 1
	switch -regexp $from {
	    {^-?\d+$} { set scale 1 }
	    {^-?\d+.\d$} { set scale 10 }
	    {^-?\d+.\d\d$} { set scale 100 }
	}
	grid [ttk::scale $w-s -orient horizontal -from [expr {$from*$scale}] -to [expr {$to*$scale}] -length 250 \
		  -variable data($client-$opt-scale) -command [list ui-plug-puts $client $opt $scale]] -row $row -column 2 -sticky ew
	set data($client-$opt-scale) [expr {$data($client-$opt)*$scale}]
	ui-plug-puts $client $opt $scale $data($client-$opt-scale)
	grid [ttk::label $w-v -textvar data($client-$opt-display)] -row $row -column 3 -sticky e
	if {$units ne {}} {
	    grid [ttk::label $w-u -text $units] -row $row -column 4 -sticky w
	}
    }
}

#
# configure ascii keyer options
#
proc ui-ascii-frame {w client row} {
    foreach {opt label from to units} {
	wpm {words / minute} 5.0 60.0 {}
	word {word length} 40 70 dits
	dah {dah length} 2.5 3.5 dits
	ies {inter-element length} 0.5 1.5 dits
	ils {inter-letter length} 2.5 3.5 dits
	iws {inter-word length} 5 20 dits
    } {
	ui-panel-row $w.$client-$opt $client $row $opt $label $from $to $units
	incr row
    }
    return $row
}

#
# configure iambic keyer options
#
proc ui-iambic-frame {w client row} {
    foreach {opt label from to units} {
	wpm {words / minute} 5.0 60.0 {}
	word {word length} 40 70 dits
	dah {dah length} 2.5 3.5 dits
	ies {inter-element length} 0.5 1.5 dits
	ils {inter-letter length} 2.5 3.5 dits
	iws {inter-word length} 5 50 dits
	swap {swap paddles} {0 1} {} {}
	alsp {auto-letter space} {0 1} {} {}
	awsp {auto-word space} {0 1} {} {}
	mode {iambic mode} {A B} {} {}
    } {
	ui-panel-row $w.$client-$opt $client $row $opt $label $from $to $units
	incr row
    }
    return $row
}

#
# configure tone options
#
proc ui-tone-frame {w client row} {
    foreach {opt label from to units} {
	freq {tone frequency} 300.0 1000.0 Hz
	gain {tone volume} -40.0 0.0 dB
	rise {key rise time} 0.1 50.0 ms
	fall {key fall time} 0.1 50.0 ms
    } {
	ui-panel-row $w.$client-$opt $client $row $opt $label $from $to $units
	incr row
    }
    return $row
}

#
# configure MIDI options
#
proc ui-midi-frame {w client row} {
    foreach {opt label from to units} {
	chan {midi channel} 1 16 {}
	note {midi note} 0 127 {}
    } {
	ui-panel-row $w.$client-$opt $client $row $opt $label $from $to $units
	incr row
    }
    return $row
}

#
# configure keyer options
#
proc ui-control-panel {w} {
    global data
    ttk::frame $w
    set row 0


    if {$data(ascii)} {
	grid [label $w.ascii -text {Ascii Keyer Tone}] -row $row -column 0 -columnspan 5 -sticky w
	set row [ui-tone-frame $w ascii_tone [incr row]]
	grid [label $w.ascii2 -text {Ascii Keyer Timing}] -row $row -column 0 -columnspan 5 -sticky w
	set row [ui-ascii-frame $w ascii [incr row]]
	grid [label $w.ascii3 -text {Ascii Midi Options}] -row $row -column 0 -columnspan 5 -sticky w
	set row [ui-midi-frame $w ascii [incr row]]
    }

    if {$data(iambic)} {
	grid [label $w.iambic -text {Iambic Keyer Tone}] -row $row -column 0 -columnspan 5 -sticky w
	set row [ui-tone-frame $w iambic_tone [incr row]]
	grid [label $w.iambic2 -text {Iambic Keyer Timing}] -row $row -column 0 -columnspan 5 -sticky w
	set row [ui-iambic-frame $w iambic [incr row]]
	grid [label $w.iambic3 -text {Iambic Midi Options}] -row $row -column 0 -columnspan 5 -sticky w
	set row [ui-midi-frame $w iambic [incr row]]
    }

    return $w
}

#
# close the window
#
proc ui-close {w} {
    global data
    global score
    if {"$w" eq "."} {
	plug-close-all
	destroy .
    }
}

proc ui-input {k} {
    global data
    if {$data(ascii)} {
	plug-puts-text ascii $k
    }
}

#
# build a user interface
#
proc ui-init {} {
    pack [ui-control-panel .ctl]
    bind . <Destroy> [list ui-close %W]
    bind . <KeyPress> [list ui-input %A]
}

#
# 
#
proc main {argv} {
    global data
    global env

    foreach {opt value} $argv {
	switch -- $opt {
	    --ascii { set data(ascii) $value }
	    --ascii-wpm { set data(ascii-wpm) $value }
	    --ascii-freq { set data(ascii_tone-freq) $value }
	    --ascii-gain { set data(ascii_tone-gain) $value }
	    --iambic { set data(iambic) $value }
	    --iambic-wpm { set data(iambic-wpm) $value }
	    --iambic-freq { set data(iambic_tone-freq) $value }
	    --iambic-gain { set data(iambic_tone-gain) $value }
	    default {
		error "unknown option $opt"
	    }
	}
    }
    if {$data(ascii) || $data(iambic)} {
	plug-init
	ui-init
    }
}

main $argv