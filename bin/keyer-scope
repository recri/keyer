#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

# [ ] - let the view scroll to follow the input
# [ ] - display the time scale with tick labels
# [x] - display a cursor that covers all the displays
# [x] - make the tone scope the same width as the other displays
# [ ] - autoscale the vertical on the tone scope

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

package require Tk
package require capture
#package require scope
#package require keyer-scope

# package provide scope 1.0.0
namespace eval ::scope {
    array set default_data {
	-height 200
	-y-scale 2.0
	-y-origin 1.0
	-x-scale 1.0
	-x-origin 0.0
	-text {}
    }
}

proc ::scope::configure {w args} {
    upvar #0 ::scope::$w data
    foreach {option value} $args {
	switch -- $option {
	    -height {
		# unscale current
		catch {$w move all 0 [expr {-$data(-y-origin)}]}
		catch {$w scale all 0 0 1 [expr {1/$data(-y-scale)}]}
		# reset for new height
		$w configure -height $value
		set data(-y-scale) [expr {-0.75*$value/2.0}]
		set data(-y-origin) [expr {$value/2.0}]
		# rescale for new height
		$w scale all 0 0 1 $data(-y-scale)
		$w move all 0 $data(-y-origin)
		$w configure -scrollregion [$w bbox all]
	    }
	    -width {
		$w configure -width $value
	    }
	    -x-scale {
		if {[info exists data(-x-scale)]} {
		    $w scale all 0 0 [expr {$value/$data(-x-scale)}] 1
		}
	    }
	    -x-origin {
		if {[info exists data(-x-origin)]} {
		    $w move all [expr {$value-$data(-x-origin)}] 0
		}
	    }
	    -xscrollcommand {
		$w configure $option $value
	    }
	    default {
	    }
	}
	set data($option) $value
    }
    catch {$w configure -scrollregion [$w bbox all]}
}

proc ::scope::start-iq {w sx} {
    upvar #0 ::scope::$w data
    catch {unset data(frame)}
    catch {unset data(chunk)}
    set data(i-xy) {}
    set data(q-xy) {}
    catch {$w delete all}
    #$w create text 0 0 -text $data(-text) -fill white -tags text -anchor nw
    set data(last-frame) 0
    update-iq $w $sx [binary format f* [lrepeat 4 0.0]] 1
}

proc ::scope::stop-iq {w ex} {
    ::scope::update-iq $w $ex [binary format f* {0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0}]
}

proc ::scope::update-iq {w frame iq {end 0}} {
    upvar #0 ::scope::$w data
    set data(last-frame) $frame
    set skip 0
    if { ! [info exists data(frame)]} {
	set data(frame) $frame
	set data(chunk) 0
    } elseif {$frame < $data(frame)} {
	set skip [expr {$data(frame)-$frame}]
	# puts "overlapped $skip samples"
    } elseif {$frame > $data(frame) && ! $end} {
	puts "missed [expr {$frame-$data(frame)}] samples"
    }

    binary scan $iq f* samples
    set n [llength $samples]
    set isamples [lrange $samples $skip [expr {$n/2-1}]]
    #set qsamples [lrange $samples [expr {$n/2+$skip}] end]
    incr frame $skip

    set ixy {}
    #set qxy {}
    #foreach i $isamples q $qsamples {}
    foreach i $isamples {
	lappend ixy $frame $i
	#lappend qxy $frame $q
	incr frame
    }
    set data(frame) $frame

    set chunk [incr data(chunk)]
    #$w create line $qxy -fill \#7fff7f -tags [list capture-q-$chunk chunk-$chunk]
    $w create line $ixy -fill white -tags [list capture-i-$chunk chunk-$chunk]

    $w scale chunk-$chunk 0 0 $data(-x-scale) $data(-y-scale)
    $w move chunk-$chunk 0 $data(-y-origin)
    $w configure -scrollregion [$w bbox all]
    #$w coords text [$w canvasx 1] [$w canvasy 1]
}

proc ::scope::update-event {w frame y {end 0}} {
    upvar #0 ::scope::$w data
    if { ! $end} {
	lappend data(midi-xy) $frame [expr {-$y}]
    }
    lappend data(midi-xy) $frame $y
    $w coords capture-midi $data(midi-xy)
    $w scale all 0 0 $data(-x-scale) $data(-y-scale)
    $w move all 0 $data(-y-origin)
    $w configure -scrollregion [$w bbox all]
    $w coords text [$w canvasx 1] [$w canvasy 1]
}

proc ::scope::start-event {w sx} {
    upvar #0 ::scope::$w data
    set data(frame) $sx
    set data(midi-xy) [list $sx -1]
    catch {$w delete all}
    $w create line 0 0 0 0 -fill white -tags capture-midi
    $w create text 0 0 -text $data(-text) -fill white -tags text -anchor nw
    ::scope::update-event $w $sx -1 1
}

proc ::scope::stop-event {w ex} {
    ::scope::update-event $w $ex -1 1
}

proc ::scope::defaults {} {
    return [array get ::scope::default_data]
}

proc ::scope::scope {w args} {
    upvar #0 ::scope::$w data
    canvas $w -bg black
    ::scope::configure $w {*}[::scope::defaults]
    ::scope::configure $w {*}$args
    if {[info exists data(-text)] && $data(-text) ne {}} { 
	$w create text 0 0 -anchor nw -text $data(-text) -fill white -tags text
    }
    return $w
}

proc ::scope {w args} {
    return [::scope::scope $w {*}$args]
}

# package provide time-scale 1.0.0
namespace eval ::time-scale {
    array set default_data {
	-height 20
	-x-scale 1.0
	-x-offset 0.0
	-x-start 0
	-x-finish 0
    }
}

proc ::time-scale::update-scale {w} {
    upvar #0 ::time-scale::$w data
    ## okay, the scale should cover the max(visible, drawn)
    ## drawn is ($data(-x-start) .. $data(-x-finish))
    ## visible is (0 width)/$data(-x-scale)
    ## in units of frames
    set ht [winfo height $w]
    set wd [winfo width $w]
    # puts "ht $ht wd $wd"
    if {$ht < 5 || $wd < 5} return
    set y [expr {$ht/2.0}]
    set yp [expr {$y+$ht/4.0}]
    set yn [expr {$y-$ht/4.0}]
    set x0 0
    set x1 [expr {max(($data(-x-finish)-$data(-x-start)), $wd/$data(-x-scale))}]

    # now the width of the scale is ($x1-$x0) in frames, so ($x1-$x0)/sample-rate in seconds
    set sr [sdrkit::jack sample-rate]
    set tx [expr {double($x1-$x0)/$sr}]
    set tw [expr {$wd/$data(-x-scale)/$sr}]
    # choose the unit for tick marks
    set unit 1.0
    while {1} {
	if {$tw/$unit < 5.0} {
	    set unit [expr {$unit/10.0}]
	} elseif {$tw/$unit >= 50.0} {
	    set unit [expr {$unit*10.0}]
	} else {
	    break
	}
    }
    # puts "unit $unit seconds"
    if {$tw/$unit < 20} {
	set sub 1
    } else {
	set sub 0
    }
    # convert that into frames
    set funit [expr {int($sr*$unit)}]
    # make the tick mark coordinates
    set xy {}
    for {set f 0} {$f < $x1} {incr f $funit} {
	lappend xy $f $y $f $yp $f $yn $f $y
    }
    lappend xy $x1 $y
    # draw the lines
    $w coords line $xy
    $w scale all 0 0 $data(-x-scale) 1
    $w configure -scrollregion [$w bbox all]
    # puts "update-scale unit $unit seconds displayed line is $tx seconds, window width is $tw seconds"
    # puts "update-scale display [expr {$data(-x-scale)*$data(-x-start)}] finish [expr {$data(-x-scale)*$data(-x-finish)}] width [winfo width $w] xview [$w xview]"
}

proc ::time-scale::update {w frame} {
    upvar #0 ::time-scale::$w data
    set data(-x-finish) $frame
    ::time-scale::update-scale $w
}

proc ::time-scale::start {w frame} {
    upvar #0 ::time-scale::$w data
    set data(-x-start) $frame
    set data(-x-finish) $frame
    catch {$w delete all}
    $w create line 0 0 0 0 -fill white -tags line
    ::time-scale::update-scale $w
}

proc ::time-scale::stop {w frame} {
    upvar #0 ::time-scale::$w data
    set data(-x-finish) $frame
    ::time-scale::update-scale $w
}

proc ::time-scale::configure {w args} {
    upvar #0 ::time-scale::$w data
    foreach {option value} $args {
	switch -- $option {
	    -x-scale {
		$w scale all 0 0 [expr {$value/$data(-x-scale)}] 1
		::time-scale::update-scale $w
	    }
	}
	set data($option) $value
    }
    catch {$w configure -scrollregion [$w bbox all]}
}

proc ::time-scale::destroy {w} {
}

proc ::time-scale::defaults {} {
    return [array get ::time-scale::default_data]
}

proc ::time-scale::time-scale {w args} {
    upvar #0 ::time-scale::$w data
    array set data [::time-scale::defaults]
    array set data $args
    return [canvas $w -height $data(-height) -bg black]
}


proc ::time-scale {w args} {
    return [::time-scale::time-scale $w {*}$args]
}

# package provide keyer-scope 1.0.0

namespace eval ::keyer-scope {
    array set default_data {
	-verbose 0
	-chan 1
	-note 0
	-zoom 0.01
	-origin 0.0
	-scroll 0.0
	-connect {}
	-period 50
	-size 4096
    }
}

proc ::keyer-scope::configure {w args} {
    upvar #0 ::keyer-scope::$w data
    foreach {option value} $args {
	switch -- $option {
	    -zoom {
		set data(-zoom) $value
		set srate [sdrkit::jack sample-rate]
		set scale [expr {$data(-zoom)/$srate}]
		foreach scope {iq keyer key1 key0 ptt0 ptt1 raw0 raw1} {
		    ::scope::configure $w.$scope -x-scale $scale
		}
		::time-scale::configure $w.t -x-scale $scale
		::keyer-scope::scrollregion $w
	    }
	    default { set data($option) $value 	}
	}
    }
}

proc ::keyer-scope::update-iq {w frame binary} {
    # puts "keyer-scope update-iq $w $frame [string length $binary]"
    set w [winfo parent $w]
    upvar #0 ::keyer-scope::$w data
    set frame [expr {$frame-$data(start-frame)}]
    if {$frame >= 0} {
	::scope::update-iq $w.iq $frame $binary
	::keyer-scope::scrollregion $w
    }
    ::time-scale::update $w.t [expr {$frame+[string length $binary]/4/2}]
}

proc ::keyer-scope::update-midi {wkey events} {
    set w [winfo parent $wkey]
    upvar #0 ::keyer-scope::$w data
    foreach item $events {
	foreach {frame event} $item {
	    binary scan $event ccc cmd note velocity
	    set chan [expr {($cmd&0xF)+1}]
	    set cmd [expr {($cmd>>4)&0xF}]
	    if {$chan == $data(-chan) && ($cmd == 8 || $cmd == 9)} {
		set frame [expr {$frame-$data(start-frame)}]
		if {$note == $data(-note)} {
		    ::scope::update-event $wkey $frame [expr {2*($cmd-8)-1}]
		} elseif {$note == $data(-note)+1} {
		    switch -glob $wkey {
			*key0 {
			    ::scope::update-event $w.key1 $frame [expr {2*($cmd-8)-1}]
			}
			*ptt0 {
			    ::scope::update-event $w.ptt1 $frame [expr {2*($cmd-8)-1}]
			}
			*raw0 {
			    ::scope::update-event $w.raw1 $frame [expr {2*($cmd-8)-1}]
			}
			default {
			    error "unknown keyer channel $wkey"
			}
		    }
		}
		::time-scale::update $w.t $frame
	    }
	}
    }
}

proc ::keyer-scope::window-configure {w cw width height} {
    if {$w ne $cw} return
    # puts "keyer-scope::window-configure $w $cw $width $height"
    upvar #0 ::keyer-scope::$w data
    # ::capture::configure $w -size $width
    set srate [sdrkit::jack sample-rate]
    set scale [expr {$data(-zoom)/$srate}]
    foreach scope {iq keyer key0 key1 ptt0 ptt1 raw0 raw1} {
	::scope::configure $w.$scope -x-scale $scale -height [winfo height $w.$scope]
    }
    ::time-scale::configure $w.t -x-scale $scale
    ::keyer-scope::scrollregion $w
}

proc ::keyer-scope::window-destroy {w cw} {
    if {$w ne $cw} return
    upvar #0 ::keyer-scope::$w data
    ::capture::destroy $w
    foreach scope {iq keyer key0 key1 ptt0 ptt1 raw0 raw1} {
	::scope::destroy $w.$scope
    }
    ::time-scale::destroy $w.t
}

proc ::keyer-scope::defaults {} {
    return [array get ::keyer-scope::default_data]
}

proc ::keyer-scope::start {w} {
    upvar #0 ::keyer-scope::$w data
    set data(start-frame) [sdrkit::jack frame-time]
    ::scope::start-iq $w.iq 0
    foreach scope {keyer key0 key1 ptt0 ptt1 raw0 raw1} {
	::scope::start-event $w.$scope 0
    }
    foreach capture {iq keyer key0 ptt0 raw0} {
	::capture::start $w.$capture
    }
    ::time-scale::start $w.t 0
}

proc ::keyer-scope::stop {w} {
    upvar #0 ::keyer-scope::$w data
    set data(last-frame) [sdrkit::jack frame-time]
    set frames [expr {$data(last-frame)-$data(start-frame)}]
    foreach capture {iq keyer key0 ptt0 raw0} {
	::capture::stop $w.$capture
    }
    ::scope::stop-iq $w.iq $frames
    foreach scope {keyer key0 key1 ptt0 ptt1 raw0 raw1} {
	::scope::stop-event $w.$scope $frames
    }
    ::time-scale::stop $w.t $frames
    ::keyer-scope::scrollregion $w
}

proc ::keyer-scope::xview {w args} {
    foreach view {iq keyer key0 key1 ptt0 ptt1 raw0 raw1} {
	$w.$view xview {*}$args
    }
    $w.t xview {*}$args
}

proc ::keyer-scope::xscrollcommand-set {w args} {
    $w.x set {*}$args
}

proc ::keyer-scope::scrollregion {w} {
    if {[catch {
	$w.iq configure -scrollregion [$w.iq bbox all]
	$w.x set {*}[$w.iq xview]
    } error]} {
	puts $error
    }
}

proc ::keyer-scope::motion {w w2 x y} {
    upvar #0 ::keyer-scope::$w data
    foreach {c i} $data(graticule) {
	$c coords $i $x 0 $x [winfo height $c]
    }
}

proc ::keyer-scope::enter {w w2} {
    upvar #0 ::keyer-scope::$w data
    set data(graticule) {}
    foreach c {iq ptt1 ptt0 keyer key1 key0 raw1 raw0 t} {
	lappend data(graticule) $w.$c [$w.$c create line 0 0 0 0 -fill grey -tags graticule]
    }
    bind $w2 <Motion> [list ::keyer-scope::motion $w $w2 %x %y]
}

proc ::keyer-scope::leave {w w2} {
    upvar #0 ::keyer-scope::$w data
    bind $w2 <Motion> {}
    foreach {c i} $data(graticule) { $c delete $i }
    set data(graticule) {}
}

proc ::keyer-scope::keyer-scope {w args} {
    upvar #0 ::keyer-scope::$w data
    array set data [::keyer-scope::defaults]
    array set data $args
    ttk::panedwindow $w -orient vertical
    $w add [::scope $w.iq -height 50 -text audio -xscrollcommand [list ::keyer-scope::xscrollcommand-set $w]] -weight 1
    bind $w.iq <Enter> [list ::keyer-scope::enter $w $w.iq]
    bind $w.iq <Leave> [list ::keyer-scope::leave $w $w.iq]
    foreach scope {ptt1 ptt0 keyer key1 key0 raw1 raw0} {
	$w add [::scope $w.$scope -height 20 -text $scope] -weight 1
	bind $w.$scope <Enter> [list ::keyer-scope::enter $w $w.$scope]
	bind $w.$scope <Leave> [list ::keyer-scope::leave $w $w.$scope]
    }
    $w add [::time-scale $w.t -height 20] -weight 0
    bind $w.t <Enter> [list ::keyer-scope::enter $w $w.t]
    bind $w.t <Leave> [list ::keyer-scope::leave $w $w.t]
    $w add [ttk::scrollbar $w.x -orient horizontal -command [list ::keyer-scope::xview $w]] -weight 0
    # period and size must add up to most of the data
    set data(sample-rate) [sdrkit::jack sample-rate]
    set data(buffer-size) [sdrkit::jack buffer-size]
    # whatever rate I capture at, I should capture a little sooner and expect to get overlaps
    for {set n 1} {1} {set n [expr {$n+$n}]} {
	set ns [expr {$n*$data(buffer-size)}]
	set nms [expr {1000*$ns/$data(sample-rate)}]
	if {$nms > 100} break
	set data(capture-samples) $ns
	set data(capture-millis) $nms
    }
    puts "capture $data(capture-samples) samples every $data(capture-millis) ms => [expr {1000*$data(capture-samples)/$data(capture-millis)}] samples/second vs $data(sample-rate)"
    incr data(capture-samples) $data(capture-samples)
    ::capture::iq $w.iq -period $data(capture-millis) -size $data(capture-samples) -client ::keyer-scope::update-iq -connect iambic_tone
    foreach {capture connect} {ptt0 ptt:midi_out keyer iambic:midi_out key0 debounce:midi_out raw0 system:midi_capture_1} {
	::capture::midi $w.$capture -period 200 -client ::keyer-scope::update-midi -connect $connect
    }
    bind . <Configure> [list ::keyer-scope::window-configure $w %W %w %h]
    bind . <Destroy> [list ::keyer-scope::window-destroy $w %W]
    return $w
}

proc keyer-scope {w args} {
    return [keyer-scope::keyer-scope $w {*}$args]
}

array set data {
    state 0
    state-text {capture start}
    log-zoom 5
    zoom 50
    zoom-label 5.0e+01
}

proc swap-state {} {
    global data
    if {$data(state)} {
	::keyer-scope::stop .k
	set data(state) 0
	.c.go configure -text start
    } else {
	::keyer-scope::start .k
	set data(state) 1
	.c.go configure -text stop
    }
}

proc zoom {step} {
    global data
    incr data(log-zoom) $step
    set frac [lindex {1 2.5 5} [expr {$data(log-zoom)%3}]]
    set expo [expr {pow(10,$data(log-zoom)/3)}]
    set data(zoom) [expr {$frac*$expo}]
    set data(zoom-label) [format %7.1e $data(zoom)]
    keyer-scope::configure .k -zoom $data(zoom)
}

proc main {argv} {
    global data
    wm title . {keyer-scope}
    pack [keyer-scope .k {*}$argv] -side top -fill both -expand true
    zoom 0
    pack [ttk::frame .c] -side top
    pack [ttk::button .c.go -text start -command swap-state] -side left
    pack [ttk::button .c.zoom-in -text {-t} -command {zoom -1}] -side left
    pack [ttk::label .c.zoom -textvariable data(zoom-label) -width 8] -side left
    pack [ttk::button .c.zoom-out -text {+t} -command {zoom +1}] -side left
    pack [ttk::button .c.quit -text quit -command {destroy .}] -side left
}

main $argv