#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

package require Tk

package require sdrtk::graph

#
# review records produced by iq-correct-train -loop
# 1) find the relationship between dBFS and useful mu
# 2) see if the alogrithm produced reproducible corrections
#

array set data {
    -extremes false
}

proc average-max-min {vals} {
    return [list [expr {[tcl::mathop::+ {*}$vals]/double([llength $vals])}] [tcl::mathfunc::max {*}$vals] [tcl::mathfunc::min {*}$vals]]
}

proc main {argv} {
    foreach {option value} $argv {
	switch -- $option {
	    -extremes { set ::data(-extremes) $value }
	    default { error "unknown option \"$option\"" }
	}
    }
    grid [ttk::frame .t] -row 0
    grid [sdrtk::graph .c] -row 1 -sticky nsew
    grid [sdrtk::graph .d] -row 2 -sticky nsew
    grid [sdrtk::graph .e] -row 3 -sticky nsew
    grid rowconfigure . 1 -weight 1
    grid rowconfigure . 2 -weight 1
    grid rowconfigure . 3 -weight 1
    grid columnconfigure . 0 -weight 1

    set lineno 0
    while {[gets stdin line] >= 0} {
	incr lineno
	# goes to 13 with addition of length
	if {[llength $line] != 12} {
	    error "$lineno: length mismatch: $line"
	}
	# lassign $line alg date time tz freq mhz lvl dbfs nsamp w iq parts tparts
	lassign $line alg date time tz freq mhz lvl dbfs w iq parts tparts
	if {[llength $iq] != 2} {
	    error "$lineno: iq length mismatch: $iq"
	}
	if {[tcl::mathop::+ {*}$parts] < $tparts} {
	    error "$lineno: parts sum mismatch: [tcl::mathop::+ {*}$parts] vs $tparts"
	}
	lappend ival($freq) [lindex $iq 0]
	lappend qval($freq) [lindex $iq 1]
	lappend dval($freq) $lvl
	lappend pval($parts) $lvl
    }
    foreach f [lsort -real [array names ival]] {
	lassign [average-max-min $ival($f)] iavg imax imin
	lassign [average-max-min $qval($f)] qavg qmax qmin
	lassign [average-max-min $dval($f)] davg dmax dmin
	if {$::data(-extremes)} {
	    lappend ixy $f $iavg $f $imax $f $imin $f $iavg
	    lappend qxy $f $qavg $f $qmax $f $qmin $f $qavg
	    lappend dxy $f $davg $f $dmax $f $dmin $f $davg
	} else {
	    lappend ixy $f $iavg
	    lappend qxy $f $qavg
	    lappend dxy $f $davg
	}
    }
    .c add line pts {*}$ixy
    .d add line pts {*}$qxy
    .e add line pts {*}$dxy
    puts "[array size ival] frequencies"
    puts "[array size pval] parts"
    puts "$lineno lines processed"
}
    
main $argv
