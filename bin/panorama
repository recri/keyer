#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

package require Tk
package require sdrkit
package require sdrkit_atap

##
## waterfall
##

# package provide waterfall 1.0.0

namespace eval ::waterfall {
    array set default_data {
	-height 200
	-atten 0
	-pal 0
	-min -125.0
	-max -60.0
	-scale 1.0
	-offset 0.0
    }
}

proc ::waterfall::hotiron {hue pal} {
    switch $pal {
	0 { lassign [list [expr {3*($hue+0.03)}] [expr {3*($hue-.333333)}] [expr {3*($hue-.666667)}]] r g b }
	1 { lassign [list [expr {3*($hue+0.03)}] [expr {3*($hue-.666667)}] [expr {3*($hue-.333333)}]] r g b }
	2 { lassign [list [expr {3*($hue-.666667)}] [expr {3*($hue+0.03)}] [expr {3*($hue-.333333)}]] r g b }
	3 { lassign [list [expr {3*($hue-.333333)}] [expr {3*($hue+0.03)}] [expr {3*($hue-.666667)}]] r g b }
	4 { lassign [list [expr {3*($hue-.333333)}] [expr {3*($hue-.666667)}] [expr {3*($hue+0.03)}]] r g b }
	5 { lassign [list [expr {3*($hue-.666667)}] [expr {3*($hue-.333333)}] [expr {3*($hue+0.03)}]] r g b }
    }
    return [format {#%02x%02x%02x} [expr {int(255*min(1,max($r,0)))}] [expr {int(255*min(1,max($g,0)))}] [expr {int(255*min(1,max($b,0)))}]]
}

proc ::waterfall::pixel {w level} {
    upvar #0 ::waterfall::$w data
    # clamp to percentage of range
    set level [expr {min(1,max(0,($level-$data(-min))/($data(-max)-$data(-min))))}]
    # use 100 levels
    set i color-$data(-pal)-[expr {int(100*$level)}]
    if { ! [info exists data($i)]} {
	set data($i) [hotiron $level $data(-pal)]
	# puts "assigned $data($i) to level $level"
    }
    return $data($i)
}

proc ::waterfall::update {w xy} {
    upvar #0 ::waterfall::$w data

    set scanline {}
    set x0 [lindex $xy 0]
    foreach {x y} $xy {
	lappend scanline [pixel $w [expr {$y+$data(-atten)}]]
    }
	
    # scroll all the canvas images down by 1
    $w move all 0 1

    # create a new canvas image
    set i $data(line-number)
    set data(img-$i) [image create photo]
    $data(img-$i) put [list $scanline]
    set data(item-$i) [$w create image $x0 0 -anchor nw -image $data(img-$i)]
    $w scale $data(item-$i) 0 0 $data(-scale) 1
    $w move $data(item-$i) $data(-offset) 0

    # increment our scanline index
    incr data(line-number)
}

proc ::waterfall::configure {w args} {
    upvar #0 ::waterfall::$w data
    array set save [array get data]
    foreach {option value} $args {
	switch -- $option {
	    -scale -
	    -offset {
		set adjustpos 1
		set data($option) $value
	    }
	    default {
		set data($option) $value
	    }
	}
    }
    if {[info exists adjustpos]} {
	$w move all [expr {-$save(-offset)}] 0
	$w scale all 0 0 [expr {$data(-scale)/$save(-scale)}] 1
	$w move all $data(-offset) 0
	# puts "waterfall::configure -scale $data(-scale) -offset $data(-offset) bbox [$w bbox all]"
    }
}
    
proc ::waterfall::waterfall {w args} {
    upvar #0 ::waterfall::$w data
    array set data [array get ::waterfall::default_data]
    array set data $args
    canvas $w -height $data(-height) -bg black
    set data(line-number) 0
    return $w
}

proc ::waterfall {w args} {
    return [::waterfall::waterfall $w {*}$args]
}

##
## spectrum
##

# package provide spectrum 1.0.0

namespace eval ::spectrum {
    # smooth?
    # multiple traces?
    array set default_data {
	-height 100
	-offset 0.0
	-scale 1.0
    }
}

proc ::spectrum::update {w xy} {
    upvar #0 ::spectrum::$w data
    $w coords spectrum $xy
    $w scale spectrum 0 0 $data(-scale) [expr {-[winfo height $w]/180.0}]
    $w move spectrum $data(-offset) 0
    # keep older copies fading to black
}

proc ::spectrum::configure {w args} {
    upvar #0 ::spectrum::$w data
    array set save [array get data]
    foreach {option value} $args {
	switch -- $option {
	    -scale -
	    -offset {
		set adjustpos 1
		set data($option) $value
	    }
	    default {
		set data($option) $value
	    }
	}
    }
    if {[info exists adjustpos]} {
	$w move all [expr {-$save(-offset)}] 0
	$w scale all 0 0 [expr {$data(-scale)/$save(-scale)}] 1
	$w move all $data(-offset) 0
	# puts "spectrum::configure -scale $data(-scale) -offset $data(-offset) bbox [$w bbox all]"
    }
}

proc ::spectrum::spectrum {w args} {
    upvar #0 ::spectrum::$w data
    array set data [array get ::spectrum::default_data]
    array set data $args
    canvas $w -height $data(-height) -bg black
    $w create line 0 0 0 0 -fill white -tags spectrum
    return $w
}    

proc ::spectrum {w args} {
    return [::spectrum::spectrum $w {*}$args]
}

##
## frequency display panel
##

# package provide frequency 1.0.0

namespace eval ::frequency {
    array set default_data {
	-offset 0.0
	-scale 1.0
	-height 50
	-lo1-offset 0.0
	-lo2-offset {}
    }
}

proc ::frequency::configure {w args} {
    upvar #0 ::frequency::$w data
    array set save [array get data]
    foreach {option value} $args {
	switch -- $option {
	    -scale -
	    -offset {
		set adjustpos 1
		set data($option) $value
	    }
	    default {
		set data($option) $value
	    }
	}
    }
    if {[info exists adjustpos]} {
	$w move all [expr {-$save(-offset)}] 0
	$w scale all 0 0 [expr {$data(-scale)/$save(-scale)}] 1
	$w move all $data(-offset) 0
    }
}
    
proc ::frequency::update {w xy} {
    upvar #0 ::frequency::$w data
    set x0 [lindex $xy 0]
    set xn [lindex $xy end-1]
    if { ! [info exists data(saved-x0)] || $data(saved-x0) != $x0 || $data(saved-xn) != $xn} {
	set data(saved-x0) $x0
	set data(saved-xn) $xn
	catch {$w delete all}
	set i0 [expr {5000*int(($x0+$data(-lo1-offset))/5000)}]
	set in [expr {5000*int(($xn+$data(-lo1-offset))/5000)}]
	set xy {}
	for {set i $i0} {$i <= $in} {incr i 1000} {
	    if {($i % 10000) == 0} {
		lassign {10 -10} tp tn
		if {($i % 20000) == 0} {
		    set label "[expr {$i/1000}]kHz"
		}
	    } else {
		lassign {5 -5} tp tn
	    }
	    set x [expr {$i-$data(-lo1-offset)}]
	    lappend xy $x 0 $x $tn $x $tp $x 0
	    if {[info exists label]} {
		$w create text $x 12 -text $label -anchor n -tag labels -fill white
		unset label
	    }
	}
	#puts "ticks $xy"
	$w create line $xy -fill white -tags ticks
	#puts "bbox raw [$w bbox all]"
	$w scale all 0 0 $data(-scale) 1
	#puts "bbox scaled [$w bbox all]"
	$w move all $data(-offset) [expr {[winfo height $w]/2.0}]
	#puts "bbox moved [$w bbox all]"
    }
}
proc ::frequency::frequency {w args} {
    upvar #0 ::frequency::$w data
    array set data [array get ::frequency::default_data]
    array set data $args
    canvas $w -height $data(-height) -bg black
    $w create line 0 0 0 0 -fill white -tag ticks
    return $w
}

proc ::frequency {w args} {
    return [::frequency::frequency $w {*}$args]
}

##
## capture
##
# package provide capture 1.0.0
namespace eval ::capture {
    set ntap 0
    array set default_data {
	-connect {}
	-period 50
	-size 4096
    }
}

proc ::capture::destroy {w} {
    upvar #0 ::capture::$w data
    catch {rename $data(tap) {}}
    catch {rename $data(fft) {}}
}

proc ::capture::configure {w args} {
    upvar #0 ::capture::$w data
    foreach {option value} $args {
	switch -- $option {
	    -size {
		if {$value != $data(-size)} {
		    set data(-size) $value
		    catch {rename $data(fft) {}}
		    ::sdrkit::fftw $data(fft) $value
		}
		set data($option) $value
	    }
	    -period {
		set data($option) $value
	    }
	    -connect {
		foreach x $value {
		    catch {sdrkit::jack connect $x:out_i $data(tap):in_i}
		    catch {sdrkit::jack connect $x:out_q $data(tap):in_q}
		}
		set data($option) $value
	    }
	    default {
		set data($option) $value
	    }
	}
    }
}

proc ::capture::capture {w} {
    upvar #0 ::capture::$w data

    # cache a number
    set n  $data(-size)

    # capture a buffer
    foreach {f b} [::$data(tap) get $n] break
	
    # compute the fft
    set l [::$data(fft) $b]
	
    # convert the coefficients to a list
    binary scan $l f* levels
	
    # reorder the results from most negative frequency to most positive
    # compute the power, and convert to pixels
    ## they're ordered from 0 .. most positive, most negative .. just < 0
    ## k/T, T = total sample time, n * 1/sample_rate
    set xy {}
    set x [expr {-[sdrkit::jack sample-rate]/2.0}]
    set dx [expr {[sdrkit::jack sample-rate]/double($n)}]
    foreach {re im} [concat [lrange $levels [expr {1+$n}] end] [lrange $levels 0 $n]] {
	# squared magnitude means 10*log10 dB
	lappend xy $x [expr {10*log10($re*$re+$im*$im+1e-16)}]
	set x [expr {$x+$dx}]
    }

    # send the result to the client
    $data(-client) $w $xy

    # schedule next capture
    after $data(-period) [list ::capture::capture $w]
}

proc ::capture::spectrum {w args} {
    upvar #0 ::capture::$w data
    array set data [array get ::capture::default_data]
    set data(tap) capture$::capture::ntap
    set data(fft) capture_fft_$::capture::ntap
    incr ::capture::ntap
    ::sdrkit::atap $data(tap)
    ::capture::configure $w {*}$args
    after 500 [list ::capture::capture $w]
}

##
## panorama
##
# package provide panorama 1.0.0

namespace eval ::panorama {
    array set default_data {
	-zoom 1.0
	-scroll 0.0
	-connect {}
	-period 50
	-size 4096
    }
}

proc ::panorama::update {w xy} {
    upvar #0 ::panorama::$w data
    # update spectrum and waterfall
    ::spectrum::update $w.s $xy
    ::waterfall::update $w.w $xy
    ::frequency::update $w.f $xy
}

proc ::panorama::configure {w args} {
    upvar #0 ::panorama::$w data
    foreach {option value} $args {
	switch -- $option {
	    default { set data($option) $value 	}
	}
    }
}

proc ::panorama::window-configure {w cw width height} {
    if {$w ne $cw} return
    # puts "panorama::window-configure $w $cw $width $height"
    upvar #0 ::panorama::$w data
    ::capture::configure $w -size $width
    set srate [sdrkit::jack sample-rate]
    set scale [expr {$data(-zoom)*double($width)/$srate}]
    set offset [expr {double($width)/2}]
    ::waterfall::configure $w.w -scale $scale -offset $offset
    ::spectrum::configure $w.s -scale $scale -offset $offset
    ::frequency::configure $w.f -scale $scale -offset $offset
}

proc ::panorama::window-destroy {w cw} {
    if {$w ne $cw} return
    upvar #0 ::panorama::$w data
    ::capture::destroy $w
    ::waterfall::destroy $w.w
    ::spectrum::destroy $w.s
    ::frequency::destroy $w.f

    foreach img [array names data img-*] {
	rename $data($img) {}
    }
}

proc ::panorama::panorama {w args} {
    upvar #0 ::panorama::$w data
    array set data [array get ::panorama::default_data]
    array set data $args
    ttk::panedwindow $w -orient vertical
    $w add [::spectrum $w.s] -weight 1
    $w add [::frequency $w.f] -weight 0
    $w add [::waterfall $w.w] -weight 1
    #rename $w ::panorama::$w
    #proc $w {args} [list return [list panorama::command $w \$args]]
    ::capture::spectrum $w -period $data(-period) -size $data(-size) -client ::panorama::update
    bind . <Configure> [list ::panorama::window-configure $w %W %w %h]
    bind . <Destroy> [list ::panorama::window-destroy $w %W]
    return $w
}

proc ::panorama {w args} {
    return [panorama::panorama $w {*}$args]
}

proc main {argv} {
    pack [panorama .p] -fill both -expand true
}

main $argv