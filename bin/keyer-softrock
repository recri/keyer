#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2011, 2012 by Roger E Critchlow Jr, Santa Fe, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

set script [expr { ! [catch {file readlink [info script]} link] ? $link : [info script]}]
lappend auto_path [file join [file dirname $script] .. lib]

#
# a simple program to play with the midi keyer softrock controller
#
# we use a midi-tap connected to system:midi_capture_1 to listen to keyer
# events, and a midi-insert connected to system:midi_playback_1 to send
# events back to the keyer.
#
package require Tk
package require vfo
package require scrolled

package require sdrkit::midi-tap
package require sdrkit::midi-insert
# package require keyer::debounce
package require sdrkit::jack

array set data {
}

binary scan {a} c data(offset)
binary scan "}" c data(vendor)
binary scan "!" c data(prefix)
binary scan "\"" c data(prefixq)

set data(sysex-start) 0xF0
set data(sysex-end) 0xF7

proc midi-transmit {cmd note vel} { midi-out puts [binary format ccc $cmd $note $vel] }

proc midi-raw {binary} {
    binary scan $binary c* msg_bytes
    puts "midi-raw: sending: [midi-format $msg_bytes]"
    midi-out puts $binary
}

proc midi-sysex {bytes} {
    set msg [binary format cccc*c $::data(sysex-start) $::data(vendor) $::data(prefix) [midi-sysex-encode $bytes] $::data(sysex-end)]
    binary scan $msg c* msg_bytes
    puts "midi-sysex: sending: [midi-format $msg_bytes]"
    midi-out puts $msg
}

proc midi-sysex-encode {bytes} {
    set encoded {}
    foreach b $bytes {
	lappend encoded [expr {(($b>>4)&0xF)+$::data(offset)}] [expr {(($b)&0xF)+$::data(offset)}]
    }
    return $encoded
}

proc midi-sysex-decode {bytes} {
    if {([llength $bytes]&1) != 0} {
	error "sysex decode with odd number of bytes: $bytes"
    }
    set decoded {}
    foreach {a b} $bytes {
	lappend decoded [expr {(($a-$::data(offset))<<4)|($b-$::data(offset))}]
    }
    return $decoded
}

#
# poll input and deliver to receiver
#
proc midi-poll {input receiver} {
    set events [$input get]
    if {$events ne {}} {
	$receiver $events
    }
    after 100 [list midi-poll $input $receiver]
}

#
# receive note events
#
proc midi-receive-note {frame bytes} {
    switch [llength $bytes] {
	3 {
	    lassign $bytes cmd note vel
	    set cmd [format %02x [expr {$cmd&0xff}]]
	    switch -glob $cmd {
		8* {	# note off
		    switch $note {
			0 { dit-off }
			1 { dah-off }
			default { puts "at $frame received $cmd $note $vel" }
		    }
		}
		9* {	# note on
		    switch $note {
			0 { dit-on }
			1 { dah-on }
			default { puts "at $frame received $cmd $note $vel" }
		    }
		}
		default { puts "at $frame received $cmd $note $vel" }
	    }
	}
	default {
	    puts "at $frame received $bytes"
	}
    }
}

proc midi-receive-chan {frame bytes} {
    puts "at $frame received $bytes"
}

proc midi-format {bytes} {
    set f {}
    foreach b $bytes {
	set b [expr {$b&0xFF}]
	if {$b > 32 && $b < 128} {
	    append f [format %c $b]
	} else {
	    append f [format {[%02x]} $b]
	}
    }
    return $f
}

proc sysex-received-text {frame text} {
    puts "sysex-received-text: at $frame received: {$text}";
}
proc sysex-received-bytes {frame bytes} {
    set string [binary format c* $bytes]
    if {[string is print $string]} {
	puts "sysex-received-bytes: at $frame received string \"$string\""
    } else {
	puts -nonewline "sysex-received-bytes: at $frame received bytes: {";
	foreach b $bytes {
	puts -nonewline [format %02X [expr {$b&0xFF}]]
	}
	puts "}"
    }
}

proc midi-receive-sysex {frame bytes} {
    puts "midi-receive-sysex: at $frame received: [midi-format $bytes]"
    if {([lindex $bytes 0]&0xFF) != $::data(sysex-start)} {
	puts "midi-receive-sysex: at $frame sysex doesn't start with 0xF0: [midi-format $bytes]"
    } elseif {([lindex $bytes end]&0xFF) != $::data(sysex-end)} {
	puts "midi-receive-sysex: at $frame sysex doesn't end with 0xF7: [midi-format $bytes]"
    } elseif {[lindex $bytes 1] != $::data(vendor)} {
	puts "midi-receive-sysex: at $frame sysex doesn't have vendor id $::data(vendor): [midi-format $bytes]"
    } elseif {[lindex $bytes 2] == $::data(prefixq)} {
	sysex-received-text $frame [binary scan [lrange $bytes 3 end-1] c*]
    } elseif {[lindex $bytes 2] != $::data(prefix)} {
	puts "midi-receive-sysex: at $frame sysex has unexpected prefix: [midi-format $bytes]"
    } else {
	sysex-received-bytes $frame [midi-sysex-decode [lrange $bytes 3 end-1]]
    }
}

#
# receive input from midi poll
#
proc midi-receiver {events} {
    foreach e $events {
	lassign $e frame event
	binary scan $event c* bytes
	switch [format 0x%02X [expr {[lindex $bytes 0]&0xF0}]] {
	    0x80 -
	    0x90 -
	    0xA0 { midi-receive-note $frame $bytes }
	    0xB0 { midi-receive-chan $frame $bytes }
	    0xF0 { midi-receive-sysex $frame $bytes }
	    default {
		puts "midi-receiver: at $frame received [midi-format $bytes]"
	    }
	}
    }
}

#
# midi note key events
#
proc dit-off {} { .dit configure -bg grey; led-off red }
proc dah-off {} { .dah configure -bg grey; led-off blue }
proc dit-on {} { .dit configure -bg red; led-on red }
proc dah-on {} { .dah configure -bg blue; led-on blue }
		
proc generate-error {tag} {
    switch $tag {
	short1 { midi-raw [binary format cc 0xF0 0xF7] }
	odd { midi-raw [binary format ccc 0xF0 32 0xF7] }
	vendor { midi-raw [binary format ca*c 0xF0 "!\}" 0xF7] }
	prefix { midi-raw [binary format ca*c 0xF0 "\}\}" 0xF7] }
	short2 { midi-raw [binary format ca*c 0xF0 "\}!bb" 0xF7] }
	op { midi-raw [binary format ca*c 0xF0 "\}!baba" 0xF7] }
	device { midi-sysex {0 10} }
	default { error "generate-error for $tag?" }
    }
}

proc initialize {} {
    foreach e {short1 odd vendor prefix short2 op device} {
	generate-error $e
    }
    midi-sysex {}
    midi-sysex {0 0}
    midi-sysex {1 0x55}
}

#
# process options
#
proc main {argv} {
    grid [canvas .dit -width 32 -height 32] -row 0 -column 0 -sticky ew
    grid [canvas .dah -width 32 -height 32] -row 0 -column 1 -sticky ew
    grid [vfo::vfo .vfo] -row 1 -column 0 -columnspan 2 -sticky nsew
    grid [scrolled::text .log] -row 2 -column 0 -columnspan 2 -sticky nsew
    sdrkit::midi-tap midi-in
    sdrkit::midi-insert midi-out
    # keyer::debounce debounce
    # sdrkit::jack connect system:midi_capture_1 debounce:midi_in
    # sdrkit::jack connect debounce:midi_out midi-in:midi_in
    foreach p [split [exec jack_lsp] \n] {
	switch -glob $p {
	    system:midi_capture_* { set capture $p }
	    system:midi_playback_* { set playback $p }
	}
    }
    sdrkit::jack connect $capture midi-in:midi_in
    sdrkit::jack connect midi-out:midi_out $playback
    sdrkit::jack connect midi-out:midi_out midi-in:midi_in
    midi-in start
    midi-poll midi-in midi-receiver
    initialize
}

main $argv
