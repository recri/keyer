** Abstraction
   The code is evolving toward a really nice set of abstractions and
   implementations, but it's a bit of a mess at the moment and will
   continue to be a mess until I get it right.

   My basic gripe with existing SDR code is that it's hard to see what
   it does because it's usually buried inside some baroque mechanism
   for putting it together into the radio.  I can't see the parts
   because they've been potted in hot glue to stick them together.
   And that's a pity, because the parts are really simple when you get
   to see them clearly.

   I've extracted the bits that do the work into one library, and
   settled on using Tcl/Tk and Jack as the glue to put the parts
   together.  So you can see the computations without the glue, and
   then glue them together in a script to see how they work.
*** sdrkit - just the bits
    Sdrkit is plain SDR implementations in c and c++ without
    any distracting details.  Oscillators, filters, mixers,
    demodulation, modulation, keyers, debouncers, and so on.
    I'll include as many alternate implementations as I find the time
    to excavate for comparison. This is where you go to figure out how
    a particular computation is performed or to steal code for your
    own use.

    I'm doing sdrkit entirely as header files.  This is a bit
    different from the usual hide the implementation one place and
    expose an interface someplace else, but I've got nothing to hide
    and I get tired of groveling all over the place trying to figure
    out how things work.  It may not work out in the end, but it's
    worked so far for me.  You include the header which defines an
    interface and an implementation, define an instance, initialize,
    and use it. The code is all static to the file that includes it,
    so the unused parts can be optimized to nothing and the used parts
    can be inlined.
*** jack-tcl-wrap - the bits wrapped for use
    This code is my own baroque implementation of software hot glue.
    It wraps sdrkit components into Tcl so they can be loaded and
    executed within a Tcl/Tk application. This covers mostly boring
    stuff like command creation and deletion, options handling,
    subcommand processing, and the gory details of being a Jack
    component.  And it's all done through an evolving framework that
    abstracts out the common code, making it very terse and cryptic.
*** lib/* - tcl code and compiled loadable modules
    The lib directory is structured as a collection of sub-directories
    which could be safely installed into a system lib directory.
*** lib/sdrkit - where sdrkit installs loadable modules
    The lib/sdrkit directory contains, after you make them, a
    collection of shared object files.  The lib/sdrkit/pkgIndex.tcl
    file contains a catalog of the packages.
*** lib/wrap - Tcl code for wrapping up loadable modules
    The commands implemented by sdrkit are barebones computational
    modules.  The code in lib/wrap makes larger functional units.
*** lib/morse - Tcl code for morse code dictionaries
    I made a simple change to the interface for the ascii keyer, and
    it magically became a unicode enabled keyer.  So I copied the
    morse code tables for arabic, cyrillic, farsi, greek, hebrew and
    wabun and converted them into Tcl dicts which can be used to
    configure the ascii keyer.  There are also dicts for the ITU
    standard code, latin extensions, punctuation, and prosigns.
*** bin/* - tcl scripts implementing full applications.
    These are a mixed bag of Tcl/Tk applications which work pretty
    well in some cases and not at all in others.  The collection will
    evolve, I'll describe the ones I'm happiest with.
** A brief introduction to Tcl
    All of the library Tcl scripts and Tcl application scripts build
    on these basics.

    The end result of jack-tcl-wrap is a collection of Tcl packages,
    which are located in "~/keyer/lib/sdrkit" and indexed in
    "~/keyer/lib/sdrkit/pkgIndex.tcl".  You use them by running Tcl,
    and you run Tcl by executing the Tcl shell command, tclsh:
   #+BEGIN_EXAMPLE
     $ tclsh
     % 
   #+END_EXAMPLE
    You load packages by telling Tcl where to look:
   #+BEGIN_EXAMPLE
     % lappend auto_path ~/keyer/lib
     /usr/share/tcltk/tcl8.5 /usr/lib /usr/local/lib/tcltk /usr/local/share/tcltk /usr/lib/tcltk /usr/share/tcltk ~/keyer/lib
     %
   #+END_EXAMPLE
     and then telling Tcl what you need, say an oscillator:
   #+BEGIN_EXAMPLE
     % package require sdrkit::oscillator
     1.0.0
     %
   #+END_EXAMPLE
     Loading an sdrkit package usually creates a Tcl command factory
     with the same name as the package.  You use the factory command
     to create SDR modules.  So: 
   #+BEGIN_EXAMPLE
    % sdrkit::oscillator lo -freq 10000 -gain 0
    lo
    %
   #+END_EXAMPLE
    creates an oscillator named "lo" which oscillates at 10000 Hertz
    and has 0 decibels gain relative to full scale.  If you say:
   #+BEGIN_EXAMPLE
    % lo help
    unrecognized subcommand "help", should one of configure, cget, or cdoc
    %
   #+END_EXAMPLE
    then you get the list of recognized subcommands as an error.  If you say:
   #+BEGIN_EXAMPLE
    % join [lo configure] \n
    -server server Server default default
    -client client Client {} lo
    -gain gain Gain -30.0 -30.0
    -freq frequency Hertz 700.0 440.0
    %
   #+END_EXAMPLE
    then you get the list of (potentially) configurable options for
    "lo": the option names, some other names, a default value and the
    current value.  Which, in this case, shows a bug, that the -freq
    and -gain options to the command creation weren't effective,
    because the gain is -30dB and the frequency is 440Hz.  We can
    fix that with: 
   #+BEGIN_EXAMPLE
    % lo configure -freq 10000 -gain 0
    % 
   #+END_EXAMPLE
    and check the result with:
   #+BEGIN_EXAMPLE
    % lo cget -freq
    10000.0
    % lo cget -gain
    0.0
    % 
   #+END_EXAMPLE
   The -server and -client options tell us the Jack server and client
   name the module registered as.  These options are only configurable
   at creation. We can use:
   #+BEGIN_EXAMPLE
    % package require sdrkit::jack
    1.0.0
    % sdrkit::jack connect lo:out_i system:playback_1
    % sdrkit::jack connect lo:out_q system:playback_2
    %
   #+END_EXAMPLE
    to connect our complex local oscillator to the system audio
    out. Note that the sdrkit::jack package is an exception to the
    rule given above, it creates a simple command rather than a
    command factory.
** Options
   Most of the lib/sdrkit packages install a command factory which
   allows you to create as many instances of a module as an
   application requires.  Each module usually implements a series of
   sub-commands, including sub-commands for configuring, querying, and
   documenting the options implemented.

   Most of the lib/wrap packages inherit the options of the components
   they wrap, inherit the options of the Tk widgets which they use for
   the wrapping, and implement further options for convenience.

   And the applications in bin/* expose some or all of the options
   that their lib/sdrkit, lib/wrap, or Tk components implement.

*** common options for all apps
**** verbose - generates output to standard error.
     Will slow down the jack process callback if set high enough, but
     most widgets aren't implementing it.
**** server - specifies the jack server name to connect to.
**** client - specifies the jack client name to connect as.
*** common options for MIDI keyer apps
**** chan - specifies which midi channel the communication runs on.
     Note that midi channel 1 is encoded as 0 in midi events.
**** note - specifies which midi note is used for communication. In the
     case of keyer_iambic, "note" specifies the dit and the dah is found
     one higher.  Note that midi note 0 is encoded as 0 in midi events.
*** common options for morse code timing
**** word - specifies the number of dit clocks in a word.
     Use 50 for PARIS and 60 for CODEX.
**** wpm - specifies the words per minute.
     Used with "word" to compute the dit clocks per minute.
**** dah - specifies the number of dit clocks in a dah.
     Default value is 3.0.
**** ies - specifies the number of dit clocks in an inter-element space.
     Defaults value is 1.0.
**** ils - specifies the number of dit clocks in an inter-letter space.
     Defaults value is 3.0.
**** iws - specifies the number of dit clocks in an inter-word space.
     Defaults value is 7.0. You can jack this up get Farnsworth word 
     spacing where strings of letters are sent fast with large gaps
     between the words.
** keyer-ascii - ascii to midi morse keyer
   keyer_ascii implements the common options and the common timing
   options.

   You type to the program's standard input to supply the characters
   to be sent.  Anything it knows will be encoded, that which it
   doesn't know gets silently ignored.

   You can send prosigns by using the backslash.  The input sequence
   \sk will send ...-.-, and \\sos will send ...---...

   And you can insert option queries and settings inline with the <>
   syntax, so <wpm?> to query words per minute and <wpm22.5> to set
   "wpm" to 22.5.
** keyer-detime - midi to dit-dah-space decoder
   keyer-detime implements the common options and the timing options.
   It infers the dit clock rate from midi note on and off events and
   writes a stream of decoded '.',  '-', and ' ' to its standard
   output.  
** keyer-iambic - iambic paddle midi to midi morse keyer
   The iambic keyer implements the common options and the common
   timing options.  In addition it implements.

   "swap" reverses the sense of dit and dah.  Normally dit comes in on
   the "chan" channel at "note" and dah one note higher.  Default 0.

   "alsp" specifies if the keyer does automatic letter spacing or
   simply turns off.  Default 0.

   "awsp" specifies if the keyer does automatic word spacing or simply
   turns off.  Default 0.

   "mode" should specify if the keyer implements iambic mode A or mode
   B, but the keyer only does what it does at the moment.
** keyer-straight - using a straight key
   There isn't any app for this, you wire the MIDI system device
   directly to keyer_tone input, and make sure that your MidiKey
   is sending note 0 for the key, or reconfigure keyer_tone to listen
   to the channel and note your key is sending.
** keyer-tone - midi to i/q tone generator
   It uses a filter based I/Q oscillator which requires a couple of
   multiplies and adds for each step, and the steps are configured to
   be exactly the desired phase difference for each sample.

   It uses the same oscillator to generate a sine ramp for key on and
   key off.  The "rise" and "fall" times can be independently set to the
   desired number of milliseconds.

   The "ramp" option sets "rise" and "fall" to the same number of
   milliseconds.

   The other parameters to keyer_tone are "gain" in decibels and
   "freq" in hertz.
