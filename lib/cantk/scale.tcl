# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2024 by Roger E Critchlow Jr, Las Cruces, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

#
# a reimagined rotary encoder to replace sdrtk::dial, after looking at knobs
# on the internets, in particular https://www.youtube.com/watch?v=ppV28ftz2ZY
# which showed a way I'd never considered.
#
# scale simply abstracts the control of changing a value, so maybe we call it
# scalish, and then define scale and knob as derivatives which show the value
# changing.
#
# second goal is to rewrite with tcloo to avoid requiring snit.
#

package provide cantk::scale 1.0

package require Tk
package require snit
package require cantk::oklab

snit::widgetadaptor cantk::scalish {
    option -orient -default central -configuremethod config
    option -from -default 0 -configuremethod config
    option -to -default 100 -configuremethod config
    option -resolution -default 0.1 -configuremethod config
    option -digits -default 1 -configuremethod config
    option -value -default 50 -configuremethod config
    option -variable -default {} -configuremethod config
    option -command -default {} -configuremethod config
    option -render -default {} -configuremethod config

    delegate option * to hull
    delegate method * to hull

    variable data -array {}
    
    constructor {args} {
	installhull using canvas -takefocus 1
	$self configure {*}$args
	$self check-direction
	$self adjust-value $win 0
	set data(valwin) [ttk::label $win.label -textvariable [myvar data(value)]]

	# ttk::menubutton -textvar [myvar data(summary)]
	bind $win <Configure> [mymethod window-configure %W %w %h]

	# MouseWheel doesn't get generated by X Windows
	bind $win <MouseWheel> [mymethod adjust-mouse-value %W %D]

	# These are the events fired by X for MouseWheel
	bind $win <ButtonPress-5> [mymethod adjust-value %W +1]
	bind $win <ButtonPress-4> [mymethod adjust-value %W -1]

	# make the cursor motion keys adjust the scale
	foreach {event delta} {Up +1 Down -1 Right +1 Left -1 KP_Add +1 KP_Subtract -1} {
	    bind $win <$event> [mymethod adjust-value %W $delta]
	    bind $win <Control-$event> [mymethod adjust-value %W [expr {10*$delta}]]
	    bind $win <Shift-$event> [mymethod adjust-value %W [expr {10*$delta}]]
	    bind $win <Control-Shift-$event> [mymethod adjust-value %W [expr {100*$delta}]]
	}
	
	# bind the focus in/out events
	bind $win <FocusIn> [mymethod focus-handler %W 1]
	bind $win <FocusOut> [mymethod focus-handler %W 0]

	# bind the mouse button and motion
	foreach {event scale} {B1-ButtonPress 1 B1-Motion 1 B1-ButtonRelease 1} {
	    bind $win <$event> [mymethod button-press %W %x %y $scale]
	    bind $win <Control-$event> [mymethod button-press %W %x %y [expr {10*$scale}]]
	    bind $win <Shift-$event> [mymethod button-press %W %x %y [expr {10*$scale}]]
	    bind $win <Control-Shift-$event> [mymethod button-press %W %x %y [expr {100*$scale}]]
	}

	focus $win
    }

    method config {opt val} {
	# puts [list config $opt $val]
	switch -- $opt {
	    -from {
		if {[info exists options(-to)] && $opt == $options(-to)} {
		    error "degenerate range: -from $opt -to $options(-to)"
		} else {
		    set options($opt) $val
		    $self check-direction
		}
	    }
	    -to {
		if {[info exists options(-to)] && $opt == $options(-from)} {
		    error "degenerate range: -from $options(-from) -to $opt"
		} else {
		    set options($opt) $val
		    $self check-direction
		}
	    }
	    -resolution {
		set options($opt) $val
		$self check-direction
	    }
	    default {
		set options($opt) $val
	    }
	}
    }

    method check-direction {} {
	if {[info exists options(-from)] && 
	    [info exists options(-to)] &&
	    [info exists options(-resolution)]} {

	    set data(range) [expr {$options(-to)-$options(-from)}]
	    if {$data(range) > 0} {
		set data(min) $options(-from)
		set data(max) $options(-to)
	    } elseif {$options(-from) > $options(-to)} {
		set data(min) $options(-to)
		set data(max) $options(-from)
	    } else {
		error "degenerate range in check-direction: -from $options(-from) -to $options(-to)"
	    }
	}
    }

    method adjust-value {w steps} {
	# puts  "adjust-value $w $steps"
	# add $steps to the current value with the proper sign
	set value [expr {$options(-resolution)*$steps+$options(-value)}]
	# clamp the result to the minimum and maximu
	set value [expr {min($data(max), max($data(min), $value))}]
	# store in options
	set options(-value) $value
	# format for display
	set data(value) [format %.*f $options(-digits) $value]
	# render
	if {$options(-render) ne {}} {
	    {*}$options(-render)
	}
    }

    method adjust-mouse-value {w d} {
	$self adjust-value [expr {abs($d)>=120 ? int($d/120) : $d}]
    }

    method focus-handler {w in} {
	# puts "focus-handler $w $in"
	if {$in} {
	    place $data(valwin) -in $w
	} else {
	    place forget $data(valwin)
	}
    }

    method window-configure {w width height} {
	# runaway, change the window width, adds a border
	# $w configure -width $width -height $height
	if {$options(-render) ne {}} {
	    {*}$options(-render)
	}
    }

    method button-press {w x y s} { 
	# never seeing any of these
	# puts "button-press $w $x $y $s"
	focus $w
	$self segment $w $x $y $s
    }

    method button-motion {w x y $s} {
	#puts "button-motion $w $x $y $s"
	focus $w
	$self segment $w $x $y $s
    }

    method button-release {w x y $s} {
	#puts "button-release $w $x $y $s"
	focus $w
	$self segment $w $x $y $s
	$self finish $w
    }

    method segment {w x y s} {
	if {[info exists data(x)]} {
	    $self adjust-value $w [expr {$s*($x-$data(x)+$data(y)-$y)}]
	}
	set data(x) $x
	set data(y) $y
    }
    
    method finish {w} {
	unset data(x)
	unset data(y)
    }

}    

snit::widgetadaptor cantk::knob {
    option -start -default 240
    option -extent -default -300
    option -width -default 10
    option -inset -default 20
    option -dash -default {}
    option -outline -default black
    option -step-n -default 0;		# number of steps in the color blend
    option -step-width -default 0.5;	# width taper when rendering steps
    option -headp -default 0.6;		# proportion of radius for the dial pointer head
    option -tailp -default 0.2;		# proportion of radius for the dial pointer tail

    delegate option * to hull
    delegate method * to hull

    variable data -array {
	window-width 0
	window-height 0
    }

    constructor {args} {
	installhull using cantk::scalish -width 64 -height 64
	$self configure {*}$args
	$hull configure -render [mymethod render]
    }
    
    method render {} {
	# delete any previous rendering
	$win delete all

	# get the window size
	set width [$win cget -width]
	set height [$win cget -height]

	# compute a linear approximation to the full arc
	# this will be a list of interleaved x and y
	# we'll use a range of these coordinates
	# ! [info exists central(line)] ||
	if {$data(window-width) != $width || $data(window-height) != $height} {
	    # frame of circle which defines the arc
	    set diam [expr {min($width, $height)}]
	    set x0 [expr {$options(-inset) * $diam}]
	    set y0 [expr {$options(-inset) * $diam}]
	    set x1 [expr {$width-$options(-inset)*$diam}]
	    set y1 [expr {$height-$options(-inset)*$diam}]
	    # center of circle
	    set data(xc) [expr {($x0+$x1)/2.0}]
	    set data(yc) [expr {($y0+$y1)/2.0}]
	    # radius of circle
	    set data(r) [expr {min($data(xc)-$x0,$data(yc)-$y0)}]
	    # number of segments of perimeter
	    set n [expr {int(abs($options(-extent))/2)}]
	    set data(line) [arc-to-line $n $data(xc) $data(yc) $data(r) $options(-start) $options(-extent)]
	    set data(window-width) $width
	    set data(window-height) $height
	}

	# proportion of -value in -from to -to
	foreach opt {value from to} {
	    set data($opt) [$win cget -$opt] 
	}
	set p [expr {($data(value)-$data(from))/($data(to)-$data(from))}]

	# index of extent of arc
	set extent [expr {max(2,2*int($p*([llength $data(line)]/2)))}]

	# points to draw in arc
	set xy [lrange $data(line) 0 $extent+1]

	# point on perimeter that pointer points at
	# expressed as a vector from xc yc
	set xp [expr {[lindex $xy end-1]-$data(xc)}]
	set yp [expr {[lindex $xy end]-$data(yc)}]

	# compute endpoints of pointer line
	set xp1 [expr {$options(-headp)*$xp+$data(xc)}]
	set yp1 [expr {$options(-headp)*$yp+$data(yc)}]
	set xp2 [expr {$options(-tailp)*$xp+$data(xc)}]
	set yp2 [expr {$options(-tailp)*$yp+$data(yc)}]

	# draw with antialias hack
	set bg [color-lookup [$win cget -background]]
	set fg [color-lookup $options(-outline)]
	foreach {width color} [interpolate-width-and-color $options(-step-n) $options(-step-width) $options(-width) $fg $bg] {
	    $win create line $xy -width $width -fill $color -capstyle round
	    $win create line $xp1 $yp1 $xp2 $yp2 -width $width -fill $color -capstyle round
	}
    }

    proc color-lookup {c} {
	if { ! [regexp {^#[0-9A-Fa-f]+$} $c] || (([string length $c]-1)%3) != 0 || [string length $c] > 13} {
	    set new [winfo rgb . $c]
	    if {$new eq {}} { error "unknown color \"$c\'" }
	    set new [string cat \# [join [lmap x $new {format %04x $x}] {}]]
	    set c $new
	}
	set c
    }

    proc interpolate-width-and-color {step-n step-width width outline background} {
	# interpolate from background to outline color, then skip the background color
	set result {}
	foreach c [lrange [hexrgb_interpolate ${step-n} $background $outline] 1 end] {
	    lappend result $width $c
	    set width [expr {$width-${step-width}}]; 	# or maybe 2*${step-width}
	}
	set result
    }
    
    proc arc-to-line {n xc yc r start extent} {
	# puts "xc $xc yc $yc r $r"
	# put the angles of the endpoints of the arc on as
	# while the list of angles is less than the resolution $n
	# double the number of angles by bisecting the arcs
	for {set as [list $start [expr {$start+$extent}]]} {[llength $as] < $n} {set as $nas} {
	    set nas {}
	    foreach a1 [lrange $as 0 end-1] a2 [lrange $as 1 end] {
		lappend nas $a1 [expr {($a1+$a2)/2.0}]
	    }
	    lappend nas [lindex $as end]
	}
	# puts "as: $as"
	set xy {}
	foreach a $as {
	    lappend xy [expr {$xc+$r*cos($a*3.14159/180.0)}] [expr {$yc-$r*sin($a*3.14159/180.0)}]
	}
	# puts "xy: [lmap c  $xy {format %.2f $c}]"
	return $xy
    }
}

    ########################################################################
    # standard options for Tk scale
    #
    #       -activebackground     -foreground          -relief
    #       -background           -highlightbackground -repeatdelay
    #       -borderwidth          -highlightcolor      -repeatinterval
    #       -cursor               -highlightthickness  -takefocus
    #       -font                 -orient              -troughcolor
    # 
    # Widget specific options for Tk scale
    #	-bigincrement	- default 1/10th of scale range
    #	-command	- invoked when scale changes value
    #	-digits		- digits of precision
    #	-label
    #	-length		- the desired long dimension of the scale
    #	-resolution	- value rounded to multiple of this
    #	-showvalue	- should the current value be displayed 
    #	-sliderlength	- the size of the slider along the long dimension
    #	-sliderrelief
    #	-state		- normal, active, or disabled
    #	-tickinterval
    #	-to
    #	-variable
    #	-width		- narrow dimension
    #
    # Widget methods for Tk scale
    #
    #	cget
    #	configure
    #	coords
    #	get
    #	identify
    #	set
    #
    # Bindings for Tk scale
    #	<Button-1> in trough, +/- $options(-resolution)
    #	<Button-1> on slider, drag slider to value
    #	<Control-Button-1> in trough to end of range
    #	<Button-2> scale set to mouse position
    #	<KeyPress-Up> <KeyPress-Right> value += $options(-resolution)
    #	<KeyPress-Down> <KeyPress-Left> value -= $options(-resolution)
    #	<Control-KeyPress-Up> <Control-KeyPress-Right> value += $options(-bigincrement)
    #	<Control-KeyPress-Down> <Control-KeyPress-Left> value -= $options(-bigincrement)
    #	<KeyPress-Home> moves to top/left end of range
    #	<KeyPress-End> moves to left/bottom end of range
    #
    ########################################################################
    # Standard options for ttk::scale
    #
    #       -class                -cursor              -style
    #       -takefocus
    #
    # Widget-Specific Options for ttk::scale
    #
    #	-command
    #	-from
    #	-length
    #	-orient
    #	-to
    #	-value
    #	-variable
    #
    # Widget commands for ttk::scale
    #
    #	cget
    #	configure
    #	get
    #	identify
    #	instate
    #	set
    #	state
    #
    # Styling Options for ttk::scale, clas sname TScale
    #
    #	-background
    #	-borderwidth
    #	-darkcolor
    #	-groovewidth
    #	-lightcolor
    #	-sliderwidth
    #	-troughcolor
    #	-troughrelief
    #
