# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2024 by Roger E Critchlow Jr, Las Cruces, NM, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

#
# a reimagined rotary encoder to replace sdrtk::dial, after looking at knobs
# on the internets, in particular https://www.youtube.com/watch?v=ppV28ftz2ZY
# which showed a way I'd never considered.
#
# scale simply abstracts the control of changing a value, so maybe we call it
# scalish, and then define scale and knob as derivatives which show the value
# changing.
#
# second goal is to rewrite with tcloo to avoid requiring snit.
#

package provide cantk::scale 1.0

package require Tk
package require snit
package require cantk::oklab

snit::widgetadaptor cantk::scale {
    option -orient -default central -configuremethod config
    option -from -default 0 -configuremethod config
    option -to -default 100 -configuremethod config
    option -resolution -default 0.1 -configuremethod config
    option -digits -default 1 -configuremethod config
    option -value -default 50 -configuremethod config
    option -variable -default {} -configuremethod config
    option -command -default {} -configuremethod config
    option -render -default cantk::scale-central -configuremethod config
    
    delegate option * to hull
    delegate method * to hull

    variable data -array {}
    
    constructor {args} {
	installhull using canvas -takefocus 1
	$self configure {*}$args
	$self check-direction
	$self adjust-value $win 0
	set data(valwin) [ttk::label $win.label -textvariable [myvar data(value)]]

	# ttk::menubutton -textvar [myvar data(summary)]
	bind $win <Configure> [mymethod window-configure %W %w %h]

	# MouseWheel doesn't get generated by X Windows
	bind $win <MouseWheel> [mymethod adjust-mouse-value %W %D]

	# These are the events fired by X for MouseWheel
	bind $win <ButtonPress-5> [mymethod adjust-value %W +1]
	bind $win <ButtonPress-4> [mymethod adjust-value %W -1]

	# make the cursor motion keys adjust the scale
	foreach {event delta} {Up +1 Down -1 Right +1 Left -1 KP_Add +1 KP_Subtract -1} {
	    bind $win <$event> [mymethod adjust-value %W $delta]
	    bind $win <Control-$event> [mymethod adjust-value %W [expr {10*$delta}]]
	    bind $win <Shift-$event> [mymethod adjust-value %W [expr {10*$delta}]]
	    bind $win <Control-Shift-$event> [mymethod adjust-value %W [expr {100*$delta}]]
	}
	
	# bind the focus in/out events
	bind $win <FocusIn> [mymethod focus-handler %W 1]
	bind $win <FocusOut> [mymethod focus-handler %W 0]

	# bind the mouse button and motion
	foreach {event scale} {B1-ButtonPress 1 B1-Motion 1 B1-ButtonRelease 1} {
	    bind $win <$event> [mymethod button-press %W %x %y $scale]
	    bind $win <Control-$event> [mymethod button-press %W %x %y [expr {10*$scale}]]
	    bind $win <Shift-$event> [mymethod button-press %W %x %y [expr {10*$scale}]]
	    bind $win <Control-Shift-$event> [mymethod button-press %W %x %y [expr {100*$scale}]]
	}

	focus $win
    }

    method config {opt val} {
	# puts [list config $opt $val]
	switch -- $opt {
	    -from {
		if {[info exists options(-to)] && $opt == $options(-to)} {
		    error "degenerate range: -from $opt -to $options(-to)"
		} else {
		    set options($opt) $val
		    $self check-direction
		}
	    }
	    -to {
		if {[info exists options(-to)] && $opt == $options(-from)} {
		    error "degenerate range: -from $options(-from) -to $opt"
		} else {
		    set options($opt) $val
		    $self check-direction
		}
	    }
	    -resolution {
		set options($opt) $val
		$self check-direction
	    }
	    default {
		set options($opt) $val
	    }
	}
    }

    method check-direction {} {
	if {[info exists options(-from)] && 
	    [info exists options(-to)] &&
	    [info exists options(-resolution)]} {

	    set data(range) [expr {$options(-to)-$options(-from)}]
	    if {$data(range) > 0} {
		set data(min) $options(-from)
		set data(max) $options(-to)
	    } elseif {$options(-from) > $options(-to)} {
		set data(min) $options(-to)
		set data(max) $options(-from)
	    } else {
		error "degenerate range in check-direction: -from $options(-from) -to $options(-to)"
	    }
	}
    }

    method adjust-value {w steps} {
	# puts  "adjust-value $w $steps"
	# add $steps to the current value with the proper sign
	set value [expr {$options(-resolution)*$steps+$options(-value)}]
	# clamp the result to the minimum and maximu
	set value [expr {min($data(max), max($data(min), $value))}]
	# store in options
	set options(-value) $value
	# format for display
	set data(value) [format %.*f $options(-digits) $value]
	# render the updated value
	if {$options(-render) ne {}} {
	    $options(-render) $w
	}
    }

    method adjust-mouse-value {w d} {
	$self adjust-value [expr {abs($d)>=120 ? int($d/120) : $d}]
    }

    method focus-handler {w in} {
	# puts "focus-handler $w $in"
	if {$in} {
	    place $data(valwin) -in $w
	} else {
	    place forget $data(valwin)
	}
    }

    method window-configure {w width height} {
	# runaway, change the window width, adds a border
	# $w configure -width $width -height $height
    }

    method button-press {w x y s} { 
	# never seeing any of these
	# puts "button-press $w $x $y $s"
	focus $w
	$self segment $w $x $y $s
    }

    method button-motion {w x y $s} {
	#puts "button-motion $w $x $y $s"
	focus $w
	$self segment $w $x $y $s
    }

    method button-release {w x y $s} {
	#puts "button-release $w $x $y $s"
	focus $w
	$self segment $w $x $y $s
	$self finish $w
    }

    method segment {w x y s} {
	if {[info exists data(x)]} {
	    $self adjust-value $w [expr {$s*($x-$data(x)+$data(y)-$y)}]
	}
	set data(x) $x
	set data(y) $y
    }
    
    method finish {w} {
	unset data(x)
	unset data(y)
    }

}    

#
# degrees measured from 3 o'clock counterclockwise
# -style is arc, which only draws the perimeter
# -width specifies the perimeter line thickness
# -outline specifies the perimeter line color
# -dash specifies a dash pattern using {.,- }
# $w create arc 0 0 width height -start degrees -extent degrees
array set ::cantk::scale-knob {
    start 240
    extent -300
    width 10
    inset 20
    dash {}
    outline black
    step-n 0
    step-width 0.5
    headp 0.6
    tailp -0.2
    window-width 0
    window-height 0
}

#
# okay, broken dreams
# 1) canvas arc doesn't comply to spec, draws an pie outline
# 2) canvas draws ugly jagged lines
# 3) tried the JKnobMan route, 27 image strip came to 188Kbytes
#
# So, roll your own:
# 1) draw a series of lines, interpolating from background color to
#    forground color, getting thinner as we get to foreground color.
# 2) ideally, you would adjust the alpha in a gradient from edge of
#    the line to the center, but Tk doen't do alpha.
# 3) draw the path for the arc manually.  Make the line segments from
#    start to start+extent at <1 degree resolution.
#
proc cantk::scale-central {w} {
    upvar data data options options

    # copy knob data into data
    if { ! [info exists data(knob-start)]} {
	foreach {name value} [array get ::cantk::scale-knob] {
	    set data(knob-$name) $value
	}
    }
    
    # delete any previous rendering
    $w delete all

    # get the window size
    set width [$w cget -width]
    set height [$w cget -height]

    # compute a linear approximation to the full arc
    # this will be a list of interleaved x and y
    # we'll use a range of these coordinates
    # ! [info exists central(line)] ||
    if {$data(knob-window-width) != $width || $data(knob-window-height) != $height} {
	# frame of circle which defines the arc
	set x0 $data(knob-inset)
	set y0 $data(knob-inset)
	set x1 [expr {$width-$data(knob-inset)}]
	set y1 [expr {$height-$data(knob-inset)}]
	# center of circle
	set data(knob-xc) [expr {($x0+$x1)/2.0}]
	set data(knob-yc) [expr {($y0+$y1)/2.0}]
	# radius of circle
	set data(knob-r) [expr {min($data(knob-xc)-$x0,$data(knob-yc)-$y0)}]
	# number of segments of perimeter
	set n [expr {int(abs($data(knob-extent))/2)}]
	set data(knob-line) [arc-to-line $n $data(knob-xc) $data(knob-yc) $data(knob-r) $data(knob-start) $data(knob-extent)]
	set data(knob-window-width) $width
	set data(knob-window-height) $height
    }

    # proportion of -value in -from to -to
    set p [expr {($options(-value)-$options(-from))/($options(-to)-$options(-from))}]

    # index of extent of arc
    set extent [expr {max(2,2*int($p*([llength $data(knob-line)]/2)))}]

    # points to draw in arc
    set xy [lrange $data(knob-line) 0 $extent+1]

    # point on perimeter that pointer points at
    # expressed as a vector from xc yc
    set xp [expr {[lindex $xy end-1]-$data(knob-xc)}]
    set yp [expr {[lindex $xy end]-$data(knob-yc)}]

    # compute endpoints of pointer line
    set xp1 [expr {$data(knob-headp)*$xp+$data(knob-xc)}]
    set yp1 [expr {$data(knob-headp)*$yp+$data(knob-yc)}]
    set xp2 [expr {$data(knob-tailp)*$xp+$data(knob-xc)}]
    set yp2 [expr {$data(knob-tailp)*$yp+$data(knob-yc)}]

    # draw with antialias hack
    set bg [color-lookup [$w cget -background]]
    set fg [color-lookup $data(knob-outline)]
    foreach {width color} [interpolate-width-and-color $data(knob-step-n) $data(knob-step-width) $data(knob-width) $fg $bg] {
	$w create line $xy -width $width -fill $color -capstyle round
	$w create line $xp1 $yp1 $xp2 $yp2 -width $width -fill $color -capstyle round
    }
}

proc color-lookup {c} {
    if { ! [regexp {^#[0-9A-Fa-f]+$} $c] || (([string length $c]-1)%3) != 0 || [string length $c] > 13} {
	set new [winfo rgb . $c]
	if {$new eq {}} { error "unknown color \"$c\'" }
	set new [string cat \# [join [lmap x $new {format %04x $x}] {}]]
	set c $new
    }
    set c
}

proc interpolate-width-and-color {step-n step-width width outline background} {
    # interpolate from background to outline color, then skip the background color
    set result {}
    foreach c [lrange [hexrgb_interpolate ${step-n} $background $outline] 1 end] {
	lappend result $width $c
	set width [expr {$width-${step-width}}]; 	# or maybe 2*${step-width}
    }
    set result
}

proc arc-to-line {n xc yc r start extent} {
    # puts "xc $xc yc $yc r $r"
    # put the angles of the endpoints of the arc on as
    # while the list of angles is less than the resolution $n
    # double the number of angles by bisecting the arcs
    for {set as [list $start [expr {$start+$extent}]]} {[llength $as] < $n} {set as $nas} {
	set nas {}
	foreach a1 [lrange $as 0 end-1] a2 [lrange $as 1 end] {
	    lappend nas $a1 [expr {($a1+$a2)/2.0}]
	}
	lappend nas [lindex $as end]
    }
    # puts "as: $as"
    set xy {}
    foreach a $as {
	lappend xy [expr {$xc+$r*cos($a*3.14159/180.0)}] [expr {$yc-$r*sin($a*3.14159/180.0)}]
    }
    # puts "xy: [lmap c  $xy {format %.2f $c}]"
    return $xy
}

########################################################################
# standard options for Tk scale
#
#       -activebackground     -foreground          -relief
#       -background           -highlightbackground -repeatdelay
#       -borderwidth          -highlightcolor      -repeatinterval
#       -cursor               -highlightthickness  -takefocus
#       -font                 -orient              -troughcolor
# 
# Widget specific options for Tk scale
#	-bigincrement	- default 1/10th of scale range
#	-command	- invoked when scale changes value
#	-digits		- digits of precision
#	-label
#	-length		- the desired long dimension of the scale
#	-resolution	- value rounded to multiple of this
#	-showvalue	- should the current value be displayed 
#	-sliderlength	- the size of the slider along the long dimension
#	-sliderrelief
#	-state		- normal, active, or disabled
#	-tickinterval
#	-to
#	-variable
#	-width		- narrow dimension
#
# Widget methods for Tk scale
#
#	cget
#	configure
#	coords
#	get
#	identify
#	set
#
# Bindings for Tk scale
#	<Button-1> in trough, +/- $options(-resolution)
#	<Button-1> on slider, drag slider to value
#	<Control-Button-1> in trough to end of range
#	<Button-2> scale set to mouse position
#	<KeyPress-Up> <KeyPress-Right> value += $options(-resolution)
#	<KeyPress-Down> <KeyPress-Left> value -= $options(-resolution)
#	<Control-KeyPress-Up> <Control-KeyPress-Right> value += $options(-bigincrement)
 #	<Control-KeyPress-Down> <Control-KeyPress-Left> value -= $options(-bigincrement)
#	<KeyPress-Home> moves to top/left end of range
#	<KeyPress-End> moves to left/bottom end of range
#
########################################################################
# Standard options for ttk::scale
#
#       -class                -cursor              -style
#       -takefocus
#
# Widget-Specific Options for ttk::scale
#
#	-command
#	-from
#	-length
#	-orient
#	-to
#	-value
#	-variable
#
# Widget commands for ttk::scale
#
#	cget
#	configure
#	get
#	identify
#	instate
#	set
#	state
#
# Styling Options for ttk::scale, clas sname TScale
#
#	-background
#	-borderwidth
#	-darkcolor
#	-groovewidth
#	-lightcolor
#	-sliderwidth
#	-troughcolor
#	-troughrelief
#
